<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Deriv Digit Match Pro - AI Enhanced</title>
<style>
/* --- CORE STYLES --- */
body { background: #020617; color: #e5e7eb; font-family: system-ui, -apple-system, sans-serif; margin: 0; padding: 0; }
.app { max-width: 420px; margin: auto; padding: 15px; }
.card { background: #0f172a; padding: 12px; border-radius: 12px; margin-bottom: 12px; border: 1px solid #1e293b; }
h2, h3 { text-align: center; margin-bottom: 8px; margin-top: 8px; }
h2 { color: #22c55e; }
label { font-size: 13px; opacity: 0.8; display: block; margin-top: 8px; }
input[type="number"], input[type="password"], select, button { width: 100%; padding: 10px; margin: 5px 0 10px; border-radius: 8px; border: none; box-sizing: border-box; }
input, select { background: #1e293b; color: #e5e7eb; border: 1px solid #334155; }
input:focus, select:focus { outline: none; border-color: #22c55e; }
button { background: #22c55e; color: #020617; font-weight: 700; cursor: pointer; transition: all 0.2s; }
button:hover { background: #16a34a; transform: translateY(-1px); }
button:active { transform: translateY(0); }
button:disabled { background: #374151; cursor: not-allowed; opacity: 0.5; }
.buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 12px; }
.status-container { display: flex; gap: 5px; margin-bottom: 10px; }
.status { flex: 2; text-align: center; padding: 8px; border-radius: 8px; font-weight: 600; }
.account-type { flex: 1.5; text-align: center; padding: 8px; border-radius: 8px; font-weight: 700; font-size: 11px; display: none; text-transform: uppercase; align-self: center; }
.demo-badge { background: #f59e0b; color: #020617; }
.live-badge { background: #22c55e; color: #020617; }
.connected { background: #16a34a; color: white; }
.disconnected { background: #dc2626; color: white; }
.stats { display: grid; grid-template-columns: repeat(4, 1fr); text-align: center; gap: 10px; }
.stats > div { display: flex; flex-direction: column; gap: 5px; }
.stats span { font-size: 12px; opacity: 0.7; }
.stats b { font-size: 16px; color: #22c55e; }
.table-container { overflow-x: auto; max-height: 300px; overflow-y: auto; }
table { width: 100%; font-size: 13px; border-collapse: collapse; }
thead { position: sticky; top: 0; background: #1e293b; }
th { padding: 8px; text-align: left; font-weight: 600; border-bottom: 2px solid #334155; }
td { padding: 8px; border-bottom: 1px solid #1e293b; }
tbody tr:hover { background: #1e293b; }
.win { color: #22c55e; }
.loss { color: #ef4444; }
.balance-display { text-align: center; padding: 10px; background: #0f172a; border-radius: 8px; margin-bottom: 10px; border: 1px solid #1e293b; }
.balance-display span { opacity: 0.7; font-size: 14px; }
.balance-display b { color: #22c55e; font-size: 18px; margin: 0 5px; }
.session-timer { margin-top: 8px; font-size: 12px; color: #f59e0b; font-weight: 600; }
.reset-button-permanent { background: #f59e0b !important; width: 100%; margin-bottom: 12px; font-size: 15px; display: block; }
.reset-button-permanent:hover { background: #d97706 !important; }
.analyzer-grid { display: grid; grid-template-columns: repeat(10, 1fr); gap: 5px; margin: 10px 0; }
.digit-box { aspect-ratio: 1; display: flex; align-items: center; justify-content: center; border-radius: 6px; font-weight: 700; font-size: 14px; border: 2px solid transparent; }
.digit-match { background: #8b5cf6; color: white; border-color: #22c55e; }
.digit-other { background: #1e293b; color: #94a3b8; }
.analyzer-stats { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; text-align: center; margin-top: 10px; }
.analyzer-stats > div { background: #1e293b; padding: 8px; border-radius: 6px; }
.analyzer-stats span { font-size: 11px; opacity: 0.7; display: block; }
.analyzer-stats b { font-size: 18px; display: block; margin-top: 3px; }
.log-container { background: #020617; border: 1px solid #1e293b; border-radius: 6px; height: 120px; overflow-y: auto; padding: 8px; font-family: 'Courier New', monospace; font-size: 11px; margin-top: 10px; }
.log-entry { margin-bottom: 4px; border-bottom: 1px solid #1e293b; padding-bottom: 2px; }
.log-time { color: #94a3b8; margin-right: 5px; }
.log-msg-info { color: #3b82f6; }
.log-msg-success { color: #22c55e; }
.log-msg-error { color: #ef4444; }
.log-msg-warn { color: #f59e0b; }
.btn-cycle { background: #3b82f6; color: white; margin-bottom: 5px; font-size: 14px; }
.btn-cycle.active { background: #8b5cf6; border: 2px solid #fff; }
.btn-cooldown { background: #475569; color: white; margin-bottom: 5px; font-size: 14px; }
.btn-cooldown.active { background: #f59e0b; color: #020617; border: 2px solid #020617; }
.cycle-timer-display { color: #f59e0b; font-size: 13px; font-weight: bold; text-align: center; margin-bottom: 10px; display: none; padding: 8px; border: 2px dashed #f59e0b; border-radius: 8px; background: rgba(245, 158, 11, 0.1); }

/* Radio Button Styles */
.radio-group { margin: 10px 0; }
.radio-option { display: flex; align-items: center; padding: 8px; margin: 5px 0; background: #1e293b; border-radius: 6px; cursor: pointer; border: 2px solid #334155; transition: all 0.2s; }
.radio-option:hover { border-color: #22c55e; background: #1e3a2b; }
.radio-option input[type="radio"] { margin-right: 10px; cursor: pointer; width: auto; }
.radio-option.selected { border-color: #22c55e; background: #1e3a2b; }
.radio-option label { cursor: pointer; margin: 0; opacity: 1; font-size: 13px; font-weight: 600; width: 100%; }

/* Prediction & Metrics */
.prediction-box { background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); border: 2px solid #8b5cf6; border-radius: 8px; padding: 15px; margin: 10px 0; text-align: center; }
.prediction-status { font-size: 14px; font-weight: 700; color: #94a3b8; margin-bottom: 10px; }
.prediction-digit { font-size: 48px; font-weight: 900; margin: 15px 0; }
.prediction-waiting { color: #f59e0b; }
.prediction-ready { color: #22c55e; animation: pulse 1.5s infinite; }
@keyframes pulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.8; transform: scale(1.05); }
}
.prediction-info { font-size: 11px; opacity: 0.7; margin-top: 10px; line-height: 1.5; }

.accuracy-metrics { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-top: 12px; }
.accuracy-card { background: #020617; padding: 10px; border-radius: 6px; border: 1px solid #334155; text-align: center; }
.accuracy-card .label { font-size: 10px; color: #94a3b8; margin-bottom: 5px; }
.accuracy-card .value { font-size: 18px; font-weight: 700; color: #8b5cf6; }
.confidence-bar { width: 100%; height: 8px; background: #1e293b; border-radius: 4px; overflow: hidden; margin-top: 10px; }
.confidence-fill { height: 100%; background: linear-gradient(90deg, #ef4444, #f59e0b, #22c55e); transition: width 0.3s; }
.pattern-indicator { margin-top: 10px; padding: 8px; background: #1e293b; border-radius: 6px; font-size: 11px; }
.pattern-strong { border-left: 4px solid #22c55e; }
.pattern-medium { border-left: 4px solid #f59e0b; }
.pattern-weak { border-left: 4px solid #ef4444; }

/* Toggle Switch Style */
.switch-container { display: flex; justify-content: space-between; align-items: center; background: #1e293b; padding: 10px; border-radius: 8px; border: 1px solid #ef4444; margin-bottom: 10px; }
.switch-label { color: #ef4444; font-weight: bold; font-size: 14px; }
.toggle-checkbox { width: 20px !important; height: 20px !important; margin: 0 !important; cursor: pointer; }

/* Virtual Trade Styles */
.virtual-trade-container { background: #1e293b; padding: 10px; border-radius: 8px; border: 2px solid #8b5cf6; margin-bottom: 10px; }
.virtual-trade-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
.virtual-trade-label { color: #8b5cf6; font-weight: bold; font-size: 14px; }
.virtual-mode-badge { background: #8b5cf6; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 700; display: none; }
.virtual-mode-badge.active { display: inline-block; animation: blink 1.5s infinite; }
@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}
.virtual-stats { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-top: 10px; }
.virtual-stat-box { background: #0f172a; padding: 8px; border-radius: 6px; text-align: center; border: 1px solid #334155; }
.virtual-stat-box span { font-size: 10px; color: #94a3b8; display: block; }
.virtual-stat-box b { font-size: 16px; color: #8b5cf6; display: block; margin-top: 3px; }

/* Loss Streak Boxes */
.streak-boxes { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; margin-top: 10px; }
.streak-box { background: #0f172a; padding: 8px; border-radius: 6px; text-align: center; border: 1px solid #334155; }
.streak-box span { font-size: 9px; color: #94a3b8; display: block; margin-bottom: 3px; }
.streak-box b { font-size: 16px; color: #ef4444; display: block; }

/* AI Model Selector */
.ai-model-selector { background: #1e293b; padding: 10px; border-radius: 8px; border: 2px solid #3b82f6; margin-bottom: 10px; }
.ai-model-label { color: #3b82f6; font-weight: bold; font-size: 14px; margin-bottom: 8px; }
.model-option { display: flex; align-items: center; padding: 6px; margin: 4px 0; background: #0f172a; border-radius: 4px; cursor: pointer; border: 2px solid #334155; transition: all 0.2s; }
.model-option:hover { border-color: #3b82f6; }
.model-option.selected { border-color: #3b82f6; background: #1e3a4b; }
.model-option input[type="radio"] { margin-right: 8px; cursor: pointer; width: auto; }
.model-option label { cursor: pointer; margin: 0; font-size: 12px; width: 100%; }
.model-description { font-size: 9px; opacity: 0.6; margin-top: 2px; }
.ai-training-status { font-size: 10px; color: #f59e0b; margin-top: 8px; text-align: center; }

/* Contract Type Selector */
.contract-type-selector { background: #1e293b; padding: 10px; border-radius: 8px; border: 2px solid #f59e0b; margin-bottom: 10px; }
.contract-type-label { color: #f59e0b; font-weight: bold; font-size: 14px; margin-bottom: 8px; }
.contract-option { display: flex; align-items: center; padding: 6px; margin: 4px 0; background: #0f172a; border-radius: 4px; cursor: pointer; border: 2px solid #334155; transition: all 0.2s; }
.contract-option:hover { border-color: #f59e0b; }
.contract-option.selected { border-color: #f59e0b; background: #3a2e1b; }
.contract-option input[type="radio"] { margin-right: 8px; cursor: pointer; width: auto; }
.contract-option label { cursor: pointer; margin: 0; font-size: 12px; width: 100%; }
.contract-description { font-size: 9px; opacity: 0.6; margin-top: 2px; }

/* Advanced Filters */
.filter-container { background: #1e293b; padding: 10px; border-radius: 8px; border: 2px solid #ec4899; margin-bottom: 10px; }
.filter-label { color: #ec4899; font-weight: bold; font-size: 14px; margin-bottom: 8px; }
.filter-toggle-row { display: flex; justify-content: space-between; align-items: center; background: #0f172a; padding: 8px; border-radius: 6px; margin: 4px 0; border: 1px solid #334155; }
.filter-toggle-label { font-size: 12px; font-weight: 600; }
.filter-checkbox { width: 20px !important; height: 20px !important; margin: 0 !important; cursor: pointer; }
.filter-status { font-size: 10px; margin-top: 5px; padding: 5px; border-radius: 4px; text-align: center; }
.filter-active { background: #22c55e33; color: #22c55e; }
.filter-inactive { background: #ef444433; color: #ef4444; }
.ensemble-selector { background: #0f172a; padding: 8px; border-radius: 6px; margin-top: 8px; border: 1px solid #334155; }
.ensemble-option-row { display: flex; align-items: center; padding: 4px; margin: 2px 0; }
.ensemble-option-row input[type="radio"] { margin-right: 8px; width: auto; cursor: pointer; }
.ensemble-option-row label { font-size: 11px; cursor: pointer; margin: 0; }

/* Consecutive Loss Counter */
.consec-loss-indicator { background: #1e293b; padding: 8px; border-radius: 6px; text-align: center; margin-top: 8px; border: 1px solid #334155; }
.consec-loss-indicator span { font-size: 10px; color: #94a3b8; display: block; margin-bottom: 3px; }
.consec-loss-indicator b { font-size: 16px; color: #ef4444; display: block; }

/* Auto Resume Timer Styles */
.auto-resume-container { background: #1e293b; padding: 10px; border-radius: 8px; border: 2px solid #3b82f6; margin-bottom: 10px; }
.auto-resume-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
.auto-resume-label { color: #3b82f6; font-weight: bold; font-size: 14px; }
.auto-resume-badge { background: #3b82f6; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 700; display: none; }
.auto-resume-badge.active { display: inline-block; animation: blink 1.5s infinite; }
.timer-display { color: #3b82f6; font-size: 13px; font-weight: bold; text-align: center; margin-top: 10px; padding: 8px; border: 2px dashed #3b82f6; border-radius: 8px; background: rgba(59, 130, 246, 0.1); display: none; }
.cumulative-profit-box { background: #0f172a; padding: 10px; border-radius: 6px; text-align: center; border: 1px solid #334155; margin-top: 10px; }
.cumulative-profit-box span { font-size: 10px; color: #94a3b8; display: block; margin-bottom: 3px; }
.cumulative-profit-box b { font-size: 20px; display: block; }
</style>
</head>
<body>
<div class="app">

<h2>Deriv Digit Match Pro - AI Enhanced</h2>

<div class="status-container">
    <div id="status" class="status disconnected">Disconnected</div>
    <div id="accountType" class="account-type"></div>
</div>

<div id="balanceDisplay" class="balance-display" style="display:none;">
  <span>Balance:</span>
  <b id="balance">0.00</b>
  <span id="balanceCurrency">USD</span>
  <div id="sessionTimer" class="session-timer">Session: 00:00:00</div>
</div>

<div class="card">
  <input id="token" type="password" placeholder="Deriv API Token" required>
  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <button id="loginBtn">Login</button>
    <button id="logoutBtn" style="background: #ef4444;">Logout</button>
  </div>
</div>

<div class="card">
  <h3>üìä Contract Type Selection</h3>
  <div class="contract-type-selector">
    <div class="contract-type-label">Select Contract Type:</div>
    <div class="contract-option selected" data-contract="DIGITMATCH">
      <input type="radio" name="contractType" value="DIGITMATCH" id="contractDigitMatch" checked>
      <div style="flex: 1;">
        <label for="contractDigitMatch">Digit Match</label>
        <div class="contract-description">Predict exact last digit - Uses AI prediction</div>
      </div>
    </div>
    <div class="contract-option" data-contract="DIGITOVER">
      <input type="radio" name="contractType" value="DIGITOVER" id="contractDigitOver">
      <div style="flex: 1;">
        <label for="contractDigitOver">Digit Over 5</label>
        <div class="contract-description">Last digit will be over 5 (6,7,8,9)</div>
      </div>
    </div>
    <div class="contract-option" data-contract="DIGITUNDER">
      <input type="radio" name="contractType" value="DIGITUNDER" id="contractDigitUnder">
      <div style="flex: 1;">
        <label for="contractDigitUnder">Digit Under 5</label>
        <div class="contract-description">Last digit will be under 5 (0,1,2,3,4)</div>
      </div>
    </div>
  </div>
</div>

<div class="card">
  <h3>‚ö° Advanced Trading Filters</h3>
  <div class="filter-container">
    <div class="filter-label">Smart Risk Management Filters</div>
    
    <!-- Volatility Filter -->
    <div class="filter-toggle-row">
      <span class="filter-toggle-label">Volatility Filter</span>
      <input type="checkbox" id="volatilityFilterToggle" class="filter-checkbox save-setting" onchange="updateFilterStatus()">
    </div>
    <div id="volatilityFilterStatus" class="filter-status filter-inactive">
      ‚ùå Blocks trades when market is chaotic (8+ unique digits in last 10 ticks)
    </div>
    
    <!-- Ensemble Consensus Filter -->
    <div class="filter-toggle-row" style="margin-top: 10px;">
      <span class="filter-toggle-label">Ensemble Consensus</span>
      <input type="checkbox" id="ensembleFilterToggle" class="filter-checkbox save-setting" onchange="updateFilterStatus()">
    </div>
    <div id="ensembleFilterStatus" class="filter-status filter-inactive">
      ‚ùå Requires model agreement before trading
    </div>
    <div id="ensembleSelector" class="ensemble-selector" style="display: none;">
      <div style="font-size: 11px; color: #94a3b8; margin-bottom: 5px;">Agreement Level:</div>
      <div class="ensemble-option-row">
        <input type="radio" id="ensemble2of3" name="ensembleLevel" value="2" class="save-setting" checked onchange="App.modules.UI.saveSettings()">
        <label for="ensemble2of3">2 out of 3 models (Recommended)</label>
      </div>
      <div class="ensemble-option-row">
        <input type="radio" id="ensemble3of3" name="ensembleLevel" value="3" class="save-setting" onchange="App.modules.UI.saveSettings()">
        <label for="ensemble3of3">3 out of 3 models (Strict)</label>
      </div>
    </div>
    
    <!-- Chi-Square Statistical Significance Filter -->
    <div class="filter-toggle-row" style="margin-top: 10px;">
      <span class="filter-toggle-label">Chi-Square Significance</span>
      <input type="checkbox" id="chiSquareFilterToggle" class="filter-checkbox save-setting" onchange="updateFilterStatus()">
    </div>
    <div id="chiSquareFilterStatus" class="filter-status filter-inactive">
      ‚ùå Verifies pattern is statistically significant (p-value < 0.05)
    </div>
  </div>
</div>

<div class="card">
  <h3>ü§ñ AI Prediction Model</h3>
  <div class="ai-model-selector">
    <div class="ai-model-label">Select Prediction Engine:</div>
    <div class="model-option selected" data-model="markov1">
      <input type="radio" name="aiModel" value="markov1" id="modelMarkov1" checked>
      <div style="flex: 1;">
        <label for="modelMarkov1">Standard Markov (1st Order)</label>
        <div class="model-description">Basic single-digit transition analysis</div>
      </div>
    </div>
    <div class="model-option" data-model="markov2">
      <input type="radio" name="aiModel" value="markov2" id="modelMarkov2">
      <div style="flex: 1;">
        <label for="modelMarkov2">Advanced Markov (2nd Order)</label>
        <div class="model-description">Two-digit sequence patterns - 5-10% accuracy boost</div>
      </div>
    </div>
    <div class="model-option" data-model="markov3">
      <input type="radio" name="aiModel" value="markov3" id="modelMarkov3">
      <div style="flex: 1;">
        <label for="modelMarkov3">Deep Markov (3rd Order)</label>
        <div class="model-description">Three-digit sequence patterns - 10-15% accuracy boost</div>
      </div>
    </div>
    <div class="model-option" data-model="ensemble">
      <input type="radio" name="aiModel" value="ensemble" id="modelEnsemble">
      <div style="flex: 1;">
        <label for="modelEnsemble">Ensemble + Features</label>
        <div class="model-description">Multi-model voting with time/volatility features</div>
      </div>
    </div>
    <div class="ai-training-status" id="aiTrainingStatus">Model Ready</div>
  </div>
</div>

<div class="card">
  <h3>üìä Enhanced Digit Match Analyzer</h3>
  <div class="analyzer-grid" id="digitDisplay"></div>
  <div class="analyzer-stats">
    <div><span>Predicted</span><b id="matchCount" style="color: #8b5cf6;">-</b></div>
    <div><span>Total Ticks</span><b id="totalCount" style="color: #e5e7eb;">0</b></div>
    <div><span>Frequency</span><b id="matchPercent" style="color: #8b5cf6;">0%</b></div>
  </div>
  
  <div class="prediction-box">
    <div class="prediction-status">üéØ AI Next Digit Prediction</div>
    <div class="prediction-digit" id="predictionDisplay">
      <span class="prediction-waiting">WAITING...</span>
    </div>
    <div class="confidence-bar">
      <div class="confidence-fill" id="confidenceBar" style="width: 0%"></div>
    </div>
    <div class="prediction-info" id="predictionInfo">Analyzing tick patterns...</div>
    
    <div class="accuracy-metrics">
      <div class="accuracy-card">
        <div class="label">Probability</div>
        <div class="value" id="probabilityValue">0%</div>
      </div>
      <div class="accuracy-card">
        <div class="label">Pattern Score</div>
        <div class="value" id="patternScore">0</div>
      </div>
      <div class="accuracy-card">
        <div class="label">Frequency</div>
        <div class="value" id="frequencyValue">0%</div>
      </div>
    </div>
    
    <div id="patternIndicator" class="pattern-indicator pattern-weak">
      <strong>Pattern Strength:</strong> <span id="patternStrength">Learning...</span>
    </div>
  </div>

  <div style="margin-top: 15px; border-top: 1px solid #334155; padding-top: 10px;">
    <div style="font-size: 12px; font-weight: 600; color: #94a3b8; display: flex; justify-content: space-between;">
      <span>SYSTEM & TRADE LOG</span>
      <span id="clearLog" style="cursor:pointer; color:#3b82f6">Clear</span>
    </div>
    <div class="log-container" id="logContainer">
      <div class="log-entry"><span class="log-time">[System]</span> <span class="log-msg-success">AI Engine Ready.</span></div>
    </div>
  </div>
</div>

<div class="card">
  <h3>Trade Settings</h3>
  
  <!-- Auto Resume Timer Section -->
  <div class="auto-resume-container">
    <div class="auto-resume-header">
      <div style="display:flex; flex-direction:column;">
        <span class="auto-resume-label">‚è±Ô∏è Auto Resume Timer</span>
        <span style="font-size:9px; opacity:0.6;">Auto-restart trading after stops/targets</span>
      </div>
      <div style="display:flex; align-items:center; gap: 8px;">
        <span class="auto-resume-badge" id="autoResumeBadge">TIMER ACTIVE</span>
        <div style="display:flex; align-items:center;">
          <span style="font-size:10px; margin-right:5px; opacity:0.7;">OFF/ON</span>
          <input type="checkbox" id="autoResumeToggle" class="toggle-checkbox save-setting">
        </div>
      </div>
    </div>
    
    <label style="margin-top: 5px;">Resume Wait Time (Minutes)</label>
    <input id="autoResumeWaitTime" class="save-setting" type="number" value="5" min="1" max="60" step="1">
    
    <div class="timer-display" id="timerDisplay">Resuming in: --:--</div>
    
    <div class="cumulative-profit-box">
      <span>Cumulative Session Profit/Loss</span>
      <b id="cumulativeProfit" style="color: #22c55e;">0.00</b>
    </div>
  </div>
  
  <!-- Virtual Trade Section -->
  <div class="virtual-trade-container">
    <div class="virtual-trade-header">
      <div style="display:flex; flex-direction:column;">
        <span class="virtual-trade-label">üéÆ Virtual Trade Mode</span>
        <span style="font-size:9px; opacity:0.6;">Practice until consecutive losses hit, then go LIVE</span>
      </div>
      <div style="display:flex; align-items:center; gap: 8px;">
        <span class="virtual-mode-badge" id="virtualModeBadge">VIRTUAL MODE</span>
        <div style="display:flex; align-items:center;">
          <span style="font-size:10px; margin-right:5px; opacity:0.7;">OFF/ON</span>
          <input type="checkbox" id="virtualTradeToggle" class="toggle-checkbox save-setting">
        </div>
      </div>
    </div>
    
    <label style="margin-top: 5px;">Consecutive Losses to Switch to Live</label>
    <input id="virtualLossThreshold" class="save-setting" type="number" value="3" min="1" max="20" step="1">
    
    <div class="virtual-stats">
      <div class="virtual-stat-box">
        <span>Consecutive Losses</span>
        <b id="virtualConsecLosses">0</b>
      </div>
      <div class="virtual-stat-box">
        <span>Virtual Trades</span>
        <b id="virtualTotalTrades">0</b>
      </div>
      <div class="virtual-stat-box">
        <span>Virtual P/L</span>
        <b id="virtualProfit">0.00</b>
      </div>
    </div>
    
    <div style="margin-top: 10px;">
      <div style="font-size: 11px; font-weight: 600; color: #8b5cf6; margin-bottom: 6px;">Top 4 Longest Loss Streaks:</div>
      <div class="streak-boxes">
        <div class="streak-box">
          <span>Streak A</span>
          <b id="streak1">0</b>
        </div>
        <div class="streak-box">
          <span>Streak B</span>
          <b id="streak2">0</b>
        </div>
        <div class="streak-box">
          <span>Streak C</span>
          <b id="streak3">0</b>
        </div>
        <div class="streak-box">
          <span>Streak D</span>
          <b id="streak4">0</b>
        </div>
      </div>
    </div>
  </div>
  
  <label>Stake ($)</label>
  <input id="stake" class="save-setting" type="number" value="1" min="0.35" step="0.01">
  <label>Duration (Ticks)</label>
  <input id="duration" class="save-setting" type="number" value="1" min="1" max="10">
  <label>Cooldown (seconds) - Set to 0 for instant trading</label>
  <input id="cooldown" class="save-setting" type="number" value="2" min="0">
  
  <label>Minimum Confidence Threshold (%)</label>
  <input id="minConfidence" class="save-setting" type="number" value="15" min="0" max="100" step="5">

  <label>Manual Digit Override (0 = Auto Mode)</label>
  <input id="manualDigit" class="save-setting" type="number" value="0" min="0" max="9" step="1">

  <div style="margin-top: 15px; border-top: 1px solid #334155; padding-top: 15px;" id="mapperSection">
    <div class="switch-container">
      <div style="display:flex; flex-direction:column;">
        <span class="switch-label">‚ö° Exclusive Prediction Mapper</span>
        <span style="font-size:9px; opacity:0.6;">ONLY trades if Prediction matches Condition.</span>
      </div>
      <div style="display:flex; align-items:center;">
        <span style="font-size:10px; margin-right:5px; opacity:0.7;">OFF/ON</span>
        <input type="checkbox" id="mapperToggle" class="toggle-checkbox save-setting">
      </div>
    </div>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
      <div>
        <label style="font-size: 11px; color: #94a3b8; margin-top:0;">IF AI PREDICTS:</label>
        <input id="mapperTrigger" class="save-setting" type="number" placeholder="Trigger" min="0" max="9" style="border: 1px solid #ef4444; text-align: center;">
      </div>
      <div>
        <label style="font-size: 11px; color: #94a3b8; margin-top:0;">THEN TRADE:</label>
        <input id="mapperTarget" class="save-setting" type="number" placeholder="Target" min="0" max="9" style="border: 1px solid #22c55e; text-align: center;">
      </div>
    </div>
    <div style="font-size: 10px; opacity: 0.8; color: #fca5a5; margin-top: 5px; text-align: center;">
       Logic: If ON, bot ignores ALL predictions except Trigger.
    </div>
  </div>

  <label style="margin-top: 15px;">Market</label>
  <div class="radio-group" id="marketRadios">
      <div class="radio-option selected" data-market="R_10">
          <input type="radio" name="market" value="R_10" id="marketR10" checked>
          <label for="marketR10">R_10</label>
      </div>
      <div class="radio-option" data-market="R_25">
          <input type="radio" name="market" value="R_25" id="marketR25">
          <label for="marketR25">R_25</label>
      </div>
      <div class="radio-option" data-market="R_50">
          <input type="radio" name="market" value="R_50" id="marketR50">
          <label for="marketR50">R_50</label>
      </div>
      <div class="radio-option" data-market="R_75">
          <input type="radio" name="market" value="R_75" id="marketR75">
          <label for="marketR75">R_75</label>
      </div>
      <div class="radio-option" data-market="R_100">
          <input type="radio" name="market" value="R_100" id="marketR100">
          <label for="marketR100">R_100</label>
      </div>
  </div>
</div>

<div class="card">
  <h3>Risk Management</h3>
  <label>Stop Loss ($)</label>
  <input id="stoploss" class="save-setting" type="number" value="10" min="1">
  <label>Take Profit ($)</label>
  <input id="takeprofit" class="save-setting" type="number" value="10" min="1">
  
  <label>Consecutive Loss Stop (0 = disabled, uses $ Stop Loss)</label>
  <input id="consecLossStop" class="save-setting" type="number" value="0" min="0" max="50" step="1">
  <div style="font-size: 10px; opacity: 0.7; margin-top: 3px; color: #94a3b8;">
    When set to 0, only dollar-based stop loss applies. When &gt; 0, auto-trade stops after this many consecutive losses (resets on win or profit target).
  </div>
  
  <div class="consec-loss-indicator">
    <span>Current Consecutive Losses</span>
    <b id="consecLossCounter">0</b>
  </div>
</div>

<button id="cycleBtn" class="btn-cycle">Auto Market Cycle: OFF</button>
<button id="cooldownBtn" class="btn-cooldown">Cycle Cooldown Loop: OFF</button>
<div id="cycleTimerDisplay" class="cycle-timer-display">Next Loop in: --:--</div>

<div class="card" style="margin-top: 0;">
  <label>Wait Time (Minutes)</label>
  <input id="cycleWaitTime" class="save-setting" type="number" value="5" min="1">
</div>

<div class="buttons">
  <button id="manualBtn">Manual Trade</button>
  <button id="autoBtn">Start Auto</button>
</div>

<button id="resetBtn" class="reset-button-permanent">üîÑ Reset All Stats</button>

<div class="card stats">
  <div><span>Trades</span><b id="trades">0</b></div>
  <div><span>Wins</span><b id="wins">0</b></div>
  <div><span>Losses</span><b id="losses">0</b></div>
  <div><span>P/L</span><b id="profit">0.00</b></div>
</div>

<div class="card">
<h3>Trade History</h3>
<div class="table-container">
<table>
<thead><tr><th>#</th><th>Mode</th><th>Result</th><th>P/L</th><th>Market</th></tr></thead>
<tbody id="history"></tbody>
</table>
</div>
</div>

</div>

<script>
(function() {
  'use strict';
  
  // ============ SHARED CONFIG ============
  const Config = {
    currentMarketValue: 'R_10',
    marketSequence: ["R_10", "R_25", "R_50", "R_75", "R_100"],
    accountBalance: 0,
    selectedAIModel: 'markov1',
    selectedContractType: 'DIGITMATCH',
    maxHistoryRows: 2500,
    
    // Advanced Filters
    volatilityFilterEnabled: false,
    ensembleFilterEnabled: false,
    chiSquareFilterEnabled: false,
    ensembleAgreementLevel: 2
  };

  // ============ APP MODULES ============
  const App = {
    modules: {},
    init() {
      this.modules.UI.init();
      this.modules.Connection.init();
      this.modules.AIEngine.init();
      this.modules.Analyzer.init();
      this.modules.VirtualTrade.init();
      this.modules.AutoResume.init();
      this.modules.Trader.init();
      
      this.modules.UI.loadSettings();
      
      const savedToken = sessionStorage.getItem('derivToken');
      if (savedToken) { 
        document.getElementById('token').value = savedToken; 
        setTimeout(() => this.modules.Connection.connect(), 1000); 
      }
      
      this.modules.UI.addLog("System: AI Engine Initialized.", "success");
    }
  };

  // ============ AI ENGINE MODULE ============
  App.modules.AIEngine = (function() {
    // Higher-order Markov chains storage
    let markov2Matrix = {}; // Key: "d1-d2", Value: {0:count, 1:count, ...}
    let markov3Matrix = {}; // Key: "d1-d2-d3", Value: {0:count, 1:count, ...}
    
    // Feature engineering
    let tickTimestamps = [];
    let volatilityBuffer = [];
    
    // Ensemble weights
    const ensembleWeights = {
      markov1: 0.3,
      markov2: 0.35,
      markov3: 0.35
    };
    
    function init() {
      document.querySelectorAll('.model-option').forEach(opt => {
        opt.addEventListener('click', (e) => {
          const model = e.currentTarget.dataset.model;
          selectModel(model);
        });
      });
      
      // Load saved model selection
      const savedModel = localStorage.getItem('selectedAIModel');
      if (savedModel) {
        selectModel(savedModel);
      }
    }
    
    function selectModel(model) {
      Config.selectedAIModel = model;
      document.querySelectorAll('.model-option').forEach(el => {
        el.classList.toggle('selected', el.dataset.model === model);
      });
      const radioEl = document.getElementById('model' + model.charAt(0).toUpperCase() + model.slice(1));
      if (radioEl) radioEl.checked = true;
      
      localStorage.setItem('selectedAIModel', model);
      
      const statusEl = document.getElementById('aiTrainingStatus');
      statusEl.textContent = `${getModelName(model)} Active`;
      
      App.modules.UI.addLog(`AI Model: ${getModelName(model)} selected`, "info");
    }
    
    function getModelName(model) {
      const names = {
        markov1: 'Standard Markov',
        markov2: 'Advanced Markov (2nd Order)',
        markov3: 'Deep Markov (3rd Order)',
        ensemble: 'Ensemble Multi-Model'
      };
      return names[model] || 'Unknown Model';
    }
    
    // Update higher-order Markov models
    function updateMarkov2(history) {
      if (history.length < 3) return;
      
      const prev2 = history[2];
      const prev1 = history[1];
      const current = history[0];
      
      const key = `${prev2}-${prev1}`;
      if (!markov2Matrix[key]) {
        markov2Matrix[key] = {};
      }
      markov2Matrix[key][current] = (markov2Matrix[key][current] || 0) + 1;
    }
    
    function updateMarkov3(history) {
      if (history.length < 4) return;
      
      const prev3 = history[3];
      const prev2 = history[2];
      const prev1 = history[1];
      const current = history[0];
      
      const key = `${prev3}-${prev2}-${prev1}`;
      if (!markov3Matrix[key]) {
        markov3Matrix[key] = {};
      }
      markov3Matrix[key][current] = (markov3Matrix[key][current] || 0) + 1;
    }
    
    // Predict using 2nd order Markov
    function predictMarkov2(history) {
      if (history.length < 2) return { digit: null, confidence: 0 };
      
      const prev2 = history[1];
      const prev1 = history[0];
      const key = `${prev2}-${prev1}`;
      
      const counts = markov2Matrix[key];
      if (!counts) return { digit: null, confidence: 0 };
      
      const total = Object.values(counts).reduce((a, b) => a + b, 0);
      if (total < 10) return { digit: null, confidence: 0 }; // Need min samples
      
      let maxDigit = -1;
      let maxCount = -1;
      
      for (let d = 0; d < 10; d++) {
        const count = counts[d] || 0;
        if (count > maxCount) {
          maxCount = count;
          maxDigit = d;
        }
      }
      
      const probability = (maxCount / total) * 100;
      return { digit: maxDigit, confidence: probability };
    }
    
    // Predict using 3rd order Markov with Laplace smoothing
    function predictMarkov3(history) {
      if (history.length < 3) return { digit: null, confidence: 0 };
      
      const prev3 = history[2];
      const prev2 = history[1];
      const prev1 = history[0];
      const key = `${prev3}-${prev2}-${prev1}`;
      
      const counts = markov3Matrix[key];
      if (!counts) return { digit: null, confidence: 0 };
      
      const total = Object.values(counts).reduce((a, b) => a + b, 0);
      if (total < 8) return { digit: null, confidence: 0 }; // Need min samples
      
      // Apply Laplace smoothing for sparse data
      const alpha = 0.5; // Smoothing parameter
      const smoothedCounts = {};
      let smoothedTotal = total + (alpha * 10);
      
      let maxDigit = -1;
      let maxProb = -1;
      
      for (let d = 0; d < 10; d++) {
        const rawCount = counts[d] || 0;
        const smoothedCount = rawCount + alpha;
        smoothedCounts[d] = smoothedCount;
        
        const prob = smoothedCount / smoothedTotal;
        if (prob > maxProb) {
          maxProb = prob;
          maxDigit = d;
        }
      }
      
      const probability = maxProb * 100;
      return { digit: maxDigit, confidence: probability };
    }
    
    // Calculate volatility feature
    function calculateVolatility(history, window = 10) {
      if (history.length < window) return 0;
      
      const recent = history.slice(0, window);
      const mean = recent.reduce((a, b) => a + b, 0) / window;
      const variance = recent.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / window;
      return Math.sqrt(variance);
    }
    
    // Time-based features
    function getTimeFeatures() {
      const now = new Date();
      const hour = now.getHours();
      const minute = now.getMinutes();
      
      // Cyclical encoding for time
      const hourSin = Math.sin(2 * Math.PI * hour / 24);
      const hourCos = Math.cos(2 * Math.PI * hour / 24);
      const minuteSin = Math.sin(2 * Math.PI * minute / 60);
      const minuteCos = Math.cos(2 * Math.PI * minute / 60);
      
      return { hourSin, hourCos, minuteSin, minuteCos };
    }
    
    // Ensemble prediction combining multiple models
    function predictEnsemble(history, markov1Pred) {
      const predictions = [];
      const weights = [];
      
      // Get predictions from each model
      if (markov1Pred.digit !== null) {
        predictions.push(markov1Pred);
        weights.push(ensembleWeights.markov1);
      }
      
      const markov2Pred = predictMarkov2(history);
      if (markov2Pred.digit !== null) {
        predictions.push(markov2Pred);
        weights.push(ensembleWeights.markov2);
      }
      
      const markov3Pred = predictMarkov3(history);
      if (markov3Pred.digit !== null) {
        predictions.push(markov3Pred);
        weights.push(ensembleWeights.markov3);
      }
      
      if (predictions.length === 0) {
        return { digit: null, confidence: 0 };
      }
      
      // Voting mechanism with weighted confidence
      const votes = {};
      const confidences = {};
      
      predictions.forEach((pred, idx) => {
        const digit = pred.digit;
        const weight = weights[idx];
        const weightedConf = pred.confidence * weight;
        
        votes[digit] = (votes[digit] || 0) + weight;
        confidences[digit] = (confidences[digit] || 0) + weightedConf;
      });
      
      // Find digit with highest weighted vote
      let bestDigit = -1;
      let bestVote = -1;
      
      for (let d = 0; d < 10; d++) {
        const vote = votes[d] || 0;
        if (vote > bestVote) {
          bestVote = vote;
          bestDigit = d;
        }
      }
      
      // Calculate ensemble confidence
      const totalWeight = weights.reduce((a, b) => a + b, 0);
      const avgConfidence = confidences[bestDigit] / totalWeight;
      
      // Boost confidence if multiple models agree
      const agreement = predictions.filter(p => p.digit === bestDigit).length;
      const agreementBoost = 1 + (agreement - 1) * 0.15; // 15% boost per agreeing model
      const finalConfidence = Math.min(avgConfidence * agreementBoost, 95);
      
      return { digit: bestDigit, confidence: finalConfidence };
    }
    
    // Master prediction function
    function getPrediction(history, markov1Pred) {
      const model = Config.selectedAIModel;
      
      switch(model) {
        case 'markov1':
          return markov1Pred;
        
        case 'markov2':
          const pred2 = predictMarkov2(history);
          return pred2.digit !== null ? pred2 : markov1Pred;
        
        case 'markov3':
          const pred3 = predictMarkov3(history);
          return pred3.digit !== null ? pred3 : markov1Pred;
        
        case 'ensemble':
          return predictEnsemble(history, markov1Pred);
        
        default:
          return markov1Pred;
      }
    }
    
    // Update all models with new tick
    function updateModels(history) {
      updateMarkov2(history);
      updateMarkov3(history);
      
      // Update volatility buffer
      if (history.length > 0) {
        const volatility = calculateVolatility(history, 10);
        volatilityBuffer.push(volatility);
        if (volatilityBuffer.length > 100) volatilityBuffer.shift();
      }
      
      // Update tick timestamps for frequency analysis
      tickTimestamps.push(Date.now());
      if (tickTimestamps.length > 100) tickTimestamps.shift();
    }
    
    function reset() {
      markov2Matrix = {};
      markov3Matrix = {};
      tickTimestamps = [];
      volatilityBuffer = [];
      App.modules.UI.addLog("AI models reset for new market", "warn");
    }
    
    function getData() {
      return {
        markov2Matrix,
        markov3Matrix,
        volatilityBuffer,
        tickTimestamps
      };
    }
    
    function setData(data) {
      if (data.markov2Matrix) markov2Matrix = data.markov2Matrix;
      if (data.markov3Matrix) markov3Matrix = data.markov3Matrix;
      if (data.volatilityBuffer) volatilityBuffer = data.volatilityBuffer;
      if (data.tickTimestamps) tickTimestamps = data.tickTimestamps;
    }
    
    // NEW: Get individual predictions from all 3 models for ensemble consensus filter
    function getAllModelPredictions(history, markov1Pred) {
      const predictions = [];
      
      // Markov1
      if (markov1Pred && markov1Pred.digit !== null) {
        predictions.push({ model: 'markov1', digit: markov1Pred.digit, confidence: markov1Pred.confidence });
      }
      
      // Markov2
      const pred2 = predictMarkov2(history);
      if (pred2.digit !== null) {
        predictions.push({ model: 'markov2', digit: pred2.digit, confidence: pred2.confidence });
      }
      
      // Markov3
      const pred3 = predictMarkov3(history);
      if (pred3.digit !== null) {
        predictions.push({ model: 'markov3', digit: pred3.digit, confidence: pred3.confidence });
      }
      
      return predictions;
    }
    
    return {
      init,
      updateModels,
      getPrediction,
      reset,
      getData,
      setData,
      calculateVolatility,
      getTimeFeatures,
      getAllModelPredictions
    };
  })();

  // ============ CONNECTION MODULE ============
  App.modules.Connection = (function() {
    let ws = null;
    let isConnected = false;
    let isExplicitLogout = false;
    let lastRequestTime = 0;
    
    function connect() {
      const token = document.getElementById('token').value.trim();
      if (!token) { 
        App.modules.UI.addLog("Error: API Token missing.", "error"); 
        return; 
      }
      if (ws) ws.close();
      sessionStorage.setItem('derivToken', token);
      isExplicitLogout = false;
      App.modules.UI.updateStatus('Connecting...', 'disconnected');
      
      ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=116948');
      
      ws.onopen = () => { 
        App.modules.UI.addLog("WebSocket Connected.", "info"); 
        sendAPIRequest({ authorize: token }); 
      };
      
      ws.onmessage = (msg) => handleMessage(JSON.parse(msg.data));
      
      ws.onclose = () => {
        isConnected = false;
        App.modules.UI.updateStatus('Disconnected', 'disconnected');
        document.getElementById('accountType').style.display = 'none';
        if (!isExplicitLogout) { 
          App.modules.UI.addLog("Connection lost. Reconnecting in 5s...", "warn"); 
          setTimeout(connect, 5000); 
        }
      };
      
      ws.onerror = (error) => { console.error("WebSocket error:", error); };
    }
    
    function handleMessage(data) {
      if (data.error) { 
        App.modules.UI.addLog(`API ERROR: ${data.error.message}`, "error"); 
        return; 
      }
      
      if (data.authorize) {
        isConnected = true;
        App.modules.UI.updateStatus('Connected', 'connected');
        const accTypeEl = document.getElementById('accountType');
        const isVirtual = data.authorize.is_virtual === 1 || data.authorize.loginid.includes('VRTC');
        accTypeEl.textContent = isVirtual ? 'Demo Account' : 'Live Account';
        accTypeEl.className = 'account-type ' + (isVirtual ? 'demo-badge' : 'live-badge');
        accTypeEl.style.display = 'block';
        App.modules.UI.addLog(`Authorized: ${data.authorize.email}`, "success");
        sendAPIRequest({ balance: 1, subscribe: 1 });
        subscribeToTicks();
        App.modules.UI.startSessionTimer();
        
        const persistedAuto = localStorage.getItem('isAutoRunning') === 'true';
        if(persistedAuto && !App.modules.Trader.getAutoRunning()) {
          App.modules.Trader.resumeAutoTrade();
        }
      }
      
      if (data.balance) { 
        Config.accountBalance = data.balance.balance; 
        App.modules.UI.updateBalance(); 
      }
      
      if (data.tick) {
        const lastDigit = parseInt(data.tick.quote.toString().slice(-1));
        App.modules.Analyzer.processTick(lastDigit);
      }
      
      if (data.buy) {
        App.modules.Trader.addContractId(data.buy.contract_id);
        App.modules.UI.addLog(`Trade Placed (ID: ${data.buy.contract_id})`, "success");
        sendAPIRequest({ proposal_open_contract: 1, contract_id: data.buy.contract_id, subscribe: 1 });
      }
      
      if (data.proposal_open_contract) {
        const contract = data.proposal_open_contract;
        if (contract.is_settled === 1 || ['won', 'lost', 'sold'].includes(contract.status)) {
          App.modules.Trader.handleTradeResult(contract);
          App.modules.Trader.removeContractId(contract.contract_id);
          if (data.subscription) sendAPIRequest({ forget: data.subscription.id });
        }
      }
    }
    
    function sendAPIRequest(data) { 
      if (ws && ws.readyState === WebSocket.OPEN) { 
        const now = Date.now();
        if (now - lastRequestTime < 100) { 
          setTimeout(() => sendAPIRequest(data), 100);
          return false;
        }
        lastRequestTime = now;
        ws.send(JSON.stringify(data)); 
        return true; 
      } 
      return false; 
    }
    
    function subscribeToTicks() {
      const market = Config.currentMarketValue;
      sendAPIRequest({ forget_all: "ticks" });
      App.modules.Analyzer.resetForNewMarket();
      document.getElementById('digitDisplay').innerHTML = '';
      App.modules.UI.addLog(`Watching ${market}...`, "info");
      sendAPIRequest({ ticks: market, subscribe: 1 });
    }
    
    return {
      init() {
        document.getElementById('loginBtn').addEventListener('click', connect);
        document.getElementById('logoutBtn').addEventListener('click', () => { 
          isExplicitLogout = true; 
          localStorage.removeItem('isAutoRunning');
          if (ws) ws.close(); 
          sessionStorage.removeItem('derivToken'); 
          App.modules.UI.addLog("Logging out...", "info");
          setTimeout(() => location.reload(), 500);
        });
      },
      connect,
      subscribeToTicks,
      sendAPIRequest,
      isConnected: () => isConnected
    };
  })();

  // ============ ANALYZER MODULE ============
  App.modules.Analyzer = (function() {
    let digitHistory = [];
    let transitionMatrix = Array(10).fill(0).map(() => Array(10).fill(0));
    let totalTransitions = Array(10).fill(0);
    
    let predictedDigit = null;
    let predictionConfidence = 0;
    let lastDigit = null;
    
    function processTick(digit) {
      // Store current digit for virtual trade validation
      lastDigit = digit;
      
      // 1. Update History & Math FIRST
      digitHistory.unshift(digit);
      if (digitHistory.length > 1000) digitHistory.pop();
      
      if (digitHistory.length > 1) {
        const prevDigit = digitHistory[1];
        transitionMatrix[prevDigit][digit]++;
        totalTransitions[prevDigit]++;
      }
      
      // 2. Update AI models (higher-order Markov chains)
      App.modules.AIEngine.updateModels(digitHistory);
      
      // 3. CALCULATE PREDICTION INTERNALLY (Before UI)
      const internalPred = calculateInternalPrediction(digit);
      
      // 4. Process pending virtual trade if exists
      App.modules.VirtualTrade.processTickResult(digit);
      
      // 5. TRADE CHECK (Pass the prediction to Trader)
      if (App.modules.Trader.getAutoRunning() && !App.modules.Trader.getCycleCooldown()) {
         App.modules.Trader.checkAndAutoTrade(internalPred); 
      }
      
      // 6. UPDATE UI
      updateDisplay();
      updatePredictionUI(internalPred, digit);
    }
    
    function calculateInternalPrediction(lastDigit) {
      const row = transitionMatrix[lastDigit];
      const total = totalTransitions[lastDigit];
      
      // Calculate basic Markov 1st order prediction
      let markov1Prediction = { digit: null, confidence: 0 };
      
      if (total >= 15) {
        let bestNextDigit = -1;
        let highestCount = -1;
        
        for(let i=0; i<10; i++) {
          if(row[i] > highestCount) {
            highestCount = row[i];
            bestNextDigit = i;
          }
        }
        
        const probability = (highestCount / total) * 100;
        markov1Prediction = { digit: bestNextDigit, confidence: probability };
      }
      
      // Get AI-enhanced prediction based on selected model
      const aiPrediction = App.modules.AIEngine.getPrediction(digitHistory, markov1Prediction);
      
      return aiPrediction;
    }
    
    function updatePredictionUI(pred, lastDigit) {
      predictedDigit = pred.digit;
      predictionConfidence = pred.confidence;
      
      const total = totalTransitions[lastDigit];
      
      if (pred.digit === null) {
        const minSamples = Config.selectedAIModel === 'markov1' ? 15 : 
                          Config.selectedAIModel === 'markov2' ? 10 : 8;
        document.getElementById('predictionInfo').textContent = `Gathering data for digit ${lastDigit}... (${total}/${minSamples})`;
        App.modules.UI.updatePredictionDisplay(null, 0);
        return;
      }

      const modelName = getModelDisplayName();
      const info = `${modelName}: When ${lastDigit} appears, ${pred.digit} follows ${pred.confidence.toFixed(1)}% of the time.`;
      document.getElementById('predictionInfo').textContent = info;
      
      const strengthEl = document.getElementById('patternStrength');
      const indicatorEl = document.getElementById('patternIndicator');
      
      if (pred.confidence > 20) {
        strengthEl.textContent = "Strong Trend";
        indicatorEl.className = "pattern-indicator pattern-strong";
      } else if (pred.confidence > 14) {
        strengthEl.textContent = "Moderate Trend";
        indicatorEl.className = "pattern-indicator pattern-medium";
      } else {
        strengthEl.textContent = "Random / Weak";
        indicatorEl.className = "pattern-indicator pattern-weak";
      }
      
      document.getElementById('probabilityValue').textContent = pred.confidence.toFixed(1) + '%';
      document.getElementById('patternScore').textContent = total;
      
      const freq = digitHistory.filter(d => d === pred.digit).length;
      const freqPct = digitHistory.length > 0 ? (freq / digitHistory.length * 100) : 0;
      document.getElementById('frequencyValue').textContent = freqPct.toFixed(1) + '%';
      
      App.modules.UI.updatePredictionDisplay(pred.digit, pred.confidence);
    }
    
    function getModelDisplayName() {
      const model = Config.selectedAIModel;
      const names = {
        markov1: 'Markov-1',
        markov2: 'Markov-2',
        markov3: 'Markov-3',
        ensemble: 'Ensemble'
      };
      return names[model] || 'AI';
    }
    
    function updateDisplay() {
      const container = document.getElementById('digitDisplay');
      container.innerHTML = '';
      digitHistory.slice(0, 50).forEach((digit, i) => {
        const box = document.createElement('div');
        box.className = `digit-box ${i===0 ? 'digit-match' : 'digit-other'}`;
        box.textContent = digit;
        container.appendChild(box);
      });
      
      const last = digitHistory[0];
      if(last !== undefined) {
          const total = digitHistory.length;
          const count = digitHistory.filter(d => d === last).length;
          document.getElementById('matchCount').textContent = last;
          document.getElementById('totalCount').textContent = total;
          document.getElementById('matchPercent').textContent = ((count/total)*100).toFixed(1) + "%";
      }
    }
    
    return {
      init() {},
      processTick,
      resetForNewMarket: () => {
        digitHistory = [];
        transitionMatrix = Array(10).fill(0).map(() => Array(10).fill(0));
        totalTransitions = Array(10).fill(0);
        predictedDigit = null;
        predictionConfidence = 0;
        lastDigit = null;
        App.modules.AIEngine.reset();
        App.modules.UI.addLog("Memory wiped for new market", "warn");
      },
      getPrediction: () => {
        return { digit: predictedDigit, confidence: predictionConfidence };
      },
      getLastDigit: () => lastDigit,
      getDigitHistory: () => digitHistory,
      getData: () => ({ 
        transitionMatrix, 
        totalTransitions,
        aiData: App.modules.AIEngine.getData()
      }),
      setData: (data) => {
        if(data.transitionMatrix) transitionMatrix = data.transitionMatrix;
        if(data.totalTransitions) totalTransitions = data.totalTransitions;
        if(data.aiData) App.modules.AIEngine.setData(data.aiData);
      }
     };
  })();

  // ============ VIRTUAL TRADE MODULE ============
  App.modules.VirtualTrade = (function() {
    let isVirtualMode = false;
    let virtualStats = {
      totalTrades: 0,
      consecLosses: 0,
      profit: 0
    };
    let pendingVirtualTrade = null;
    let lossStreaks = []; // Track all loss streaks
    let currentStreak = 0;
    let topStreaks = [0, 0, 0, 0]; // Top 4 longest streaks
    
    function init() {
      document.getElementById('virtualTradeToggle').addEventListener('change', (e) => {
        const isEnabled = e.target.checked;
        if (isEnabled) {
          resetVirtualStats();
          App.modules.UI.addLog("Virtual Trade Mode ENABLED", "info");
          document.getElementById('virtualModeBadge').classList.add('active');
        } else {
          App.modules.UI.addLog("Virtual Trade Mode DISABLED", "warn");
          document.getElementById('virtualModeBadge').classList.remove('active');
        }
        App.modules.UI.saveSettings();
      });
      
      // Load saved virtual stats
      const saved = localStorage.getItem('virtual_stats_dm_pro');
      if (saved) {
        virtualStats = JSON.parse(saved);
        updateVirtualUI();
      }
      
      // Load saved streaks
      const savedStreaks = localStorage.getItem('virtual_streaks_dm_pro');
      if (savedStreaks) {
        topStreaks = JSON.parse(savedStreaks);
        updateStreakDisplay();
      }
    }
    
    function isEnabled() {
      return document.getElementById('virtualTradeToggle').checked;
    }
    
    function shouldSwitchToLive() {
      const threshold = parseInt(document.getElementById('virtualLossThreshold').value);
      return virtualStats.consecLosses >= threshold;
    }
    
    function queueVirtualTrade(contractType, targetDigit, confidence) {
      if (!isVirtualMode) {
        isVirtualMode = true;
      }
      
      // Store the pending trade
      pendingVirtualTrade = {
        contractType: contractType,
        targetDigit: targetDigit,
        confidence: confidence,
        timestamp: Date.now()
      };
      
      const typeDesc = contractType === 'DIGITMATCH' ? `Digit ${targetDigit}` : 
                       contractType === 'DIGITOVER' ? 'Over 5' : 'Under 5';
      App.modules.UI.addLog(`[VIRTUAL] Trade queued: ${typeDesc} (Prob: ${confidence.toFixed(1)}%)`, "info");
    }
    
    function processTickResult(actualDigit) {
      // Check if there's a pending virtual trade to process
      if (!pendingVirtualTrade) return;
      
      const trade = pendingVirtualTrade;
      pendingVirtualTrade = null; // Clear immediately to prevent duplicate processing
      
      virtualStats.totalTrades++;
      
      // Check if the trade won based on contract type
      let isWin = false;
      if (trade.contractType === 'DIGITMATCH') {
        isWin = (actualDigit === trade.targetDigit);
      } else if (trade.contractType === 'DIGITOVER') {
        isWin = (actualDigit > 5);
      } else if (trade.contractType === 'DIGITUNDER') {
        isWin = (actualDigit < 5);
      }
      
      const stake = parseFloat(document.getElementById('stake').value);
      const payout = isWin ? stake * 0.95 : -stake; // Approximate 95% payout
      
      virtualStats.profit += payout;
      
      const typeDesc = trade.contractType === 'DIGITMATCH' ? `Digit ${trade.targetDigit}` : 
                       trade.contractType === 'DIGITOVER' ? 'Over 5' : 'Under 5';
      
      if (isWin) {
        // If we had a loss streak, save it before resetting
        if (currentStreak > 0) {
          updateTopStreaks(currentStreak);
          currentStreak = 0;
        }
        
        virtualStats.consecLosses = 0;
        App.modules.UI.addLog(`[VIRTUAL] WIN: ${typeDesc} matched ${actualDigit} ($${payout.toFixed(2)})`, "success");
      } else {
        virtualStats.consecLosses++;
        currentStreak++;
        App.modules.UI.addLog(`[VIRTUAL] LOSS: ${typeDesc}, got ${actualDigit} ($${payout.toFixed(2)}) | Consecutive: ${virtualStats.consecLosses}`, "error");
      }
      
      // Add to history
      App.modules.UI.addToHistory(virtualStats.totalTrades, isWin ? 'Win' : 'Loss', payout, Config.currentMarketValue, true);
      
      updateVirtualUI();
      saveVirtualStats();
      
      // Check if should switch to live
      if (shouldSwitchToLive()) {
        switchToLiveMode();
      }
      
      return { isWin, payout };
    }
    
    function updateTopStreaks(streak) {
      // Add new streak to array
      topStreaks.push(streak);
      
      // Sort in descending order
      topStreaks.sort((a, b) => b - a);
      
      // Remove duplicates by keeping only unique values
      topStreaks = [...new Set(topStreaks)];
      
      // Keep only top 4
      topStreaks = topStreaks.slice(0, 4);
      
      // Pad with zeros if less than 4
      while (topStreaks.length < 4) {
        topStreaks.push(0);
      }
      
      updateStreakDisplay();
      saveStreakData();
    }
    
    function updateStreakDisplay() {
      document.getElementById('streak1').textContent = topStreaks[0] || 0;
      document.getElementById('streak2').textContent = topStreaks[1] || 0;
      document.getElementById('streak3').textContent = topStreaks[2] || 0;
      document.getElementById('streak4').textContent = topStreaks[3] || 0;
    }
    
    function saveStreakData() {
      localStorage.setItem('virtual_streaks_dm_pro', JSON.stringify(topStreaks));
    }
    
    function switchToLiveMode() {
      App.modules.UI.addLog(`üî¥ SWITCHING TO LIVE MODE - ${virtualStats.consecLosses} consecutive losses reached!`, "warn");
      document.getElementById('virtualTradeToggle').checked = false;
      document.getElementById('virtualModeBadge').classList.remove('active');
      isVirtualMode = false;
      
      // Reset consecutive losses but keep total stats
      virtualStats.consecLosses = 0;
      updateVirtualUI();
      saveVirtualStats();
    }
    
    function updateVirtualUI() {
      document.getElementById('virtualConsecLosses').textContent = virtualStats.consecLosses;
      document.getElementById('virtualTotalTrades').textContent = virtualStats.totalTrades;
      const profitEl = document.getElementById('virtualProfit');
      profitEl.textContent = virtualStats.profit.toFixed(2);
      profitEl.style.color = virtualStats.profit > 0 ? '#22c55e' : (virtualStats.profit < 0 ? '#ef4444' : '#8b5cf6');
    }
    
    function saveVirtualStats() {
      localStorage.setItem('virtual_stats_dm_pro', JSON.stringify(virtualStats));
    }
    
    function resetVirtualStats() {
      virtualStats = {
        totalTrades: 0,
        consecLosses: 0,
        profit: 0
      };
      isVirtualMode = false;
      pendingVirtualTrade = null;
      currentStreak = 0;
      topStreaks = [0, 0, 0, 0];
      updateVirtualUI();
      updateStreakDisplay();
      saveVirtualStats();
      saveStreakData();
    }
    
    return {
      init,
      isEnabled,
      queueVirtualTrade,
      processTickResult,
      resetVirtualStats,
      getStats: () => virtualStats
    };
  })();

  // ============ AUTO RESUME MODULE ============
  App.modules.AutoResume = (function() {
    let isTimerActive = false;
    let timerIntervalId = null;
    let cumulativeProfit = 0;
    let remainingSeconds = 0;
    
    function init() {
      document.getElementById('autoResumeToggle').addEventListener('change', (e) => {
        const isEnabled = e.target.checked;
        if (isEnabled) {
          isTimerActive = true;
          document.getElementById('autoResumeBadge').classList.add('active');
          App.modules.UI.addLog("üîî Auto Resume Timer ENABLED - Will loop with same settings", "info");
        } else {
          isTimerActive = false;
          stopTimer();
          document.getElementById('autoResumeBadge').classList.remove('active');
          document.getElementById('timerDisplay').style.display = 'none';
          // Reset cumulative profit when disabled
          cumulativeProfit = 0;
          updateCumulativeDisplay();
          App.modules.UI.addLog("Auto Resume Timer DISABLED", "warn");
        }
        App.modules.UI.saveSettings();
      });
      
      // Load saved cumulative profit
      const saved = localStorage.getItem('cumulative_profit_dm_pro');
      if (saved && document.getElementById('autoResumeToggle').checked) {
        cumulativeProfit = parseFloat(saved);
        updateCumulativeDisplay();
      }
    }
    
    function isEnabled() {
      return document.getElementById('autoResumeToggle').checked;
    }
    
    function startTimer(reason) {
      if (!isEnabled()) {
        App.modules.UI.addLog(`‚ö†Ô∏è Auto Resume Timer is OFF - Not starting timer for ${reason}`, "warn");
        return;
      }
      
      const waitMinutes = parseInt(document.getElementById('autoResumeWaitTime').value);
      remainingSeconds = waitMinutes * 60;
      
      const display = document.getElementById('timerDisplay');
      display.style.display = 'block';
      
      // Log the exact settings that will be used after resume
      const tp = parseFloat(document.getElementById('takeprofit').value);
      const sl = parseFloat(document.getElementById('stoploss').value);
      const consecLoss = parseInt(document.getElementById('consecLossStop').value);
      
      App.modules.UI.addLog(`‚è±Ô∏è Auto Resume Timer Started (${reason})`, "warn");
      App.modules.UI.addLog(`‚öôÔ∏è Will resume with: TP=$${tp}, SL=$${sl}, ConsecLoss=${consecLoss}`, "info");
      App.modules.UI.addLog(`‚è≥ Waiting ${waitMinutes} minutes before restart...`, "info");
      
      if (timerIntervalId) clearInterval(timerIntervalId);
      
      timerIntervalId = setInterval(() => {
        remainingSeconds--;
        const m = Math.floor(remainingSeconds / 60);
        const s = remainingSeconds % 60;
        display.textContent = `Resuming in: ${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        
        if (remainingSeconds <= 0) {
          stopTimer();
          resumeTrading();
        }
      }, 1000);
    }
    
    function stopTimer() {
      if (timerIntervalId) {
        clearInterval(timerIntervalId);
        timerIntervalId = null;
      }
      remainingSeconds = 0;
      document.getElementById('timerDisplay').style.display = 'none';
    }
    
    function resumeTrading() {
      App.modules.UI.addLog("‚è±Ô∏è ‚úÖ Timer Elapsed - RESUMING TRADING NOW", "success");
      
      // Log the settings being used for this cycle
      const tp = parseFloat(document.getElementById('takeprofit').value);
      const sl = parseFloat(document.getElementById('stoploss').value);
      const consecLoss = parseInt(document.getElementById('consecLossStop').value);
      
      App.modules.UI.addLog(`üîÑ Cycle Settings: TP=$${tp}, SL=$${sl}, ConsecLoss=${consecLoss}`, "success");
      
      // Clear trade history for fresh cycle
      document.getElementById('history').innerHTML = '';
      localStorage.removeItem('trade_history_dm_pro');
      
      // Enable virtual trade mode if not already enabled
      const virtualToggle = document.getElementById('virtualTradeToggle');
      if (!virtualToggle.checked) {
        virtualToggle.checked = true;
        document.getElementById('virtualModeBadge').classList.add('active');
        App.modules.UI.addLog("üéÆ Virtual Trade Mode AUTO-ENABLED", "info");
      }
      
      // CRITICAL: Reset virtual trade consecutive losses for new cycle
      App.modules.VirtualTrade.resetVirtualStats();
      
      // Enable auto-trade with clean state
      if (!App.modules.Trader.getAutoRunning()) {
        App.modules.Trader.toggleAuto(true);
      }
      
      App.modules.UI.saveSettings();
    }
    
    function addToCumulative(profit) {
      if (isEnabled()) {
        cumulativeProfit += profit;
        updateCumulativeDisplay();
        saveCumulativeProfit();
        App.modules.UI.addLog(`üí∞ Cumulative Total: $${cumulativeProfit.toFixed(2)}`, cumulativeProfit > 0 ? "success" : "error");
      }
    }
    
    function updateCumulativeDisplay() {
      const el = document.getElementById('cumulativeProfit');
      el.textContent = cumulativeProfit.toFixed(2);
      el.style.color = cumulativeProfit > 0 ? '#22c55e' : (cumulativeProfit < 0 ? '#ef4444' : '#8b5cf6');
    }
    
    function saveCumulativeProfit() {
      localStorage.setItem('cumulative_profit_dm_pro', cumulativeProfit.toString());
    }
    
    function resetCumulative() {
      cumulativeProfit = 0;
      updateCumulativeDisplay();
      saveCumulativeProfit();
    }
    
    return {
      init,
      isEnabled,
      startTimer,
      stopTimer,
      addToCumulative,
      resetCumulative
    };
  })();

  // ============ TRADER MODULE ============
  App.modules.Trader = (function() {
    let isAutoRunning = false;
    let activeContractIds = new Set();
    let stats = { trades: 0, wins: 0, losses: 0, profit: 0 };
    let lastTradeTime = 0;
    let consecutiveLosses = 0;
    
    let isMarketCycleActive = false;
    let isCooldownLoopActive = false;
    let isCycleCooldown = false;
    let currentMarketIndex = 0;
    let cycleTimerId = null;
    
    // ============ ADVANCED FILTERS ============
    
    // Master filter check function
    function passAdvancedFilters(prediction) {
      // Volatility Filter
      if (Config.volatilityFilterEnabled) {
        if (!checkVolatilityFilter()) {
          App.modules.UI.addLog('‚ùå Volatility Filter: Market too chaotic - Trade blocked', 'warn');
          return false;
        }
      }
      
      // Ensemble Consensus Filter
      if (Config.ensembleFilterEnabled) {
        if (!checkEnsembleConsensus()) {
          App.modules.UI.addLog('‚ùå Ensemble Filter: Insufficient model agreement - Trade blocked', 'warn');
          return false;
        }
      }
      
      // Chi-Square Statistical Significance Filter
      if (Config.chiSquareFilterEnabled) {
        if (!checkChiSquareSignificance()) {
          App.modules.UI.addLog('‚ùå Chi-Square Filter: Pattern not statistically significant - Trade blocked', 'warn');
          return false;
        }
      }
      
      return true; // All filters passed
    }
    
    // Volatility Filter - blocks trades when last 10 ticks show 8+ unique digits (chaotic market)
    function checkVolatilityFilter() {
      const history = App.modules.Analyzer.getDigitHistory();
      if (history.length < 10) return true; // Not enough data, allow trade
      
      const last10 = history.slice(0, 10);
      const uniqueDigits = new Set(last10);
      
      // If 8 or more unique digits in last 10 ticks, market is too chaotic
      return uniqueDigits.size < 8;
    }
    
    // Ensemble Consensus - requires 2 or 3 out of 3 models to agree
    function checkEnsembleConsensus() {
      const history = App.modules.Analyzer.getDigitHistory();
      const markov1Pred = App.modules.Analyzer.getPrediction();
      
      // Get predictions from all 3 models
      const allPredictions = App.modules.AIEngine.getAllModelPredictions(history, markov1Pred);
      
      if (allPredictions.length < 2) return true; // Not enough models ready, allow trade
      
      // Count how many models agree on each digit
      const predictionCounts = {};
      allPredictions.forEach(pred => {
        predictionCounts[pred.digit] = (predictionCounts[pred.digit] || 0) + 1;
      });
      
      const maxAgreement = Math.max(...Object.values(predictionCounts));
      
      // Get required agreement level from UI
      const requiredLevel = parseInt(document.querySelector('input[name="ensembleLevel"]:checked')?.value || '2');
      
      return maxAgreement >= requiredLevel;
    }
    
    // Chi-Square Statistical Significance - verifies pattern is real, not just noise around 10% baseline
    function checkChiSquareSignificance() {
      const history = App.modules.Analyzer.getDigitHistory();
      if (history.length < 30) return true; // Need enough data
      
      // Count occurrences of each digit in recent history
      const observed = Array(10).fill(0);
      const recentTicks = history.slice(0, Math.min(50, history.length));
      
      recentTicks.forEach(digit => {
        observed[digit]++;
      });
      
      // Expected frequency (uniform distribution = 10% for each digit)
      const expected = recentTicks.length / 10;
      
      // Calculate Chi-Square statistic
      let chiSquare = 0;
      for (let i = 0; i < 10; i++) {
        const diff = observed[i] - expected;
        chiSquare += (diff * diff) / expected;
      }
      
      // Chi-Square critical value for 9 degrees of freedom at p=0.05 is ~16.919
      // If chi-square > 16.919, pattern is statistically significant (not random)
      const criticalValue = 16.919;
      
      return chiSquare > criticalValue;
    }
    
    // ============ END ADVANCED FILTERS ============
    
    // Accepts final target digit or contract type
    function placeTrade(contractType, targetDigit, conf, isVirtual = false) {
      if (!App.modules.Connection.isConnected() && !isVirtual) {
        App.modules.UI.addLog("Error: Not connected to Deriv", "error");
        return;
      }
      
      const stake = parseFloat(document.getElementById('stake').value);
      const duration = parseInt(document.getElementById('duration').value);
      const market = Config.currentMarketValue;
      
      // Validate inputs
      if (isNaN(stake) || stake < 0.35) {
        App.modules.UI.addLog("Error: Invalid stake amount", "error");
        return;
      }
      
      // For DIGITMATCH, validate target digit
      if (contractType === 'DIGITMATCH') {
        if (isNaN(targetDigit) || targetDigit < 0 || targetDigit > 9) {
          App.modules.UI.addLog("Error: Invalid target digit", "error");
          return;
        }
      }
      
      if (isVirtual) {
        const typeDesc = contractType === 'DIGITMATCH' ? `Digit ${targetDigit}` : 
                         contractType === 'DIGITOVER' ? 'Over 5' : 'Under 5';
        App.modules.UI.addLog(`[VIRTUAL] Buying ${typeDesc} (AI Prob: ${conf.toFixed(1)}%)`, "info");
        App.modules.VirtualTrade.queueVirtualTrade(contractType, targetDigit, conf);
        return;
      }
      
      const typeDesc = contractType === 'DIGITMATCH' ? `Digit ${targetDigit}` : 
                       contractType === 'DIGITOVER' ? 'Over 5' : 'Under 5';
      App.modules.UI.addLog(`[LIVE] Buying ${typeDesc} (AI Prob: ${conf.toFixed(1)}%)`, "info");
      
      // Build contract parameters based on type
      const params = {
        contract_type: contractType,
        symbol: market,
        duration: duration,
        duration_unit: 't',
        amount: stake,
        basis: 'stake',
        currency: 'USD'
      };
      
      // Add barrier for all digit contracts
      if (contractType === 'DIGITMATCH') {
        params.barrier = targetDigit.toString();
      } else if (contractType === 'DIGITOVER') {
        params.barrier = '5';  // Over 5 means digits 6,7,8,9
      } else if (contractType === 'DIGITUNDER') {
        params.barrier = '5';  // Under 5 means digits 0,1,2,3,4
      }
      
      App.modules.Connection.sendAPIRequest({
        buy: 1,
        price: stake,
        parameters: params
      });
    }
    
    function checkAndAutoTrade(prediction) {
      const now = Date.now();
      const cooldownSec = parseFloat(document.getElementById('cooldown').value);
      
      // NEW LOGIC: If cooldown is 0, allow trading even with pending contracts
      const allowMultipleTrades = (cooldownSec === 0);
      
      // Skip if contract is pending AND cooldown is NOT zero
      if (!allowMultipleTrades && activeContractIds.size > 0) return;
      
      // Check cooldown timer only if cooldown > 0
      if (cooldownSec > 0 && now - lastTradeTime < (cooldownSec * 1000)) return;
      
      // Check if in virtual mode
      const isVirtualEnabled = App.modules.VirtualTrade.isEnabled();
      
      // Get selected contract type
      const contractType = Config.selectedContractType;
      
      // === CONTRACT TYPE LOGIC ===
      if (contractType === 'DIGITMATCH') {
        // Skip if prediction is not ready
        if (prediction.digit === null || prediction.digit === undefined) return;
        
        // === ADVANCED FILTERS CHECK ===
        if (!passAdvancedFilters(prediction)) {
          return; // Filters blocked the trade
        }
        
        // === EXCLUSIVE PREDICTION MAPPER LOGIC (Only for DIGITMATCH) ===
        const isMapperOn = document.getElementById('mapperToggle').checked;
        const mapTrigger = document.getElementById('mapperTrigger').value;
        const mapTarget = document.getElementById('mapperTarget').value;
        
        let finalTarget = prediction.digit;
        let finalConfidence = prediction.confidence;
        
        if (isMapperOn && mapTrigger !== "" && mapTarget !== "") {
          const trigger = parseInt(mapTrigger);
          const target = parseInt(mapTarget);
          
          // Validate mapper inputs
          if (isNaN(trigger) || isNaN(target) || trigger < 0 || trigger > 9 || target < 0 || target > 9) {
            return;
          }
          
          if (prediction.digit === trigger) {
            finalTarget = target;
            App.modules.UI.addLog(`‚ö° Map Active: AI said ${trigger}, Trading ${target}`, "warn");
          } else {
            // Mapper is ON but prediction doesn't match trigger - skip this trade
            return;
          }
        } else {
          // Manual digit override (if not using mapper)
          const manualDigit = parseInt(document.getElementById('manualDigit').value);
          if (!isNaN(manualDigit) && manualDigit !== 0 && prediction.digit !== manualDigit) {
            return;
          }
        }
        
        // Validate final target
        if (isNaN(finalTarget) || finalTarget < 0 || finalTarget > 9) {
          App.modules.UI.addLog("Error: Invalid final target digit", "error");
          return;
        }
        
        // Check confidence threshold
        const userMinConf = parseFloat(document.getElementById('minConfidence').value);
        if (finalConfidence < userMinConf) return;
        
        lastTradeTime = now;
        
        // Route to virtual or live trade
        if (isVirtualEnabled) {
          placeTrade('DIGITMATCH', finalTarget, finalConfidence, true);
        } else {
          placeTrade('DIGITMATCH', finalTarget, finalConfidence, false);
        }
        
      } else if (contractType === 'DIGITOVER' || contractType === 'DIGITUNDER') {
        // For OVER/UNDER contracts, use same triggers as DIGITMATCH but ignore mapper
        
        // Skip if prediction is not ready (still use prediction as trigger)
        if (prediction.digit === null || prediction.digit === undefined) return;
        
        // Check confidence threshold (use same threshold as DIGITMATCH)
        const userMinConf = parseFloat(document.getElementById('minConfidence').value);
        if (prediction.confidence < userMinConf) return;
        
        // Manual digit override check (if set, only trade when prediction matches)
        const manualDigit = parseInt(document.getElementById('manualDigit').value);
        if (!isNaN(manualDigit) && manualDigit !== 0 && prediction.digit !== manualDigit) {
          return;
        }
        
        lastTradeTime = now;
        
        // Route to virtual or live trade (no target digit needed for OVER/UNDER)
        if (isVirtualEnabled) {
          placeTrade(contractType, null, prediction.confidence, true);
        } else {
          placeTrade(contractType, null, prediction.confidence, false);
        }
      }
    }
    
    function handleTradeResult(contract) {
      const isWin = contract.status === 'won';
      const pl = parseFloat(contract.profit || 0);
      
      stats.trades++;
      if(isWin) {
        stats.wins++;
        consecutiveLosses = 0; // Reset on win
      } else {
        stats.losses++;
        consecutiveLosses++; // Increment on loss
      }
      stats.profit += pl;
      
      // DO NOT add to cumulative here - only add when cycle completes
      
      App.modules.UI.addLog(`[LIVE] Result: ${isWin?'WIN':'LOSS'} ($${pl.toFixed(2)})`, isWin?'success':'error');
      App.modules.UI.updateStats(stats);
      App.modules.UI.updateConsecLossCounter(consecutiveLosses);
      App.modules.UI.addToHistory(stats.trades, isWin?'Win':'Loss', pl, Config.currentMarketValue, false);
      
      localStorage.setItem('trade_stats_dm_pro', JSON.stringify(stats));
      localStorage.setItem('consec_losses_dm_pro', consecutiveLosses.toString());
      localStorage.setItem('trade_history_dm_pro', document.getElementById('history').innerHTML);
      
      checkTargets();
    }
    
    function checkTargets() {
      // CRITICAL: Always read fresh values from UI inputs
      const tp = parseFloat(document.getElementById('takeprofit').value);
      const sl = parseFloat(document.getElementById('stoploss').value);
      const consecLossStop = parseInt(document.getElementById('consecLossStop').value);
      
      let shouldStop = false;
      let stopReason = '';
      
      // Check consecutive loss stop (if enabled - value > 0)
      if (consecLossStop > 0 && consecutiveLosses >= consecLossStop) {
        shouldStop = true;
        stopReason = 'Consecutive Loss Stop';
        App.modules.UI.addLog(`üõë Consecutive Loss Stop: ${consecutiveLosses}/${consecLossStop}`, "error");
      }
      
      // Check take profit - use EXACT value from input
      if (stats.profit >= tp) {
        shouldStop = true;
        stopReason = 'Take Profit';
        // Reset consecutive losses counter when profit target is hit
        consecutiveLosses = 0;
        App.modules.UI.updateConsecLossCounter(consecutiveLosses);
        localStorage.setItem('consec_losses_dm_pro', consecutiveLosses.toString());
        App.modules.UI.addLog(`‚úÖ Take Profit Hit: $${stats.profit.toFixed(2)}/$${tp.toFixed(2)}`, "success");
      }
      
      // Check dollar-based stop loss - use EXACT value from input
      if (stats.profit <= -sl) {
        shouldStop = true;
        stopReason = 'Stop Loss';
        App.modules.UI.addLog(`üõë Stop Loss Hit: $${stats.profit.toFixed(2)}/-$${sl.toFixed(2)}`, "error");
      }
      
      // If any condition is met, stop trading and optionally start auto-resume
      if (shouldStop) {
        if (isMarketCycleActive && stopReason === 'Take Profit') {
          advanceCycle();
        } else {
          // Stop auto-trading
          toggleAuto(false);
          App.modules.UI.addLog(`üî¥ ${stopReason} Triggered - Auto-Trade STOPPED`, stopReason === 'Take Profit' ? 'success' : 'error');
          
          // ENFORCED AUTO-RESUME LOGIC
          if (App.modules.AutoResume.isEnabled()) {
            App.modules.UI.addLog(`üîî Auto-Resume is ENABLED - Starting timer...`, "warn");
            
            // IMPORTANT: Add cycle profit to cumulative BEFORE resetting
            const cycleProfit = stats.profit;
            App.modules.AutoResume.addToCumulative(cycleProfit);
            App.modules.UI.addLog(`üí∞ Cycle P/L: $${cycleProfit.toFixed(2)} added to cumulative`, cycleProfit > 0 ? "success" : "error");
            
            // CRITICAL: Reset stats for next cycle AFTER adding to cumulative
            stats = { trades: 0, wins: 0, losses: 0, profit: 0 };
            consecutiveLosses = 0;
            App.modules.UI.updateStats(stats);
            App.modules.UI.updateConsecLossCounter(consecutiveLosses);
            localStorage.setItem('trade_stats_dm_pro', JSON.stringify(stats));
            localStorage.setItem('consec_losses_dm_pro', '0');
            
            // Start the timer
            App.modules.AutoResume.startTimer(stopReason);
          } else {
            App.modules.UI.addLog(`‚ÑπÔ∏è Auto-Resume is DISABLED. Enable it to automatically restart trading.`, "info");
          }
        }
      }
    }
    
    function advanceCycle() {
      if (currentMarketIndex < Config.marketSequence.length - 1) {
        currentMarketIndex++;
        const next = Config.marketSequence[currentMarketIndex];
        App.modules.UI.addLog(`Cycle Target Reached. Switching to ${next}`, "success");
        
        stats = { trades: 0, wins: 0, losses: 0, profit: 0 };
        consecutiveLosses = 0;
        App.modules.UI.updateStats(stats);
        App.modules.UI.updateConsecLossCounter(consecutiveLosses);
        
        App.modules.UI.selectMarket(next);
      } else {
        App.modules.UI.addLog("Full Market Cycle Complete.", "success");
        stats = { trades: 0, wins: 0, losses: 0, profit: 0 };
        consecutiveLosses = 0;
        App.modules.UI.updateStats(stats);
        App.modules.UI.updateConsecLossCounter(consecutiveLosses);
        
        if (isCooldownLoopActive) {
          startCycleCooldown();
        } else {
          toggleAuto(false);
          isMarketCycleActive = false;
          document.getElementById('cycleBtn').classList.remove('active');
          document.getElementById('cycleBtn').textContent = "Auto Market Cycle: OFF";
        }
      }
    }
    
    function startCycleCooldown() {
      isCycleCooldown = true;
      let min = parseInt(document.getElementById('cycleWaitTime').value);
      let sec = min * 60;
      const disp = document.getElementById('cycleTimerDisplay');
      disp.style.display = 'block';
      
      App.modules.UI.addLog(`Cycle cooldown active: waiting ${min}m...`, "warn");
      
      if (cycleTimerId) clearInterval(cycleTimerId);
      cycleTimerId = setInterval(() => {
        sec--;
        const m = Math.floor(sec/60);
        const s = sec%60;
        disp.textContent = `Next Loop in: ${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
        
        if (sec <= 0) {
          clearInterval(cycleTimerId);
          isCycleCooldown = false;
          currentMarketIndex = 0;
          disp.style.display = 'none';
          const nextMarket = Config.marketSequence[0];
          Config.currentMarketValue = nextMarket;
          App.modules.UI.selectMarket(nextMarket);
          document.getElementById('cycleBtn').textContent = `Auto Market Cycle: ON (${nextMarket})`;
          App.modules.UI.addLog(`Cooldown finished. Restarting cycle at ${nextMarket}.`, "success");
        }
      }, 1000);
    }
    
    function toggleAuto(forceState) {
      if (typeof forceState === 'boolean') isAutoRunning = forceState;
      else isAutoRunning = !isAutoRunning;
      
      const btn = document.getElementById('autoBtn');
      if (isAutoRunning) {
        // RESET consecutive losses to 0 when auto-trade is enabled
        consecutiveLosses = 0;
        App.modules.UI.updateConsecLossCounter(consecutiveLosses);
        localStorage.setItem('consec_losses_dm_pro', '0');
        
        localStorage.setItem('isAutoRunning', 'true');
        btn.textContent = "Stop Auto";
        btn.style.background = "#ef4444";
        
        const mode = App.modules.VirtualTrade.isEnabled() ? "VIRTUAL" : "LIVE";
        const model = Config.selectedAIModel.toUpperCase();
        const contractType = Config.selectedContractType === 'DIGITMATCH' ? 'DIGIT MATCH' :
                            Config.selectedContractType === 'DIGITOVER' ? 'DIGIT OVER 5' : 'DIGIT UNDER 5';
        const cooldownSec = parseFloat(document.getElementById('cooldown').value);
        const cooldownMsg = cooldownSec === 0 ? " (INSTANT TRADING MODE)" : "";
        App.modules.UI.addLog(`üöÄ Auto-Trade STARTED in ${mode} mode using ${model} for ${contractType}${cooldownMsg}`, "success");
      } else {
        // RESET consecutive losses to 0 when auto-trade is disabled
        consecutiveLosses = 0;
        App.modules.UI.updateConsecLossCounter(consecutiveLosses);
        localStorage.setItem('consec_losses_dm_pro', '0');
        
        localStorage.removeItem('isAutoRunning');
        btn.textContent = "Start Auto";
        btn.style.background = "#22c55e";
        App.modules.UI.addLog("üõë Auto-Trade STOPPED", "warn");
      }
    }
    
    function toggleMarketCycle() {
      isMarketCycleActive = !isMarketCycleActive;
      const btn = document.getElementById('cycleBtn');
      if (isMarketCycleActive) {
        btn.classList.add('active');
        currentMarketIndex = Config.marketSequence.indexOf(Config.currentMarketValue);
        if(currentMarketIndex === -1) currentMarketIndex = 0;
        btn.textContent = `Auto Market Cycle: ON (${Config.marketSequence[currentMarketIndex]})`;
        App.modules.UI.addLog(`Market Cycle Started at ${Config.marketSequence[currentMarketIndex]}.`, "info");
      } else {
        btn.classList.remove('active');
        btn.textContent = "Auto Market Cycle: OFF";
        App.modules.UI.addLog(`Market Cycle Disabled.`, "warn");
      }
    }
    
    function toggleCooldownLoop() {
      isCooldownLoopActive = !isCooldownLoopActive;
      const btn = document.getElementById('cooldownBtn');
      if (isCooldownLoopActive) {
        btn.classList.add('active');
        btn.textContent = "Cycle Cooldown Loop: ON";
        App.modules.UI.addLog(`Cooldown Loop Enabled.`, "info");
      } else {
        btn.classList.remove('active');
        btn.textContent = "Cycle Cooldown Loop: OFF";
        App.modules.UI.addLog(`Cooldown Loop Disabled.`, "warn");
      }
    }
    
    function resetStats() {
      stats = { trades: 0, wins: 0, losses: 0, profit: 0 };
      consecutiveLosses = 0;
      App.modules.UI.updateStats(stats);
      App.modules.UI.updateConsecLossCounter(consecutiveLosses);
      document.getElementById('history').innerHTML = '';
      localStorage.removeItem('trade_stats_dm_pro');
      localStorage.removeItem('consec_losses_dm_pro');
      localStorage.removeItem('trade_history_dm_pro');
      
      // Also reset virtual stats
      App.modules.VirtualTrade.resetVirtualStats();
      
      // Also reset cumulative profit
      App.modules.AutoResume.resetCumulative();
      
      App.modules.UI.addLog("All stats reset.", "info");
    }
    
    function addContractId(id) {
      activeContractIds.add(id);
    }
    
    function removeContractId(id) {
      activeContractIds.delete(id);
    }
    
    return {
      init() {
        document.getElementById('autoBtn').addEventListener('click', () => toggleAuto());
        document.getElementById('manualBtn').addEventListener('click', () => {
            const pred = App.modules.Analyzer.getPrediction();
            const contractType = Config.selectedContractType;
            const isVirtual = App.modules.VirtualTrade.isEnabled();
            
            if (contractType === 'DIGITMATCH') {
              if(pred.digit !== null && pred.digit !== undefined) {
                placeTrade('DIGITMATCH', pred.digit, pred.confidence, isVirtual);
              } else {
                App.modules.UI.addLog("No prediction available yet", "warn");
              }
            } else if (contractType === 'DIGITOVER') {
              if(pred.digit !== null && pred.digit !== undefined) {
                placeTrade('DIGITOVER', null, pred.confidence, isVirtual);
              } else {
                App.modules.UI.addLog("No prediction available yet", "warn");
              }
            } else if (contractType === 'DIGITUNDER') {
              if(pred.digit !== null && pred.digit !== undefined) {
                placeTrade('DIGITUNDER', null, pred.confidence, isVirtual);
              } else {
                App.modules.UI.addLog("No prediction available yet", "warn");
              }
            }
        });
        document.getElementById('cycleBtn').addEventListener('click', toggleMarketCycle);
        document.getElementById('cooldownBtn').addEventListener('click', toggleCooldownLoop);
        document.getElementById('resetBtn').addEventListener('click', resetStats);
        
        // Load saved stats
        const s = localStorage.getItem('trade_stats_dm_pro');
        if(s) { stats = JSON.parse(s); App.modules.UI.updateStats(stats); }
        
        const cl = localStorage.getItem('consec_losses_dm_pro');
        if(cl) { 
          consecutiveLosses = parseInt(cl); 
          App.modules.UI.updateConsecLossCounter(consecutiveLosses);
        }
      },
      checkAndAutoTrade,
      addContractId,
      removeContractId,
      handleTradeResult,
      getAutoRunning: () => isAutoRunning,
      getCycleCooldown: () => isCycleCooldown,
      resumeAutoTrade: () => toggleAuto(true),
      toggleAuto
    };
  })();

  // ============ UI MODULE ============
  App.modules.UI = (function() {
    let sessionStartTime = null;
    let timerIntervalId = null;
    
    function init() {
      // Market selection
      document.querySelectorAll('#marketRadios .radio-option').forEach(opt => {
        opt.addEventListener('click', (e) => {
          const m = e.currentTarget.dataset.market;
          selectMarket(m);
        });
      });
      
      // Contract type selection
      document.querySelectorAll('.contract-option').forEach(opt => {
        opt.addEventListener('click', (e) => {
          const contractType = e.currentTarget.dataset.contract;
          selectContractType(contractType);
        });
      });
      
      document.querySelectorAll('.save-setting').forEach(el => {
        el.addEventListener('change', saveSettings);
        el.addEventListener('input', saveSettings);
      });
      
      document.getElementById('clearLog').addEventListener('click', () => {
         document.getElementById('logContainer').innerHTML = '';
      });
    }
    
    function selectContractType(type) {
      Config.selectedContractType = type;
      document.querySelectorAll('.contract-option').forEach(el => {
        el.classList.toggle('selected', el.dataset.contract === type);
      });
      const radioEl = document.getElementById('contract' + type.charAt(0).toUpperCase() + type.slice(1).replace('OVER', 'Over').replace('UNDER', 'Under').replace('MATCH', 'Match'));
      if (radioEl) radioEl.checked = true;
      
      // Show/hide mapper section based on contract type
      const mapperSection = document.getElementById('mapperSection');
      if (type === 'DIGITMATCH') {
        mapperSection.style.display = 'block';
      } else {
        mapperSection.style.display = 'none';
      }
      
      localStorage.setItem('selectedContractType', type);
      
      const typeNames = {
        DIGITMATCH: 'Digit Match',
        DIGITOVER: 'Digit Over 5',
        DIGITUNDER: 'Digit Under 5'
      };
      addLog(`Contract Type: ${typeNames[type]} selected`, "info");
    }
    
    function addLog(msg, type = 'info') {
      const container = document.getElementById('logContainer');
      const time = new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `<span class="log-time">[${time}]</span> <span class="log-msg-${type}">${msg}</span>`;
      container.appendChild(entry);
      container.scrollTop = container.scrollHeight;
    }
    
    function updateStatus(text, className) { 
      const s = document.getElementById('status'); 
      s.textContent = text; 
      s.className = 'status ' + className; 
    }
    
    function updateBalance() { 
      document.getElementById('balanceDisplay').style.display = 'block'; 
      document.getElementById('balance').textContent = parseFloat(Config.accountBalance).toFixed(2); 
    }
    
    function updateStats(stats) {
      document.getElementById('trades').textContent = stats.trades;
      document.getElementById('wins').textContent = stats.wins;
      document.getElementById('losses').textContent = stats.losses;
      const p = document.getElementById('profit');
      p.textContent = stats.profit.toFixed(2);
      p.style.color = stats.profit > 0 ? '#22c55e' : (stats.profit < 0 ? '#ef4444' : '#e5e7eb');
    }
    
    function updateConsecLossCounter(count) {
      const counter = document.getElementById('consecLossCounter');
      counter.textContent = count;
      counter.style.color = count === 0 ? '#22c55e' : (count >= 3 ? '#ef4444' : '#f59e0b');
    }
    
    function startSessionTimer() {
      if (timerIntervalId) clearInterval(timerIntervalId);
      sessionStartTime = Date.now(); 
      timerIntervalId = setInterval(() => {
        const now = Date.now();
        const s = Math.floor((now - sessionStartTime) / 1000);
        document.getElementById('sessionTimer').textContent = `Session: ${Math.floor(s/3600).toString().padStart(2,'0')}:${Math.floor((s%3600)/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`;
      }, 1000);
    }
    
    function addToHistory(n, res, pl, m, isVirtual = false) {
      const tbody = document.getElementById('history');
      const row = tbody.insertRow(0);
      const cls = res === 'Win' ? 'win' : 'loss';
      const mode = isVirtual ? 'Virtual' : 'Live';
      row.innerHTML = `<td>${n}</td><td style="color: ${isVirtual ? '#8b5cf6' : '#22c55e'}">${mode}</td><td class="${cls}">${res}</td><td class="${cls}">${pl.toFixed(2)}</td><td>${m}</td>`;
      
      // Limit history to max rows
      while (tbody.rows.length > Config.maxHistoryRows) {
        tbody.deleteRow(tbody.rows.length - 1);
      }
    }
    
    function updatePredictionDisplay(digit, conf) {
      const box = document.getElementById('predictionDisplay');
      const bar = document.getElementById('confidenceBar');
      
      const visualPercent = Math.min(100, (conf / 25) * 100);
      bar.style.width = visualPercent + '%';
      
      if (digit !== null && digit !== undefined) {
        const color = conf > 18 ? '#22c55e' : (conf > 14 ? '#f59e0b' : '#94a3b8');
        box.innerHTML = `<span class="prediction-ready" style="color:${color}">DIGIT ${digit}</span>`;
      } else {
        box.innerHTML = `<span class="prediction-waiting">WAITING...</span>`;
      }
    }
    
    function saveSettings() {
      const set = {
        analyzer: App.modules.Analyzer.getData(),
        market: Config.currentMarketValue,
        mapperToggle: document.getElementById('mapperToggle').checked,
        virtualTradeToggle: document.getElementById('virtualTradeToggle').checked,
        autoResumeToggle: document.getElementById('autoResumeToggle').checked,
        selectedAIModel: Config.selectedAIModel,
        selectedContractType: Config.selectedContractType,
        
        // Advanced Filters
        volatilityFilterToggle: document.getElementById('volatilityFilterToggle')?.checked || false,
        ensembleFilterToggle: document.getElementById('ensembleFilterToggle')?.checked || false,
        chiSquareFilterToggle: document.getElementById('chiSquareFilterToggle')?.checked || false
      };
      document.querySelectorAll('.save-setting').forEach(el => {
        if(el.type !== 'checkbox') set[el.id] = el.value;
      });
      localStorage.setItem('settings_dm_pro', JSON.stringify(set));
    }
    
    function loadSettings() {
      const s = localStorage.getItem('settings_dm_pro');
      if(s) {
        const set = JSON.parse(s);
        for(let k in set) {
          const el = document.getElementById(k);
          if(el && el.type !== 'checkbox') el.value = set[k];
        }
        
        if(set.mapperToggle) document.getElementById('mapperToggle').checked = set.mapperToggle;
        if(set.virtualTradeToggle) {
          document.getElementById('virtualTradeToggle').checked = set.virtualTradeToggle;
          if(set.virtualTradeToggle) {
            document.getElementById('virtualModeBadge').classList.add('active');
          }
        }
        if(set.autoResumeToggle) {
          document.getElementById('autoResumeToggle').checked = set.autoResumeToggle;
          if(set.autoResumeToggle) {
            document.getElementById('autoResumeBadge').classList.add('active');
          }
        }
        
        if(set.analyzer) App.modules.Analyzer.setData(set.analyzer);
        if(set.market) {
          Config.currentMarketValue = set.market;
          selectMarket(set.market);
        }
        
        if(set.selectedAIModel) {
          // Defer AI model selection until after AIEngine is initialized
          setTimeout(() => {
            const modelRadio = document.querySelector(`input[name="aiModel"][value="${set.selectedAIModel}"]`);
            if (modelRadio) {
              modelRadio.click();
            }
          }, 100);
        }
        
        if(set.selectedContractType) {
          setTimeout(() => {
            selectContractType(set.selectedContractType);
          }, 100);
        }
        
        // Load Advanced Filter settings
        if(set.volatilityFilterToggle !== undefined) {
          document.getElementById('volatilityFilterToggle').checked = set.volatilityFilterToggle;
          Config.volatilityFilterEnabled = set.volatilityFilterToggle;
        }
        if(set.ensembleFilterToggle !== undefined) {
          document.getElementById('ensembleFilterToggle').checked = set.ensembleFilterToggle;
          Config.ensembleFilterEnabled = set.ensembleFilterToggle;
        }
        if(set.chiSquareFilterToggle !== undefined) {
          document.getElementById('chiSquareFilterToggle').checked = set.chiSquareFilterToggle;
          Config.chiSquareFilterEnabled = set.chiSquareFilterToggle;
        }
        
        // Update filter status displays after loading
        setTimeout(() => {
          if (window.updateFilterStatus) window.updateFilterStatus();
        }, 200);
      }
      
      const h = localStorage.getItem('trade_history_dm_pro');
      if(h) document.getElementById('history').innerHTML = h;
    }
    
    function selectMarket(m) {
      Config.currentMarketValue = m;
      document.querySelectorAll('.radio-option').forEach(el => {
        el.classList.toggle('selected', el.dataset.market === m);
      });
      const radioEl = document.getElementById('market'+m.replace('_',''));
      if(radioEl) radioEl.checked = true;
      
      if (App.modules.Connection.isConnected()) {
        App.modules.Connection.subscribeToTicks();
      }
      saveSettings();
    }
    
    return {
      init,
      addLog,
      updateStatus,
      updateBalance,
      updateStats,
      updateConsecLossCounter,
      startSessionTimer,
      addToHistory,
      updatePredictionDisplay,
      saveSettings,
      loadSettings,
      selectMarket
    };
  })();

  // ============ INITIALIZE APP ============
  window.addEventListener('DOMContentLoaded', () => {
    App.init();
  });
  
  // ============ GLOBAL FILTER UPDATE FUNCTION ============
  window.updateFilterStatus = function() {
    // Volatility Filter
    const volToggle = document.getElementById('volatilityFilterToggle');
    const volStatus = document.getElementById('volatilityFilterStatus');
    if (volToggle && volStatus) {
      const volEnabled = volToggle.checked;
      Config.volatilityFilterEnabled = volEnabled;
      
      if (volEnabled) {
        volStatus.className = 'filter-status filter-active';
        volStatus.textContent = '‚úÖ Active: Blocking trades during chaotic market conditions';
        App.modules.UI.addLog('Volatility Filter enabled', 'success');
      } else {
        volStatus.className = 'filter-status filter-inactive';
        volStatus.textContent = '‚ùå Blocks trades when market is chaotic (8+ unique digits in last 10 ticks)';
      }
    }
    
    // Ensemble Consensus Filter
    const ensToggle = document.getElementById('ensembleFilterToggle');
    const ensStatus = document.getElementById('ensembleFilterStatus');
    const ensSelector = document.getElementById('ensembleSelector');
    if (ensToggle && ensStatus && ensSelector) {
      const ensEnabled = ensToggle.checked;
      Config.ensembleFilterEnabled = ensEnabled;
      
      if (ensEnabled) {
        ensStatus.className = 'filter-status filter-active';
        ensStatus.textContent = '‚úÖ Active: Requiring model agreement before trading';
        ensSelector.style.display = 'block';
        
        // Update agreement level
        const agreementLevel = parseInt(document.querySelector('input[name="ensembleLevel"]:checked')?.value || '2');
        Config.ensembleAgreementLevel = agreementLevel;
        App.modules.UI.addLog(`Ensemble Consensus enabled (${agreementLevel}/3 agreement required)`, 'success');
      } else {
        ensStatus.className = 'filter-status filter-inactive';
        ensStatus.textContent = '‚ùå Requires model agreement before trading';
        ensSelector.style.display = 'none';
      }
    }
    
    // Chi-Square Statistical Significance Filter
    const chiToggle = document.getElementById('chiSquareFilterToggle');
    const chiStatus = document.getElementById('chiSquareFilterStatus');
    if (chiToggle && chiStatus) {
      const chiEnabled = chiToggle.checked;
      Config.chiSquareFilterEnabled = chiEnabled;
      
      if (chiEnabled) {
        chiStatus.className = 'filter-status filter-active';
        chiStatus.textContent = '‚úÖ Active: Verifying statistical significance of patterns';
        App.modules.UI.addLog('Chi-Square Significance Filter enabled', 'success');
      } else {
        chiStatus.className = 'filter-status filter-inactive';
        chiStatus.textContent = '‚ùå Verifies pattern is statistically significant (p-value < 0.05)';
      }
    }
    
    // Save settings after updating filters
    if (App && App.modules && App.modules.UI) {
      App.modules.UI.saveSettings();
    }
  };

})();
</script>
</body>
</html>