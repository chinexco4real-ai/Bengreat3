<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deriv SuperTrend Trading</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1d3a 100%);
            color: #e0e0e0;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 15px;
        }

        /* Login Section */
        .login-section {
            background: rgba(26, 29, 58, 0.95);
            border: 1px solid #2d3561;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .login-section.logged-in {
            background: rgba(26, 58, 29, 0.3);
            border-color: #4caf50;
        }

        .login-grid {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 15px;
            align-items: end;
        }

        .login-inputs {
            display: grid;
            grid-template-columns: 1fr auto auto;
            gap: 10px;
            align-items: end;
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        .input-group label {
            margin-bottom: 6px;
            color: #b0b0b0;
            font-size: 12px;
            font-weight: 600;
        }

        .input-group input {
            padding: 12px;
            background: #1a1d3a;
            border: 1px solid #2d3561;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .input-group input:focus {
            outline: none;
            border-color: #4fc3f7;
        }

        .input-group input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4fc3f7 0%, #2196f3 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(79, 195, 247, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-logout {
            background: #d32f2f;
            color: white;
        }

        .btn-logout:hover {
            background: #b71c1c;
        }

        .btn-logout.confirm {
            background: #ff6b6b;
            animation: pulse 0.5s;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .account-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .status-item {
            display: flex;
            flex-direction: column;
        }

        .status-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
        }

        .status-value {
            font-size: 16px;
            font-weight: 600;
            color: #4fc3f7;
            margin-top: 4px;
        }

        .timer {
            font-size: 18px;
            color: #4fc3f7;
            font-weight: 600;
        }

        .connection-status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-left: 8px;
            background: #f44336;
        }

        .connection-status.connected {
            background: #4caf50;
            animation: blink 2s infinite;
        }

        .connection-status.connecting {
            background: #ff9800;
            animation: pulse 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes pulse {
            0%, 100% { 
                opacity: 1;
                transform: scale(1);
            }
            50% { 
                opacity: 0.6;
                transform: scale(1.2);
            }
        }

        /* Main Dashboard */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        .panel {
            background: rgba(26, 29, 58, 0.95);
            border: 1px solid #2d3561;
            border-radius: 12px;
            padding: 20px;
        }

        .panel-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #4fc3f7;
            border-bottom: 2px solid #2d3561;
            padding-bottom: 10px;
        }

        /* Strategy Settings */
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .setting-item {
            margin-bottom: 15px;
        }

        .setting-item label {
            display: block;
            margin-bottom: 6px;
            font-size: 13px;
            color: #b0b0b0;
        }

        .setting-item input[type="number"],
        .setting-item select {
            width: 100%;
            padding: 10px;
            background: #1a1d3a;
            border: 1px solid #2d3561;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .setting-item input:focus,
        .setting-item select:focus {
            outline: none;
            border-color: #4fc3f7;
        }

        /* Radio Buttons */
        .radio-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .radio-item {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 8px 12px;
            background: #1a1d3a;
            border: 1px solid #2d3561;
            border-radius: 6px;
            transition: all 0.3s;
        }

        .radio-item:hover {
            border-color: #4fc3f7;
        }

        .radio-item input[type="radio"] {
            margin-right: 6px;
            cursor: pointer;
            width: 16px;
            height: 16px;
            accent-color: #4fc3f7;
        }

        .radio-item input[type="radio"]:checked + span {
            color: #4fc3f7;
            font-weight: 600;
        }

        /* Market Radio Group */
        .market-radio-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .market-radio-item {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 12px;
            background: #1a1d3a;
            border: 2px solid #2d3561;
            border-radius: 6px;
            transition: all 0.3s;
        }

        .market-radio-item:hover {
            border-color: #4fc3f7;
            background: rgba(79, 195, 247, 0.1);
        }

        .market-radio-item input[type="radio"]:checked ~ * {
            color: #4fc3f7;
        }

        .market-radio-item input[type="radio"]:checked {
            accent-color: #4fc3f7;
        }

        .market-radio-item.selected {
            border-color: #4fc3f7;
            background: rgba(79, 195, 247, 0.15);
        }

        /* Toggle Switch */
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .switch {
            position: relative;
            width: 50px;
            height: 24px;
            background: #2d3561;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .switch.active {
            background: #4fc3f7;
        }

        .switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: left 0.3s;
        }

        .switch.active::after {
            left: 28px;
        }

        /* MTF Indicator */
        .mtf-indicator {
            display: inline-block;
            padding: 4px 8px;
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4caf50;
            border-radius: 4px;
            font-size: 11px;
            color: #4caf50;
            margin-left: 8px;
        }

        .mtf-indicator.disabled {
            background: rgba(136, 136, 136, 0.2);
            border-color: #888;
            color: #888;
        }

        /* Signal Display */
        .signal-display {
            text-align: center;
            padding: 25px;
            background: linear-gradient(135deg, #1a1d3a 0%, #0a0e27 100%);
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px solid #2d3561;
        }

        .market-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #2d3561;
        }

        .market-name {
            font-size: 14px;
            color: #4fc3f7;
            font-weight: 600;
        }

        .market-price {
            font-size: 18px;
            color: #4caf50;
            font-weight: 700;
        }

        .signal-label {
            font-size: 14px;
            color: #888;
            margin-bottom: 10px;
        }

        .signal-value {
            font-size: 48px;
            font-weight: 700;
            text-transform: uppercase;
        }

        .signal-value.buy {
            color: #4caf50;
            text-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
        }

        .signal-value.sell {
            color: #f44336;
            text-shadow: 0 0 20px rgba(244, 67, 54, 0.5);
        }

        .signal-value.none {
            color: #888;
        }

        .signal-details {
            margin-top: 15px;
            font-size: 13px;
            color: #b0b0b0;
        }

        /* Progress Bar */
        .progress-container {
            margin-top: 15px;
            display: none; /* Hidden by default */
        }

        .progress-container.active {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(45, 53, 97, 0.5);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4fc3f7 0%, #2196f3 100%);
            border-radius: 4px;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.5);
            position: relative;
            overflow: hidden;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-text {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
        }

        /* Mode Badges */
        .mode-badges {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }

        .mode-badge {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .mode-badge.reverse {
            background: #ff9800;
            color: white;
        }

        .mode-badge.alternator {
            background: #9c27b0;
            color: white;
        }

        .mode-badge.rsi {
            background: #4caf50;
            color: white;
        }

        .mode-badge.mtf {
            background: #00bcd4;
            color: white;
        }

        .mode-badge.virtual {
            background: #ff5722;
            color: white;
            animation: pulse-virtual 2s infinite;
        }

        @keyframes pulse-virtual {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .mode-badge.timer {
            background: #ff9800;
            color: white;
            animation: pulse-timer 1s infinite;
        }

        @keyframes pulse-timer {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .virtual-indicator {
            display: inline-block;
            padding: 6px 12px;
            background: rgba(255, 87, 34, 0.2);
            border: 2px solid #ff5722;
            border-radius: 6px;
            font-size: 12px;
            color: #ff5722;
            font-weight: 700;
            margin-left: 10px;
            animation: pulse-virtual 2s infinite;
        }

        .live-indicator {
            display: inline-block;
            padding: 6px 12px;
            background: rgba(76, 175, 80, 0.2);
            border: 2px solid #4caf50;
            border-radius: 6px;
            font-size: 12px;
            color: #4caf50;
            font-weight: 700;
            margin-left: 10px;
        }

        /* Virtual indicator in table */
        table .virtual-indicator {
            display: inline-block;
            padding: 2px 6px;
            background: #ff5722;
            border-radius: 3px;
            font-size: 9px;
            color: white;
            font-weight: 700;
            margin-left: 4px;
        }

        /* Control Buttons */
        .control-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }

        .btn-trade {
            padding: 16px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-trade:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn-buy {
            background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);
            color: white;
        }

        .btn-buy:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        .btn-sell {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            color: white;
        }

        .btn-sell:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(244, 67, 54, 0.4);
        }

        .btn-auto {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            color: white;
        }

        .btn-auto:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 152, 0, 0.4);
        }

        .btn-auto.active {
            background: linear-gradient(135deg, #4fc3f7 0%, #2196f3 100%);
        }

        /* Statistics */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-card {
            background: #1a1d3a;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #2d3561;
        }

        .stat-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 700;
        }

        .stat-value.positive {
            color: #4caf50;
        }

        .stat-value.negative {
            color: #f44336;
        }

        /* Trade History */
        .table-container {
            overflow-x: auto;
            max-height: 420px; /* Approximately 10.5 rows visible to hint at scrolling */
            overflow-y: auto;
            border: 1px solid #2d3561;
            border-radius: 6px;
        }

        /* Custom scrollbar for trade history */
        .table-container::-webkit-scrollbar {
            width: 8px;
        }

        .table-container::-webkit-scrollbar-track {
            background: #1a1d3a;
            border-radius: 4px;
        }

        .table-container::-webkit-scrollbar-thumb {
            background: #4fc3f7;
            border-radius: 4px;
        }

        .table-container::-webkit-scrollbar-thumb:hover {
            background: #2196f3;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        table th {
            background: #1a1d3a;
            padding: 12px 8px;
            text-align: left;
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        table td {
            padding: 12px 8px;
            border-bottom: 1px solid #2d3561;
            font-size: 13px;
        }

        table tr:hover {
            background: rgba(79, 195, 247, 0.05);
        }

        .result-win {
            color: #4caf50;
            font-weight: 600;
        }

        .result-loss {
            color: #f44336;
            font-weight: 600;
        }

        .btn-clear {
            margin-top: 10px;
            padding: 10px 20px;
            background: #d32f2f;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-clear:hover {
            background: #b71c1c;
        }

        .btn-clear.confirm {
            background: #ff6b6b;
            animation: pulse 0.5s;
        }

        /* Activity Log */
        .activity-log {
            background: #0a0e27;
            padding: 15px;
            border-radius: 6px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .log-entry {
            padding: 6px 0;
            border-bottom: 1px solid #2d3561;
        }

        .log-time {
            color: #888;
            margin-right: 10px;
        }

        .log-message {
            color: #e0e0e0;
        }

        .log-error {
            color: #f44336;
        }

        .log-success {
            color: #4caf50;
        }

        .log-info {
            color: #4fc3f7;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .login-grid {
                grid-template-columns: 1fr;
            }

            .login-inputs {
                grid-template-columns: 1fr;
            }

            .account-status {
                grid-template-columns: repeat(2, 1fr);
            }

            .main-grid {
                grid-template-columns: 1fr;
            }

            .settings-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .signal-value {
                font-size: 36px;
            }

            .market-radio-group {
                grid-template-columns: 1fr;
            }

            table {
                font-size: 11px;
            }

            table th,
            table td {
                padding: 8px 4px;
            }
        }

        .page-title {
            text-align: center;
            color: #4fc3f7;
            font-size: 28px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(79, 195, 247, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="page-title">Deriv SuperTrend Trading Platform</h1>

        <!-- Login Section -->
        <div class="login-section" id="loginSection">
            <div class="login-grid">
                <div class="login-inputs">
                    <div class="input-group">
                        <label>Deriv API Token</label>
                        <input type="password" id="apiToken" placeholder="Enter your Deriv API token">
                    </div>
                    <button class="btn btn-primary" id="loginBtn" onclick="login()">Login</button>
                    <button class="btn btn-logout" id="logoutBtn" onclick="handleLogout()" style="display: none;">Logout</button>
                </div>
            </div>

            <div class="account-status" id="accountStatus" style="display: none;">
                <div class="status-item">
                    <span class="status-label">Account Type</span>
                    <span class="status-value" id="accountType">-</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Currency</span>
                    <span class="status-value" id="accountCurrency">-</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Balance</span>
                    <span class="status-value" id="accountBalance">-</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Status</span>
                    <span class="status-value">
                        <span id="connectionText">Disconnected</span>
                        <span class="connection-status" id="connectionStatus"></span>
                    </span>
                </div>
                <div class="status-item">
                    <span class="status-label">Session Time</span>
                    <span class="timer" id="sessionTimer">00:00:00</span>
                </div>
            </div>
        </div>

        <div id="tradingInterface">
            <div class="main-grid">
                <!-- Strategy Settings Panel -->
                <div class="panel">
                    <h3 class="panel-title">Strategy Settings</h3>
                    
                    <div class="setting-item">
                        <label>Market Symbol</label>
                        <div class="market-radio-group" id="marketRadioGroup">
                            <label class="market-radio-item selected">
                                <input type="radio" name="marketSymbol" value="R_10" checked onchange="changeMarket()">
                                <span>Volatility 10 Index</span>
                            </label>
                            <label class="market-radio-item">
                                <input type="radio" name="marketSymbol" value="R_25" onchange="changeMarket()">
                                <span>Volatility 25 Index</span>
                            </label>
                            <label class="market-radio-item">
                                <input type="radio" name="marketSymbol" value="R_50" onchange="changeMarket()">
                                <span>Volatility 50 Index</span>
                            </label>
                            <label class="market-radio-item">
                                <input type="radio" name="marketSymbol" value="R_75" onchange="changeMarket()">
                                <span>Volatility 75 Index</span>
                            </label>
                            <label class="market-radio-item">
                                <input type="radio" name="marketSymbol" value="R_100" onchange="changeMarket()">
                                <span>Volatility 100 Index</span>
                            </label>
                            <label class="market-radio-item">
                                <input type="radio" name="marketSymbol" value="stpRNG" onchange="changeMarket()">
                                <span>Step Index 100</span>
                            </label>
                            <label class="market-radio-item">
                                <input type="radio" name="marketSymbol" value="stpRNG2" onchange="changeMarket()">
                                <span>Step Index 200</span>
                            </label>
                            <label class="market-radio-item">
                                <input type="radio" name="marketSymbol" value="stpRNG3" onchange="changeMarket()">
                                <span>Step Index 300</span>
                            </label>
                            <label class="market-radio-item">
                                <input type="radio" name="marketSymbol" value="stpRNG4" onchange="changeMarket()">
                                <span>Step Index 400</span>
                            </label>
                            <label class="market-radio-item">
                                <input type="radio" name="marketSymbol" value="stpRNG5" onchange="changeMarket()">
                                <span>Step Index 500</span>
                            </label>
                        </div>
                    </div>

                    <div class="settings-grid">
                        <div class="setting-item">
                            <label>SuperTrend Period</label>
                            <input type="number" id="stPeriod" value="10" min="1" max="50" onchange="saveSettings()">
                        </div>
                        <div class="setting-item">
                            <label>SuperTrend Multiplier</label>
                            <input type="number" id="stMultiplier" value="3.0" step="0.1" min="0.5" max="10" onchange="saveSettings()">
                        </div>
                    </div>

                    <div class="setting-item">
                        <label>Filter 1: RSI</label>
                        <div class="toggle-switch">
                            <div class="switch" id="rsiFilterSwitch" onclick="toggleFilter('rsi')"></div>
                            <span>Enable RSI Filter</span>
                        </div>
                    </div>

                    <div class="setting-item">
                        <label>RSI Period</label>
                        <input type="number" id="rsiPeriod" value="14" min="1" max="50" onchange="saveSettings()">
                    </div>

                    <div class="setting-item">
                        <label>Filter 2: Multi-Timeframe Confirmation</label>
                        <div class="toggle-switch">
                            <div class="switch" id="mtfFilterSwitch" onclick="toggleFilter('mtf')"></div>
                            <span>Enable MTF Filter<span class="mtf-indicator" id="mtfIndicator">Auto: 5m</span></span>
                        </div>
                    </div>

                    <div class="setting-item">
                        <label>Filter 3: Virtual Trading Start</label>
                        <div class="toggle-switch">
                            <div class="switch" id="virtualFilterSwitch" onclick="toggleFilter('virtual')"></div>
                            <span>Start with Virtual Trading</span>
                        </div>
                    </div>

                    <div class="setting-item">
                        <label>Switch to Live After Losses</label>
                        <input type="number" id="virtualLossThreshold" value="3" min="1" max="20" onchange="saveSettings()">
                    </div>

                    <div class="setting-item">
                        <label>Filter 4: Auto-Restart Timer</label>
                        <div class="toggle-switch">
                            <div class="switch" id="timerFilterSwitch" onclick="toggleFilter('timer')"></div>
                            <span>Enable Auto-Restart After SL/TP</span>
                        </div>
                    </div>

                    <div class="setting-item">
                        <label>Restart Delay (Minutes)</label>
                        <input type="number" id="restartDelay" value="5" min="1" max="1440" onchange="saveSettings()">
                    </div>
                </div>

                <!-- Signal & Control Panel -->
                <div class="panel">
                    <h3 class="panel-title">Trading Signal</h3>
                    
                    <div class="signal-display">
                        <div class="market-info">
                            <span class="market-name" id="currentMarketName">Volatility 10 Index</span>
                            <span class="market-price" id="currentMarketPrice">-</span>
                        </div>
                        <div class="signal-label">Current Signal</div>
                        <div class="signal-value none" id="signalValue">NO SIGNAL</div>
                        <div class="signal-details" id="signalDetails">Please login to start</div>
                        <div class="progress-container" id="progressContainer">
                            <div class="progress-bar">
                                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                            </div>
                            <div class="progress-text" id="progressText"></div>
                        </div>
                        <div class="mode-badges" id="modeBadges"></div>
                        
                        <!-- Restart Timer Countdown -->
                        <div id="restartCountdownDisplay" style="display: none; margin-top: 15px; padding: 15px; background: rgba(255, 152, 0, 0.2); border: 2px solid #ff9800; border-radius: 8px; text-align: center;">
                            <div style="font-size: 12px; color: #ff9800; margin-bottom: 5px; font-weight: 600;">AUTO-RESTART COUNTDOWN</div>
                            <div style="font-size: 28px; font-weight: 700; color: #ff9800;" id="countdownTimer">00:00</div>
                            <div style="font-size: 11px; color: #ff9800; margin-top: 5px;">Bot will restart automatically</div>
                        </div>
                    </div>

                    <div class="settings-grid">
                        <div class="setting-item">
                            <label>Stake Amount</label>
                            <input type="number" id="stakeAmount" value="1" step="0.1" min="0.1" onchange="saveSettings()">
                        </div>
                        <div class="setting-item">
                            <label>Stop Loss</label>
                            <input type="number" id="stopLoss" value="0" step="0.1" min="0" onchange="saveSettings()">
                        </div>
                    </div>

                    <div class="settings-grid">
                        <div class="setting-item">
                            <label>Take Profit</label>
                            <input type="number" id="takeProfit" value="0" step="0.1" min="0" onchange="saveSettings()">
                        </div>
                        <div class="setting-item">
                            <label>Candle Period</label>
                            <div class="radio-group">
                                <label class="radio-item">
                                    <input type="radio" name="candlePeriod" value="30" onchange="changeCandlePeriod()">
                                    <span>30 Sec</span>
                                </label>
                                <label class="radio-item">
                                    <input type="radio" name="candlePeriod" value="60" checked onchange="changeCandlePeriod()">
                                    <span>1 Min</span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <div class="settings-grid">
                        <div class="setting-item">
                            <label>Trade Duration Type</label>
                            <div class="radio-group">
                                <label class="radio-item">
                                    <input type="radio" name="durationType" value="t" checked onchange="changeDurationType()">
                                    <span>Ticks</span>
                                </label>
                                <label class="radio-item">
                                    <input type="radio" name="durationType" value="s" onchange="changeDurationType()">
                                    <span>Seconds</span>
                                </label>
                                <label class="radio-item">
                                    <input type="radio" name="durationType" value="m" onchange="changeDurationType()">
                                    <span>Minutes</span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <div class="settings-grid">
                        <div class="setting-item">
                            <label>Duration</label>
                            <input type="number" id="tradeDuration" value="5" min="1" onchange="saveSettings()">
                        </div>
                        <div class="setting-item">
                            <label>Trading Modes</label>
                            <div class="toggle-switch">
                                <div class="switch" id="reverseModeSwitch" onclick="toggleMode('reverse')"></div>
                                <span>Reverse Mode</span>
                            </div>
                            <div class="toggle-switch" style="margin-top: 10px;">
                                <div class="switch" id="alternatorModeSwitch" onclick="toggleMode('alternator')"></div>
                                <span>Alternator Mode</span>
                            </div>
                        </div>
                    </div>

                    <div class="control-buttons">
                        <button class="btn-trade btn-buy" id="buyBtn" onclick="manualTrade('CALL')">BUY (CALL)</button>
                        <button class="btn-trade btn-sell" id="sellBtn" onclick="manualTrade('PUT')">SELL (PUT)</button>
                        <button class="btn-trade btn-auto" id="autoTradeBtn" onclick="toggleAutoTrade()">
                            <span id="autoTradeText">Start Auto Trade</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Statistics -->
            <div class="panel">
                <h3 class="panel-title">Trading Statistics (LIVE Trades Only)</h3>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Total Trades</div>
                        <div class="stat-value" id="totalTrades">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Wins</div>
                        <div class="stat-value positive" id="totalWins">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Losses</div>
                        <div class="stat-value negative" id="totalLosses">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Profit/Loss</div>
                        <div class="stat-value" id="totalPL">0.00</div>
                    </div>
                </div>
                
                <!-- Stop Loss / Take Profit Indicators -->
                <div id="slTpIndicators" style="margin-top: 15px; display: none;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div id="stopLossIndicator" style="padding: 10px; background: rgba(244, 67, 54, 0.1); border: 1px solid #f44336; border-radius: 6px;">
                            <div style="font-size: 11px; color: #f44336; margin-bottom: 5px;">STOP LOSS</div>
                            <div style="font-size: 14px; font-weight: 600; color: #f44336;" id="slStatus">Not Set</div>
                        </div>
                        <div id="takeProfitIndicator" style="padding: 10px; background: rgba(76, 175, 80, 0.1); border: 1px solid #4caf50; border-radius: 6px;">
                            <div style="font-size: 11px; color: #4caf50; margin-bottom: 5px;">TAKE PROFIT</div>
                            <div style="font-size: 14px; font-weight: 600; color: #4caf50;" id="tpStatus">Not Set</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Trade History -->
            <div class="panel">
                <h3 class="panel-title">Trade History (All Trades - Virtual [V] & Live)</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>S/N</th>
                                <th>Time</th>
                                <th>Market</th>
                                <th>Type</th>
                                <th>Stake</th>
                                <th>Result</th>
                            </tr>
                        </thead>
                        <tbody id="tradeHistoryBody">
                            <tr>
                                <td colspan="6" style="text-align: center; color: #888;">No trades yet</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <button class="btn-clear" id="clearHistoryBtn" onclick="handleClearHistory()">Clear History</button>
            </div>

            <!-- Activity Log -->
            <div class="panel">
                <h3 class="panel-title">Activity Log</h3>
                <div class="activity-log" id="activityLog">
                    <div class="log-entry">
                        <span class="log-time">[00:00:00]</span>
                        <span class="log-message log-info">System ready. Please login to start trading.</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global Variables
        let ws = null;
        let apiToken = '';
        let accountInfo = {};
        let sessionStartTime = null;
        let timerInterval = null;
        let candleData = [];
        let candleSubscription = null;
        let currentCandleSymbol = null; // Track currently subscribed symbol
        
        // Live tick-to-candle conversion variables
        let currentCandle = null; // Currently building candle
        let candleStartTime = null; // When current candle started
        let candlePeriod = 60; // Default: 60 seconds = 1 minute candles (can be 30 or 60)
        let totalCandleCount = 0; // Total candles created (not affected by array size limit)
        let candleCollectionStartTime = null; // Track when collection started for time calculation
        let candleCollectionComplete = false; // Track if initial collection is complete
        
        let isAutoTrading = false;
        let currentSignal = 'NONE';
        let tradeHistory = [];
        let logoutClickCount = 0;
        let clearClickCount = 0;
        let logoutTimeout = null;
        let clearHistoryTimeout = null;
        let isLoggedIn = false;
        let proposalId = null;
        let lastProposalRequest = null;
        let pendingProposal = null; // Track pending proposal for proper execution
        let currentPrice = 0;
        let pendingTradeType = null; // Store the trade type for pending trades

        // Trading modes
        let reverseMode = false;
        let alternatorMode = false;
        let lastTradeType = null;
        
        // Multi-Timeframe variables
        let mtfEnabled = false;
        let mtfCandleData = [];
        let mtfCandlePeriod = 300; // Default 5 minutes for 1-minute base
        let mtfSubscription = null;
        let currentMtfCandleSymbol = null;
        let mtfCurrentCandle = null;
        let mtfCandleStartTime = null;
        
        // Virtual Trading variables
        let virtualTradingEnabled = false;
        let isVirtualMode = false;
        let virtualConsecutiveLosses = 0;
        let virtualLossThreshold = 3;
        let virtualTradeHistory = [];
        
        // Timer Filter variables
        let timerFilterEnabled = false;
        let restartDelay = 5; // minutes
        let restartTimer = null;
        let restartCountdown = 0;
        let countdownInterval = null;
        
        // Contract Tracking System - Smart Duration-Based
        let activeContracts = new Map(); // Map of contract_id -> {contract details + timeout}
        let contractTimeouts = new Map(); // Map of contract_id -> timeout reference
        let pendingContractChecks = new Set(); // FIX #6: Queue for contracts needing check after reconnection

        // Market names mapping
        const marketNames = {
            'R_10': 'Volatility 10 Index',
            'R_25': 'Volatility 25 Index',
            'R_50': 'Volatility 50 Index',
            'R_75': 'Volatility 75 Index',
            'R_100': 'Volatility 100 Index',
            'stpRNG': 'Step Index 100',
            'stpRNG2': 'Step Index 200',
            'stpRNG3': 'Step Index 300',
            'stpRNG4': 'Step Index 400',
            'stpRNG5': 'Step Index 500'
        };

        // Settings
        let settings = {
            stPeriod: 10,
            stMultiplier: 3.0,
            rsiEnabled: false,
            rsiPeriod: 14,
            mtfEnabled: false,
            virtualEnabled: false,
            virtualLossThreshold: 3,
            timerEnabled: false,
            restartDelay: 5,
            marketSymbol: 'R_10',
            stakeAmount: 1,
            stopLoss: 0,
            takeProfit: 0,
            durationType: 't',
            tradeDuration: 5,
            candlePeriod: 60  // Default to 1-minute candles
        };

        // Initialize on load
        window.onload = function() {
            loadSettings();
            checkSavedToken();
            disableTrading();
            updateModeBadges();
            startContractTracking();
        };

        // Update mode badges display
        function updateModeBadges() {
            const container = document.getElementById('modeBadges');
            container.innerHTML = '';
            
            // Show RSI filter badge if enabled
            if (settings.rsiEnabled) {
                const badge = document.createElement('div');
                badge.className = 'mode-badge rsi';
                badge.textContent = 'RSI Filter (' + settings.rsiPeriod + ')';
                container.appendChild(badge);
            }
            
            // Show MTF filter badge if enabled
            if (settings.mtfEnabled) {
                const badge = document.createElement('div');
                badge.className = 'mode-badge mtf';
                const mtfLabel = getMTFLabel();
                badge.textContent = 'MTF Confirmation (' + mtfLabel + ')';
                container.appendChild(badge);
            }
            
            // Show Virtual Trading badge if in virtual mode
            if (isVirtualMode) {
                const badge = document.createElement('div');
                badge.className = 'mode-badge virtual';
                badge.textContent = 'Virtual Mode (Losses: ' + virtualConsecutiveLosses + '/' + virtualLossThreshold + ')';
                container.appendChild(badge);
            }
            
            // Show Timer badge if countdown is active
            if (timerFilterEnabled && restartCountdown > 0) {
                const badge = document.createElement('div');
                badge.className = 'mode-badge timer';
                const minutes = Math.floor(restartCountdown / 60);
                const seconds = restartCountdown % 60;
                badge.textContent = 'Auto-Restart: ' + minutes + 'm ' + seconds + 's';
                container.appendChild(badge);
            }
            
            // Show Reverse Mode badge if enabled
            if (reverseMode) {
                const badge = document.createElement('div');
                badge.className = 'mode-badge reverse';
                badge.textContent = 'Reverse Mode';
                container.appendChild(badge);
            }
            
            // Show Alternator Mode badge if enabled
            if (alternatorMode) {
                const badge = document.createElement('div');
                badge.className = 'mode-badge alternator';
                badge.textContent = 'Alternator Mode';
                container.appendChild(badge);
            }
        }

        // Toggle trading modes
        function toggleMode(mode) {
            const switchElement = document.getElementById(mode + 'ModeSwitch');
            const isActive = switchElement.classList.contains('active');
            
            if (mode === 'reverse') {
                reverseMode = !isActive;
                if (reverseMode) {
                    switchElement.classList.add('active');
                    logActivity('Reverse mode enabled: BUY becomes SELL, SELL becomes BUY', 'info');
                } else {
                    switchElement.classList.remove('active');
                    logActivity('Reverse mode disabled', 'info');
                }
            } else if (mode === 'alternator') {
                alternatorMode = !isActive;
                if (alternatorMode) {
                    switchElement.classList.add('active');
                    logActivity('Alternator mode enabled: Will alternate BUY-SELL-BUY-SELL', 'info');
                } else {
                    switchElement.classList.remove('active');
                    lastTradeType = null;
                    logActivity('Alternator mode disabled', 'info');
                }
            }
            
            updateModeBadges();
            saveSettings();
        }

        // Apply trading mode transformations
        function applyTradingModes(originalType) {
            let finalType = originalType;
            
            // Apply reverse mode
            if (reverseMode) {
                finalType = (originalType === 'CALL') ? 'PUT' : 'CALL';
                logActivity(`Reverse mode applied: ${originalType} â†’ ${finalType}`, 'info');
            }
            
            // Apply alternator mode
            if (alternatorMode) {
                if (lastTradeType === null) {
                    // First trade, use the signal
                    lastTradeType = finalType;
                } else {
                    // Alternate from last trade
                    finalType = (lastTradeType === 'CALL') ? 'PUT' : 'CALL';
                    lastTradeType = finalType;
                    logActivity(`Alternator mode applied: Trading ${finalType}`, 'info');
                }
            }
            
            return finalType;
        }

        // Disable trading interface
        function disableTrading() {
            document.getElementById('buyBtn').disabled = true;
            document.getElementById('sellBtn').disabled = true;
            document.getElementById('autoTradeBtn').disabled = true;
        }

        // Enable trading interface
        function enableTrading() {
            document.getElementById('buyBtn').disabled = false;
            document.getElementById('sellBtn').disabled = false;
            document.getElementById('autoTradeBtn').disabled = false;
        }

        // Check for saved token
        function checkSavedToken() {
            const savedToken = localStorage.getItem('derivApiToken');
            if (savedToken) {
                document.getElementById('apiToken').value = savedToken;
                login();
            }
        }

        // Login Function
        function login() {
            apiToken = document.getElementById('apiToken').value.trim();
            
            if (!apiToken) {
                alert('Please enter your Deriv API token');
                return;
            }

            // Save token
            localStorage.setItem('derivApiToken', apiToken);
            
            // Update UI
            document.getElementById('apiToken').disabled = true;
            document.getElementById('loginBtn').style.display = 'none';
            document.getElementById('logoutBtn').style.display = 'block';
            document.getElementById('accountStatus').style.display = 'grid';
            document.getElementById('loginSection').classList.add('logged-in');
            
            // Start session timer
            startSessionTimer();
            
            // Connect to Deriv WebSocket
            connectWebSocket();
            
            isLoggedIn = true;
            logActivity('User logged in successfully', 'success');
        }

        // WebSocket Connection
        function connectWebSocket() {
            const appId = '1089';
            ws = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${appId}`);

            ws.onopen = function() {
                logActivity('WebSocket connected', 'success');
                updateConnectionStatus(true);
                
                // Authorize
                ws.send(JSON.stringify({
                    authorize: apiToken
                }));
            };

            ws.onmessage = function(msg) {
                const data = JSON.parse(msg.data);
                handleWebSocketMessage(data);
            };

            ws.onerror = function(error) {
                logActivity('WebSocket error - Connection lost', 'error');
                updateConnectionStatus(false);
                
                // RESTART session timer on error (reset the session time)
                if (timerInterval) {
                    clearInterval(timerInterval);
                }
                startSessionTimer();
                logActivity('Session timer restarted due to connection error', 'info');
            };

            ws.onclose = function() {
                logActivity('WebSocket disconnected', 'error');
                updateConnectionStatus(false);
                
                // RESTART session timer on disconnect (reset the session time)
                if (timerInterval) {
                    clearInterval(timerInterval);
                }
                startSessionTimer();
                logActivity('Session timer restarted due to disconnection', 'info');
                
                // Clear subscriptions on disconnect
                candleSubscription = null;
                currentCandleSymbol = null;
                
                // Auto reconnect after 3 seconds if still logged in
                setTimeout(() => {
                    if (apiToken && isLoggedIn) {
                        logActivity('Attempting to reconnect...', 'info');
                        updateConnectionStatus('connecting');
                        connectWebSocket();
                    }
                }, 3000);
            };
        }

        // Handle WebSocket Messages
        function handleWebSocketMessage(data) {
            if (data.error) {
                logActivity('API Error: ' + data.error.message, 'error');
                
                // Reset proposal if error
                if (data.error.code === 'InputValidationFailed' || data.error.code === 'InvalidToken') {
                    proposalId = null;
                    pendingProposal = null; // Clear pending proposal on error
                    pendingTradeType = null;
                }
                
                // Clear pending proposal on any proposal-related error
                if (data.error.code && data.error.code.includes('Proposal')) {
                    pendingProposal = null;
                    pendingTradeType = null;
                }
                return;
            }

            // Authorization
            if (data.authorize) {
                accountInfo = data.authorize;
                
                // CRITICAL FIX #1: Initialize virtual mode if enabled
                if (virtualTradingEnabled) {
                    // Try to restore saved virtual state first
                    const savedVirtualState = localStorage.getItem('virtualModeState');
                    if (savedVirtualState) {
                        try {
                            const state = JSON.parse(savedVirtualState);
                            isVirtualMode = state.isVirtualMode;
                            virtualConsecutiveLosses = state.virtualConsecutiveLosses || 0;
                            logActivity('ðŸ”„ Restored virtual mode state: ' + (isVirtualMode ? 'VIRTUAL' : 'LIVE') + ' (Losses: ' + virtualConsecutiveLosses + ')', 'info');
                        } catch (e) {
                            // If parsing fails, default to virtual mode
                            isVirtualMode = true;
                            virtualConsecutiveLosses = 0;
                        }
                    } else {
                        // No saved state - start fresh in virtual mode
                        isVirtualMode = true;
                        virtualConsecutiveLosses = 0;
                    }
                    
                    logActivity('ðŸ›¡ï¸ Virtual Trading ENABLED - Starting in ' + (isVirtualMode ? 'VIRTUAL' : 'LIVE') + ' mode', 'success');
                    if (isVirtualMode) {
                        logActivity('Safe trading active - will switch to LIVE after ' + virtualLossThreshold + ' consecutive virtual losses', 'info');
                    }
                    updateModeBadges();
                } else {
                    // Virtual trading disabled - always start in live mode
                    isVirtualMode = false;
                    virtualConsecutiveLosses = 0;
                }
                
                updateAccountInfo();
                subscribeToCandles(); // This now subscribes to live ticks for both price and candle building
                enableTrading();
                
                // FIX #6: Process any pending contract checks after reconnection
                if (pendingContractChecks.size > 0) {
                    setTimeout(() => {
                        processPendingContractChecks();
                    }, 1000); // Wait 1 second after authorization to process pending checks
                }
            }

            // Balance update
            if (data.balance) {
                document.getElementById('accountBalance').textContent = 
                    data.balance.balance + ' ' + data.balance.currency;
            }

            // Tick update (for current price AND candle building)
            if (data.tick) {
                const tickPrice = data.tick.quote;
                const tickTime = data.tick.epoch;
                const tickSymbol = data.tick.symbol;
                
                // CRITICAL FIX: Only process ticks from the CURRENT subscribed symbol
                // Ignore ticks from old subscriptions that haven't been cleaned up yet
                if (tickSymbol !== currentCandleSymbol) {
                    // This is from an old subscription, ignore it silently
                    // (The forget command will eventually stop these)
                    return;
                }
                
                // Capture subscription ID on first tick from current symbol
                if (data.subscription && data.subscription.id) {
                    if (!candleSubscription) {
                        candleSubscription = data.subscription.id;
                        logActivity('Live tick subscription confirmed: ' + marketNames[currentCandleSymbol], 'success');
                    }
                    // Capture MTF subscription ID
                    if (settings.mtfEnabled && !mtfSubscription && data.subscription.id !== candleSubscription) {
                        mtfSubscription = data.subscription.id;
                        const mtfLabel = getMTFLabel();
                        logActivity('MTF subscription confirmed: ' + mtfLabel + ' timeframe', 'success');
                    }
                }
                
                // Update current price display
                currentPrice = tickPrice;
                document.getElementById('currentMarketPrice').textContent = currentPrice.toFixed(2);
                
                // Build candles from live ticks
                processLiveTick(tickPrice, tickTime);
                
                // Build MTF candles from same ticks
                if (settings.mtfEnabled) {
                    processMTFTick(tickPrice, tickTime);
                }
            }

            // Proposal response
            if (data.proposal) {
                proposalId = data.proposal.id;
                lastProposalRequest = data.echo_req;
                
                // Get market name and trade details
                const marketName = marketNames[data.echo_req.symbol] || data.echo_req.symbol;
                const tradeType = data.echo_req.contract_type === 'CALL' ? 'RISE' : 'FALL';
                const stake = data.echo_req.amount;
                const payout = data.proposal.payout ? data.proposal.payout.toFixed(2) : 'N/A';
                
                logActivity(`Proposal: ${marketName} - ${tradeType} | Stake: ${stake} | Payout: ${payout}`, 'info');
                
                // If there's a pending proposal request, execute it immediately
                if (pendingProposal) {
                    logActivity('Executing pending trade with proposal ID: ' + proposalId, 'info');
                    ws.send(JSON.stringify({
                        buy: proposalId,
                        price: pendingProposal.stake
                    }));
                    pendingProposal = null; // Clear after sending
                }
            }

            // Buy response
            if (data.buy) {
                const mode = isVirtualMode ? 'VIRTUAL' : 'LIVE';
                logActivity('Trade opened (' + mode + '): Contract ID ' + data.buy.contract_id, 'success');
                
                // Log the full buy data for debugging
                console.log('Buy response:', data.buy);
                
                // Track contract for monitoring with duration from settings
                trackContract(
                    data.buy.contract_id, 
                    data.buy.contract_type, 
                    data.buy.buy_price,
                    settings.tradeDuration,
                    settings.durationType
                );
                
                trackTrade(data.buy);
                proposalId = null;
            }

            // Proposal open contract (for tracking)
            if (data.proposal_open_contract) {
                const contract = data.proposal_open_contract;
                
                // Update trade result
                updateTradeResult(contract);
                
                // If contract is closed, remove from tracking
                if (contract.status === 'sold' || contract.status === 'cancelled') {
                    const result = contract.status === 'sold' ? 
                        (contract.profit > 0 ? 'WIN' : 'LOSS') : 'CANCELLED';
                    removeContract(contract.contract_id, result);
                }
            }
        }

        // Subscribe to Ticks for current price
        // Note: subscribeToTicks is no longer needed - subscribeToCandles handles everything

        // Update Account Info
        function updateAccountInfo() {
            document.getElementById('accountType').textContent = 
                accountInfo.is_virtual ? 'DEMO' : 'REAL';
            document.getElementById('accountCurrency').textContent = 
                accountInfo.currency;
            document.getElementById('accountBalance').textContent = 
                accountInfo.balance + ' ' + accountInfo.currency;
            
            // Subscribe to balance updates
            ws.send(JSON.stringify({
                balance: 1,
                subscribe: 1
            }));
            
            logActivity('Account loaded: ' + accountInfo.loginid, 'success');
        }

        // Subscribe to Candle Data
        function subscribeToCandles() {
            const symbol = settings.marketSymbol;
            
            // Don't resubscribe if already subscribed to this symbol
            if (currentCandleSymbol === symbol && candleSubscription) {
                logActivity('Already subscribed to ' + marketNames[symbol] + ' live ticks', 'info');
                return;
            }
            
            // Unsubscribe from previous stream if exists
            if (candleSubscription && currentCandleSymbol) {
                ws.send(JSON.stringify({
                    forget: candleSubscription
                }));
                logActivity('Unsubscribing from ' + marketNames[currentCandleSymbol] + '...', 'info');
                
                // CRITICAL: Clear subscription ID and symbol IMMEDIATELY
                // This prevents processing ticks from old symbol before forget completes
                const oldSubscription = candleSubscription;
                candleSubscription = null;
                currentCandleSymbol = null;
                
                // Clear candle data when changing symbols
                candleData = [];
                currentCandle = null;
                candleStartTime = null;
                totalCandleCount = 0; // Reset counter
                candleCollectionStartTime = null;
                candleCollectionComplete = false;
            }
            
            // Show LOADING status immediately
            const signalElement = document.getElementById('signalValue');
            const detailsElement = document.getElementById('signalDetails');
            const progressContainer = document.getElementById('progressContainer');
            
            signalElement.textContent = 'LOADING...';
            signalElement.className = 'signal-value none';
            detailsElement.textContent = 'Building candles from live ticks...';
            progressContainer.classList.add('active');
            
            // Set the current symbol BEFORE subscribing
            // This ensures tick handler knows which symbol to accept
            currentCandleSymbol = symbol;
            
            // Subscribe to live ticks ONLY (no historical data)
            ws.send(JSON.stringify({
                ticks: symbol,
                subscribe: 1
            }));

            logActivity('Subscribing to ' + marketNames[symbol] + ' live ticks for real-time candle building...', 'info');
            
            // Subscribe to MTF candles if enabled
            if (settings.mtfEnabled) {
                subscribeMTFCandles(symbol);
            }
        }

        // Subscribe to MTF Candles
        function subscribeMTFCandles(symbol) {
            if (!settings.mtfEnabled) return;
            
            // Unsubscribe from previous MTF stream if exists
            if (mtfSubscription) {
                ws.send(JSON.stringify({ forget: mtfSubscription }));
                mtfSubscription = null;
                mtfCandleData = [];
                mtfCurrentCandle = null;
                mtfCandleStartTime = null;
            }
            
            currentMtfCandleSymbol = symbol;
            
            // Subscribe to higher timeframe ticks
            ws.send(JSON.stringify({
                ticks: symbol,
                subscribe: 1
            }));
            
            const mtfLabel = getMTFLabel();
            logActivity('MTF: Subscribing to ' + mtfLabel + ' confirmation timeframe...', 'info');
        }

        // Process Live Tick and Build Candles
        function processLiveTick(price, timestamp) {
            // Calculate which candle period this tick belongs to
            const candlePeriodStart = Math.floor(timestamp / candlePeriod) * candlePeriod;
            
            // Check if we need to start a new candle
            if (!currentCandle || candlePeriodStart !== candleStartTime) {
                // If we have a completed candle, add it to history
                if (currentCandle) {
                    candleData.push(currentCandle);
                    totalCandleCount++; // Increment total count
                    
                    // Keep only last 100 candles in array
                    if (candleData.length > 100) {
                        candleData.shift();
                    }
                    
                    // Log every 20 candles continuously (20, 40, 60, 80, 100, 120, etc.)
                    const candleType = candlePeriod === 30 ? '30-sec' : '1-min';
                    if (totalCandleCount % 20 === 0) {
                        logActivity('Candle #' + totalCandleCount + ' completed (' + candleType + ')', 'info');
                    }
                }
                
                // Start new candle (silently - no log spam)
                currentCandle = {
                    time: candlePeriodStart,
                    open: price,
                    high: price,
                    low: price,
                    close: price
                };
                candleStartTime = candlePeriodStart;
            } else {
                // Update current candle with new tick
                currentCandle.high = Math.max(currentCandle.high, price);
                currentCandle.low = Math.min(currentCandle.low, price);
                currentCandle.close = price;
            }
            
            // Run strategy calculation with current data
            calculateStrategy();
        }

        // Process MTF Tick and Build Higher Timeframe Candles
        function processMTFTick(price, timestamp) {
            // Calculate which MTF candle period this tick belongs to
            const mtfPeriodStart = Math.floor(timestamp / mtfCandlePeriod) * mtfCandlePeriod;
            
            // Check if we need to start a new MTF candle
            if (!mtfCurrentCandle || mtfPeriodStart !== mtfCandleStartTime) {
                // If we have a completed candle, add it to history
                if (mtfCurrentCandle) {
                    mtfCandleData.push(mtfCurrentCandle);
                    
                    // Keep only last 100 candles in array
                    if (mtfCandleData.length > 100) {
                        mtfCandleData.shift();
                    }
                }
                
                // Start new MTF candle
                mtfCurrentCandle = {
                    time: mtfPeriodStart,
                    open: price,
                    high: price,
                    low: price,
                    close: price
                };
                mtfCandleStartTime = mtfPeriodStart;
            } else {
                // Update current MTF candle with new tick
                mtfCurrentCandle.high = Math.max(mtfCurrentCandle.high, price);
                mtfCurrentCandle.low = Math.min(mtfCurrentCandle.low, price);
                mtfCurrentCandle.close = price;
            }
        }

        // Calculate SuperTrend Strategy
        function calculateStrategy() {
            // Base requirement: period + 1 for ATR, +1 for first ST, +1 for signal flip = period + 3
            let requiredLength = settings.stPeriod + 3;
            
            if (settings.rsiEnabled) {
                requiredLength = Math.max(requiredLength, settings.rsiPeriod + 2);
            }
            
            if (candleData.length < requiredLength) {
                const progress = Math.floor((candleData.length / requiredLength) * 100);
                const remaining = requiredLength - candleData.length;
                
                // Calculate estimated time remaining based on candle period
                const remainingSeconds = remaining * candlePeriod;
                const remainingMinutes = Math.floor(remainingSeconds / 60);
                const remainingSecs = remainingSeconds % 60;
                let timeEstimate = '';
                if (remainingMinutes > 0) {
                    timeEstimate = ` (~${remainingMinutes}m ${remainingSecs}s remaining)`;
                } else {
                    timeEstimate = ` (~${remainingSecs}s remaining)`;
                }
                
                const signalElement = document.getElementById('signalValue');
                const detailsElement = document.getElementById('signalDetails');
                const progressContainer = document.getElementById('progressContainer');
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                
                signalElement.textContent = 'LOADING...';
                signalElement.className = 'signal-value none';
                
                // Show which filters are enabled
                let filterInfo = '';
                if (settings.rsiEnabled || settings.mtfEnabled) {
                    const enabledFilters = [];
                    if (settings.rsiEnabled) enabledFilters.push('RSI');
                    if (settings.mtfEnabled) enabledFilters.push('MTF ' + getMTFLabel());
                    filterInfo = ' | Filters: ' + enabledFilters.join(', ');
                } else {
                    filterInfo = ' | No filters';
                }
                
                const candleType = candlePeriod === 30 ? '30-sec' : '1-min';
                detailsElement.innerHTML = `Collecting ${candleType} candles...${filterInfo}`;
                progressContainer.classList.add('active');
                
                // Start timer on first candle
                if (!candleCollectionStartTime && candleData.length === 1) {
                    candleCollectionStartTime = Date.now();
                }
                
                progressFill.style.width = progress + '%';
                progressText.textContent = `${candleData.length} / ${requiredLength} ${candleType} candles${timeEstimate}`;
                
                // Log progress with detailed info
                if (candleData.length % 5 === 0 || candleData.length === 1) {
                    const periodInfo = candlePeriod === 30 ? ' (30-sec candles = 2x faster)' : ' (1-min candles)';
                    logActivity('Collecting: ' + candleData.length + '/' + requiredLength + ' candles' + timeEstimate + periodInfo + filterInfo, 'info');
                }
                return;
            }
            
            const progressContainer = document.getElementById('progressContainer');
            if (progressContainer) {
                // Log completion message only on first completion
                if (progressContainer.classList.contains('active') && !candleCollectionComplete) {
                    const collectionTime = candleCollectionStartTime ? 
                        Math.floor((Date.now() - candleCollectionStartTime) / 1000) : 0;
                    const minutes = Math.floor(collectionTime / 60);
                    const seconds = collectionTime % 60;
                    const timeText = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                    const candleType = candlePeriod === 30 ? '30-sec' : '1-min';
                    
                    logActivity(`âœ“ Candle collection complete! ${requiredLength} ${candleType} candles collected in ${timeText}`, 'success');
                    candleCollectionComplete = true;
                }
                progressContainer.classList.remove('active');
            }

            const atr = calculateATR(candleData, settings.stPeriod);
            const superTrend = calculateSuperTrend(candleData, settings.stPeriod, settings.stMultiplier, atr);
            
            // Now SuperTrend will have sufficient length by candle 13-14
            if (!superTrend || superTrend.length < 2) {
                logActivity('SuperTrend has ' + (superTrend ? superTrend.length : 0) + ' values, need 2 minimum', 'info');
                return;
            }
            
            const currentTrend = superTrend[superTrend.length - 1];
            const previousTrend = superTrend[superTrend.length - 2];
            
            let signal = 'NONE';
            let signalDetails = '';
            
            if (previousTrend.trend === 'DOWN' && currentTrend.trend === 'UP') {
                signal = 'BUY';
                signalDetails = 'SuperTrend Bullish Flip';
            } else if (previousTrend.trend === 'UP' && currentTrend.trend === 'DOWN') {
                signal = 'SELL';
                signalDetails = 'SuperTrend Bearish Flip';
            }

            // Filters
            if (signal !== 'NONE') {
                if (settings.rsiEnabled && signal !== 'NONE') {
                    const rsi = calculateRSI(candleData, settings.rsiPeriod);
                    if (!rsi || rsi.length === 0) {
                        signal = 'NONE';
                        signalDetails = 'Filtered: RSI calculation failed';
                    } else {
                        const currentRSI = rsi[rsi.length - 1];
                        if (signal === 'BUY') {
                            if (currentRSI > 70) {
                                signal = 'NONE';
                                signalDetails = 'Filtered: RSI Overbought (' + currentRSI.toFixed(2) + ')';
                            } else if (currentRSI <= 50) {
                                signal = 'NONE';
                                signalDetails = 'Filtered: RSI Not Bullish (' + currentRSI.toFixed(2) + ')';
                            } else {
                                signalDetails += ' | RSI: ' + currentRSI.toFixed(2);
                            }
                        } else if (signal === 'SELL') {
                            if (currentRSI < 30) {
                                signal = 'NONE';
                                signalDetails = 'Filtered: RSI Oversold (' + currentRSI.toFixed(2) + ')';
                            } else if (currentRSI >= 50) {
                                signal = 'NONE';
                                signalDetails = 'Filtered: RSI Not Bearish (' + currentRSI.toFixed(2) + ')';
                            } else {
                                signalDetails += ' | RSI: ' + currentRSI.toFixed(2);
                            }
                        }
                    }
                }
                
                // MTF Confirmation Filter
                if (settings.mtfEnabled && signal !== 'NONE') {
                    // Require minimum MTF candles for reliable SuperTrend
                    const mtfRequiredLength = settings.stPeriod + 3;
                    
                    if (mtfCandleData.length < mtfRequiredLength) {
                        signal = 'NONE';
                        const mtfLabel = getMTFLabel();
                        signalDetails = 'Filtered: Collecting ' + mtfLabel + ' candles (' + mtfCandleData.length + '/' + mtfRequiredLength + ')';
                    } else {
                        // Calculate SuperTrend on MTF data
                        const mtfAtr = calculateATR(mtfCandleData, settings.stPeriod);
                        const mtfSuperTrend = calculateSuperTrend(mtfCandleData, settings.stPeriod, settings.stMultiplier, mtfAtr);
                        
                        if (!mtfSuperTrend || mtfSuperTrend.length < 1) {
                            signal = 'NONE';
                            signalDetails = 'Filtered: MTF SuperTrend calculation pending';
                        } else {
                            const mtfCurrentTrend = mtfSuperTrend[mtfSuperTrend.length - 1];
                            const mtfTrendDirection = mtfCurrentTrend.trend;
                            
                            // Check if MTF trend matches the signal
                            if (signal === 'BUY' && mtfTrendDirection !== 'UP') {
                                signal = 'NONE';
                                const mtfLabel = getMTFLabel();
                                signalDetails = 'Filtered: MTF ' + mtfLabel + ' not confirming (Trend: ' + mtfTrendDirection + ')';
                            } else if (signal === 'SELL' && mtfTrendDirection !== 'DOWN') {
                                signal = 'NONE';
                                const mtfLabel = getMTFLabel();
                                signalDetails = 'Filtered: MTF ' + mtfLabel + ' not confirming (Trend: ' + mtfTrendDirection + ')';
                            } else {
                                const mtfLabel = getMTFLabel();
                                signalDetails += ' | MTF ' + mtfLabel + ': ' + mtfTrendDirection + ' âœ“';
                            }
                        }
                    }
                }
            } else {
                signalDetails = 'Trend: ' + currentTrend.trend;
            }

            updateSignalDisplay(signal, signalDetails);

            if (isAutoTrading && signal !== 'NONE' && signal !== currentSignal) {
                // Build filter status message
                let filterStatus = '';
                if (settings.rsiEnabled || settings.mtfEnabled) {
                    filterStatus = ' [Filters: ';
                    const activeFilters = [];
                    if (settings.rsiEnabled) activeFilters.push('RSI âœ“');
                    if (settings.mtfEnabled) activeFilters.push('MTF âœ“');
                    filterStatus += activeFilters.join(', ') + ']';
                }
                
                logActivity('New signal detected: ' + signal + filterStatus + ' (Previous: ' + currentSignal + ')', 'info');
                const tradeType = signal === 'BUY' ? 'CALL' : 'PUT';
                executeTrade(tradeType);
            }

            currentSignal = signal;
        }

        // Calculate ATR
        function calculateATR(candles, period) {
            const tr = [];
            
            for (let i = 1; i < candles.length; i++) {
                const high = candles[i].high;
                const low = candles[i].low;
                const prevClose = candles[i - 1].close;
                
                const trValue = Math.max(
                    high - low,
                    Math.abs(high - prevClose),
                    Math.abs(low - prevClose)
                );
                
                tr.push(trValue);
            }
            
            const atr = [];
            let sum = 0;
            
            for (let i = 0; i < tr.length; i++) {
                if (i < period - 1) {
                    sum += tr[i];
                } else if (i === period - 1) {
                    sum += tr[i];
                    atr.push(sum / period);
                } else {
                    const prevATR = atr[atr.length - 1];
                    atr.push((prevATR * (period - 1) + tr[i]) / period);
                }
            }
            
            return atr;
        }

        // Calculate SuperTrend
        function calculateSuperTrend(candles, period, multiplier, atr) {
            const superTrend = [];
            
            for (let i = 0; i < candles.length; i++) {
                // We need at least 'period' candles to have an ATR value
                const atrIndex = i - period + 1;
                const atrValue = atr[atrIndex];
                
                if (atrValue === undefined) continue;

                const candle = candles[i];
                const midPrice = (candle.high + candle.low) / 2;
                const basicUpper = midPrice + (multiplier * atrValue);
                const basicLower = midPrice - (multiplier * atrValue);
                
                let finalUpper, finalLower, trend;
                
                if (superTrend.length === 0) {
                    finalUpper = basicUpper;
                    finalLower = basicLower;
                    trend = candle.close > finalUpper ? 'UP' : 'DOWN';
                } else {
                    const prev = superTrend[superTrend.length - 1];
                    
                    // Logic for Upper Band
                    finalUpper = (basicUpper < prev.finalUpper || candles[i-1].close > prev.finalUpper) 
                                 ? basicUpper : prev.finalUpper;
                    
                    // Logic for Lower Band
                    finalLower = (basicLower > prev.finalLower || candles[i-1].close < prev.finalLower) 
                                 ? basicLower : prev.finalLower;
                    
                    // Trend Switching Logic - flip happens when price crosses the band
                    if (prev.trend === 'UP') {
                        trend = candle.close < finalLower ? 'DOWN' : 'UP';
                    } else {
                        trend = candle.close > finalUpper ? 'UP' : 'DOWN';
                    }
                }
                
                superTrend.push({ 
                    finalUpper, 
                    finalLower, 
                    trend,
                    activeLine: trend === 'UP' ? finalLower : finalUpper
                });
            }
            return superTrend;
        }

        // Calculate ADX
        // Calculate RSI
        function calculateRSI(candles, period) {
            const changes = [];
            
            for (let i = 1; i < candles.length; i++) {
                changes.push(candles[i].close - candles[i - 1].close);
            }
            
            const rsi = [];
            let avgGain = 0;
            let avgLoss = 0;
            
            for (let i = 0; i < period; i++) {
                if (changes[i] > 0) avgGain += changes[i];
                else avgLoss += Math.abs(changes[i]);
            }
            
            avgGain /= period;
            avgLoss /= period;
            
            rsi.push(100 - (100 / (1 + (avgGain / avgLoss))));
            
            for (let i = period; i < changes.length; i++) {
                const gain = changes[i] > 0 ? changes[i] : 0;
                const loss = changes[i] < 0 ? Math.abs(changes[i]) : 0;
                
                avgGain = ((avgGain * (period - 1)) + gain) / period;
                avgLoss = ((avgLoss * (period - 1)) + loss) / period;
                
                rsi.push(100 - (100 / (1 + (avgGain / avgLoss))));
            }
            
            return rsi;
        }

        // Update Signal Display
        function updateSignalDisplay(signal, details) {
            const signalElement = document.getElementById('signalValue');
            const detailsElement = document.getElementById('signalDetails');
            
            signalElement.textContent = signal;
            signalElement.className = 'signal-value ' + signal.toLowerCase();
            detailsElement.textContent = details;
        }

        // Execute Trade
        // Execute Trade
        function executeTrade(type) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                logActivity('Cannot trade: Not connected', 'error');
                return;
            }
            
            // Apply trading modes
            const finalType = applyTradingModes(type);
            
            // CRITICAL FIX #7: Handle VIRTUAL trades differently - simulate locally without API call
            if (isVirtualMode) {
                logActivity('âš¡ Executing VIRTUAL trade (Losses: ' + virtualConsecutiveLosses + '/' + virtualLossThreshold + ') - SIMULATED, NO REAL MONEY', 'info');
                simulateVirtualTrade(finalType);
                return; // Don't send to API for virtual trades
            }
            
            // LIVE MODE - Send actual trade to Deriv API
            logActivity('âš¡ Executing LIVE trade - REAL MONEY', 'info');
            
            // Store the final trade type for later use
            pendingTradeType = finalType;

            // Create proposal request
            const proposalRequest = {
                proposal: 1,
                amount: settings.stakeAmount,
                basis: 'stake',
                contract_type: finalType,
                currency: accountInfo.currency,
                symbol: settings.marketSymbol,
                duration: settings.tradeDuration,
                duration_unit: settings.durationType
            };

            // Store pending proposal info
            pendingProposal = {
                stake: settings.stakeAmount,
                type: finalType
            };

            // Send proposal request to Deriv API
            ws.send(JSON.stringify(proposalRequest));
            
            logActivity('Requesting proposal [LIVE] for ' + finalType + ' on ' + marketNames[settings.marketSymbol], 'info');
            
            // Trade will be executed automatically when proposal response is received
            // See handleWebSocketMessage() -> if (data.proposal) section
        }
        
        // Simulate Virtual Trade (no API call, local simulation only)
        function simulateVirtualTrade(finalType) {
            // Generate a fake contract ID for tracking
            const virtualContractId = 'VIRTUAL_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            // Create virtual trade entry
            const virtualTrade = {
                sn: tradeHistory.length + 1,
                time: new Date().toLocaleTimeString(),
                market: settings.marketSymbol,
                type: (finalType === 'CALL' ? 'BUY (CALL)' : 'SELL (PUT)'),
                stake: settings.stakeAmount,
                contractId: virtualContractId,
                result: 'PENDING',
                isVirtual: true,
                virtualStartPrice: currentPrice,
                virtualStartTime: Date.now(),
                virtualType: finalType,
                virtualDuration: settings.tradeDuration,
                virtualDurationUnit: settings.durationType
            };
            
            tradeHistory.unshift(virtualTrade);
            
            // Cap trade history at 500 trades maximum
            if (tradeHistory.length > 500) {
                tradeHistory = tradeHistory.slice(0, 500);
            }
            
            updateTradeHistory();
            
            logActivity('Virtual trade simulated: ' + virtualTrade.type + ' at price ' + currentPrice.toFixed(2) + ' (Contract: ' + virtualContractId + ')', 'info');
            
            // Schedule virtual trade result calculation
            scheduleVirtualTradeResult(virtualTrade);
        }
        
        // Schedule Virtual Trade Result Calculation
        function scheduleVirtualTradeResult(virtualTrade) {
            let durationMs = 0;
            
            // Calculate duration in milliseconds
            if (virtualTrade.virtualDurationUnit === 't') {
                durationMs = virtualTrade.virtualDuration * 2000; // Assume 2 seconds per tick
            } else if (virtualTrade.virtualDurationUnit === 's') {
                durationMs = virtualTrade.virtualDuration * 1000;
            } else if (virtualTrade.virtualDurationUnit === 'm') {
                durationMs = virtualTrade.virtualDuration * 60 * 1000;
            } else if (virtualTrade.virtualDurationUnit === 'h') {
                durationMs = virtualTrade.virtualDuration * 60 * 60 * 1000;
            } else if (virtualTrade.virtualDurationUnit === 'd') {
                durationMs = virtualTrade.virtualDuration * 24 * 60 * 60 * 1000;
            }
            
            // Add 2 second buffer
            durationMs += 2000;
            
            const timeoutId = setTimeout(() => {
                calculateVirtualTradeResult(virtualTrade);
            }, durationMs);
            
            // Store timeout for cleanup
            contractTimeouts.set(virtualTrade.contractId, timeoutId);
            
            logActivity('Virtual trade will be resolved in ' + Math.floor(durationMs / 1000) + 's', 'info');
        }
        
        // Calculate Virtual Trade Result
        function calculateVirtualTradeResult(virtualTrade) {
            const trade = tradeHistory.find(t => t.contractId === virtualTrade.contractId);
            if (!trade) return;
            
            // Get current price at time of calculation
            const exitPrice = currentPrice;
            const entryPrice = virtualTrade.virtualStartPrice;
            
            // Determine if trade won or lost
            let isWin = false;
            if (virtualTrade.virtualType === 'CALL') {
                isWin = exitPrice > entryPrice;
            } else {
                isWin = exitPrice < entryPrice;
            }
            
            // Calculate profit/loss (simplified - use 95% payout for wins, -100% for losses)
            const payout = isWin ? (settings.stakeAmount * 0.95) : (-settings.stakeAmount);
            
            trade.profit = payout;
            trade.result = payout > 0 ? 'WIN (+' + payout.toFixed(2) + ')' : 'LOSS (' + payout.toFixed(2) + ')';
            
            // Create simulated contract object to reuse existing logic
            const simulatedContract = {
                contract_id: virtualTrade.contractId,
                profit: payout,
                is_sold: true,
                status: 'sold'
            };
            
            logActivity('Virtual trade resolved: Entry=' + entryPrice.toFixed(2) + ', Exit=' + exitPrice.toFixed(2) + ', Result=' + trade.result, isWin ? 'success' : 'error');
            
            // Update trade result using existing function (will handle virtual loss tracking)
            updateTradeResult(simulatedContract);
            
            // Clean up timeout
            contractTimeouts.delete(virtualTrade.contractId);
        }

        // Manual Trade
        function manualTrade(type) {
            logActivity('Manual trade initiated: ' + type, 'info');
            executeTrade(type);
        }

        // Toggle Auto Trade
        function toggleAutoTrade() {
            isAutoTrading = !isAutoTrading;
            const btn = document.getElementById('autoTradeBtn');
            const text = document.getElementById('autoTradeText');
            
            if (isAutoTrading) {
                btn.classList.add('active');
                text.textContent = 'Stop Auto Trade';
                logActivity('Auto trading enabled', 'success');
            } else {
                btn.classList.remove('active');
                text.textContent = 'Start Auto Trade';
                logActivity('Auto trading disabled', 'info');
            }
        }

        // Track Trade
        function trackTrade(buyData) {
            // Determine the contract type to display
            let displayType = 'UNKNOWN';
            
            // First, try to use the stored pending trade type
            if (pendingTradeType) {
                if (pendingTradeType === 'CALL') {
                    displayType = 'BUY (CALL)';
                } else if (pendingTradeType === 'PUT') {
                    displayType = 'SELL (PUT)';
                }
                pendingTradeType = null; // Clear after use
            } 
            // Fallback to contract_type from buy response
            else if (buyData.contract_type) {
                if (buyData.contract_type === 'CALL') {
                    displayType = 'BUY (CALL)';
                } else if (buyData.contract_type === 'PUT') {
                    displayType = 'SELL (PUT)';
                } else {
                    displayType = buyData.contract_type;
                }
            }
            // Last fallback: try to extract from longcode
            else if (buyData.longcode) {
                if (buyData.longcode.toLowerCase().includes('rises') || buyData.longcode.toLowerCase().includes('call')) {
                    displayType = 'BUY (CALL)';
                } else if (buyData.longcode.toLowerCase().includes('falls') || buyData.longcode.toLowerCase().includes('put')) {
                    displayType = 'SELL (PUT)';
                }
            }
            
            const trade = {
                sn: tradeHistory.length + 1,
                time: new Date().toLocaleTimeString(),
                market: settings.marketSymbol,
                type: displayType,
                stake: settings.stakeAmount,
                contractId: buyData.contract_id,
                result: 'PENDING',
                isVirtual: isVirtualMode  // Mark if this was a virtual trade
            };
            
            tradeHistory.unshift(trade);
            
            // Cap trade history at 500 trades maximum
            if (tradeHistory.length > 500) {
                tradeHistory = tradeHistory.slice(0, 500);
            }
            
            updateTradeHistory();
            
            // Subscribe to contract updates
            ws.send(JSON.stringify({
                proposal_open_contract: 1,
                contract_id: buyData.contract_id,
                subscribe: 1
            }));
        }

        // Update Trade Result
        function updateTradeResult(contract) {
            if (!contract || !contract.contract_id) return;
            
            const trade = tradeHistory.find(t => t.contractId === contract.contract_id);
            if (!trade) return;
            
            if (contract.is_sold) {
                const profit = contract.profit;
                trade.result = profit > 0 ? 'WIN (+' + profit.toFixed(2) + ')' : 'LOSS (' + profit.toFixed(2) + ')';
                trade.profit = profit;
                
                // CRITICAL FIX #3 & #4: Track virtual trading losses with proper state management
                if (virtualTradingEnabled && trade.isVirtual) {
                    const timestamp = new Date().toISOString();
                    
                    if (profit > 0) {
                        // WIN - Only reset counter if STILL in virtual mode
                        if (isVirtualMode) {
                            const oldCount = virtualConsecutiveLosses;
                            virtualConsecutiveLosses = 0;
                            logActivity('[' + timestamp + '] âœ“ Virtual WIN! Loss counter RESET ' + oldCount + ' â†’ 0 (Contract: ' + trade.contractId + ')', 'success');
                            if (oldCount > 0) {
                                logActivity('Starting fresh - need ' + virtualLossThreshold + ' NEW consecutive losses to switch to LIVE', 'info');
                            }
                            updateModeBadges();
                            
                            // Save updated state
                            if (virtualTradingEnabled) {
                                localStorage.setItem('virtualModeState', JSON.stringify({
                                    isVirtualMode: isVirtualMode,
                                    virtualConsecutiveLosses: virtualConsecutiveLosses
                                }));
                            }
                        } else {
                            // Already in LIVE mode - ignore late virtual WIN
                            logActivity('[' + timestamp + '] Late virtual WIN closed (already in LIVE mode) - no counter change (Contract: ' + trade.contractId + ')', 'info');
                        }
                        return; // Don't process further for virtual wins
                    }
                    
                    // LOSS - Only track if STILL in virtual mode
                    if (isVirtualMode) {
                        if (profit < 0) {
                            // LOSS - increment counter
                            virtualConsecutiveLosses++;
                            logActivity('[' + timestamp + '] Virtual LOSS #' + virtualConsecutiveLosses + ' of ' + virtualLossThreshold + ' required (Contract: ' + trade.contractId + ')', 'error');
                            
                            // Check if threshold reached
                            if (virtualConsecutiveLosses >= virtualLossThreshold) {
                                isVirtualMode = false;
                                logActivity('[' + timestamp + '] ðŸ”¥ EXACTLY ' + virtualLossThreshold + ' consecutive virtual losses! SWITCHING TO LIVE MODE NOW', 'success');
                                logActivity('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
                                logActivity('âš¡ LIVE TRADING ACTIVATED - All future trades will be REAL', 'success');
                                logActivity('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
                                updateModeBadges();
                                
                                // Save updated state
                                if (virtualTradingEnabled) {
                                    localStorage.setItem('virtualModeState', JSON.stringify({
                                        isVirtualMode: isVirtualMode,
                                        virtualConsecutiveLosses: virtualConsecutiveLosses
                                    }));
                                }
                            } else {
                                logActivity('Need ' + (virtualLossThreshold - virtualConsecutiveLosses) + ' more consecutive loss(es) to switch to LIVE', 'info');
                                updateModeBadges();
                                
                                // Save updated state
                                if (virtualTradingEnabled) {
                                    localStorage.setItem('virtualModeState', JSON.stringify({
                                        isVirtualMode: isVirtualMode,
                                        virtualConsecutiveLosses: virtualConsecutiveLosses
                                    }));
                                }
                            }
                        } else {
                            // profit === 0 (tie/draw) - treat as loss
                            virtualConsecutiveLosses++;
                            logActivity('[' + timestamp + '] Virtual TIE (0.00) counted as LOSS #' + virtualConsecutiveLosses + ' of ' + virtualLossThreshold, 'error');
                            updateModeBadges();
                            
                            // Save updated state
                            if (virtualTradingEnabled) {
                                localStorage.setItem('virtualModeState', JSON.stringify({
                                    isVirtualMode: isVirtualMode,
                                    virtualConsecutiveLosses: virtualConsecutiveLosses
                                }));
                            }
                        }
                    } else {
                        // Already in LIVE mode - ignore late virtual losses
                        logActivity('[' + timestamp + '] Late virtual LOSS closed (already in LIVE mode) - ignored (Contract: ' + trade.contractId + ')', 'info');
                    }
                }
                
                updateTradeHistory();
                updateStatistics();
                
                // Check Stop Loss and Take Profit
                checkStopLossTakeProfit(profit);
                
                const mode = trade.isVirtual ? '[VIRTUAL]' : '[LIVE]';
                logActivity('Trade closed ' + mode + ': ' + trade.result, profit > 0 ? 'success' : 'error');
            }
        }

        // Update Trade History
        function updateTradeHistory() {
            const tbody = document.getElementById('tradeHistoryBody');
            
            if (tradeHistory.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #888;">No trades yet</td></tr>';
                return;
            }
            
            // Display ALL trades (up to 500) - CSS scrolling will show ~10 visible
            tbody.innerHTML = tradeHistory.map(trade => {
                const virtualIndicator = trade.isVirtual ? '<span class="virtual-indicator">V</span>' : '';
                return `
                <tr>
                    <td>${trade.sn}</td>
                    <td>${trade.time}</td>
                    <td>${trade.market}</td>
                    <td>${trade.type} ${virtualIndicator}</td>
                    <td>${trade.stake}</td>
                    <td class="${trade.result.includes('WIN') ? 'result-win' : trade.result.includes('LOSS') ? 'result-loss' : ''}">${trade.result}</td>
                </tr>`;
            }).join('');
        }

        // Statistics cache for performance optimization
        let statsCache = {
            liveTrades: 0,
            liveWins: 0,
            liveLosses: 0,
            livePL: 0,
            virtualTrades: 0,
            virtualWins: 0,
            virtualLosses: 0,
            virtualPL: 0,
            lastUpdate: 0
        };

        // Update Statistics (IMPROVED: Show both Virtual and Live statistics separately)
        function updateStatistics() {
            const now = Date.now();
            
            // Use cache if updated within last 100ms (performance optimization)
            if (now - statsCache.lastUpdate < 100) {
                updateStatisticsDisplay();
                return statsCache.livePL;
            }
            
            // Calculate LIVE trades
            const liveTrades = tradeHistory.filter(t => t.profit !== undefined && !t.isVirtual);
            const liveWins = liveTrades.filter(t => t.profit > 0);
            const liveLosses = liveTrades.filter(t => t.profit < 0);
            const livePL = liveTrades.reduce((sum, t) => sum + (t.profit || 0), 0);
            
            // Calculate VIRTUAL trades
            const virtualTrades = tradeHistory.filter(t => t.profit !== undefined && t.isVirtual);
            const virtualWins = virtualTrades.filter(t => t.profit > 0);
            const virtualLosses = virtualTrades.filter(t => t.profit < 0);
            const virtualPL = virtualTrades.reduce((sum, t) => sum + (t.profit || 0), 0);
            
            // Update cache
            statsCache = {
                liveTrades: liveTrades.length,
                liveWins: liveWins.length,
                liveLosses: liveLosses.length,
                livePL: livePL,
                virtualTrades: virtualTrades.length,
                virtualWins: virtualWins.length,
                virtualLosses: virtualLosses.length,
                virtualPL: virtualPL,
                lastUpdate: now
            };
            
            updateStatisticsDisplay();
            
            // Return total LIVE P/L for stop loss/take profit checking
            return livePL;
        }
        
        // Update Statistics Display (uses cached values)
        function updateStatisticsDisplay() {
            // Show combined format: "LIVE / VIRTUAL"
            document.getElementById('totalTrades').innerHTML = 
                `<span style="color: #4fc3f7">${statsCache.liveTrades}</span>` +
                (statsCache.virtualTrades > 0 ? ` / <span style="color: #ff9800">${statsCache.virtualTrades}V</span>` : '');
            
            document.getElementById('totalWins').innerHTML = 
                `<span style="color: #4fc3f7">${statsCache.liveWins}</span>` +
                (statsCache.virtualWins > 0 ? ` / <span style="color: #ff9800">${statsCache.virtualWins}V</span>` : '');
            
            document.getElementById('totalLosses').innerHTML = 
                `<span style="color: #4fc3f7">${statsCache.liveLosses}</span>` +
                (statsCache.virtualLosses > 0 ? ` / <span style="color: #ff9800">${statsCache.virtualLosses}V</span>` : '');
            
            // P/L shows LIVE only (virtual trades don't affect real balance)
            const plElement = document.getElementById('totalPL');
            plElement.textContent = statsCache.livePL.toFixed(2) + ' (Live)';
            plElement.className = 'stat-value ' + (statsCache.livePL > 0 ? 'positive' : statsCache.livePL < 0 ? 'negative' : '');
            
            // Show virtual P/L info if there are virtual trades
            if (statsCache.virtualTrades > 0) {
                plElement.title = `Virtual P/L: ${statsCache.virtualPL.toFixed(2)} (not affecting real balance)`;
            }
            
            // Update Stop Loss / Take Profit indicators (LIVE trades only)
            updateSLTPIndicators(statsCache.livePL);
        }
        
        // Update Stop Loss and Take Profit Indicators
        function updateSLTPIndicators(totalPL) {
            const container = document.getElementById('slTpIndicators');
            const slStatus = document.getElementById('slStatus');
            const tpStatus = document.getElementById('tpStatus');
            
            // Show container if either SL or TP is set
            if (settings.stopLoss > 0 || settings.takeProfit > 0) {
                container.style.display = 'block';
                
                // Update Stop Loss
                if (settings.stopLoss > 0) {
                    const distance = totalPL + settings.stopLoss;
                    const percentage = ((distance / settings.stopLoss) * 100).toFixed(0);
                    slStatus.textContent = '-' + settings.stopLoss + ' (' + distance.toFixed(2) + ' away)';
                    
                    // Change color if getting close
                    if (distance < settings.stopLoss * 0.2) {
                        slStatus.style.color = '#ff1744';
                        slStatus.style.fontWeight = '700';
                    }
                } else {
                    slStatus.textContent = 'Not Set';
                }
                
                // Update Take Profit
                if (settings.takeProfit > 0) {
                    const distance = settings.takeProfit - totalPL;
                    const percentage = ((totalPL / settings.takeProfit) * 100).toFixed(0);
                    tpStatus.textContent = '+' + settings.takeProfit + ' (' + distance.toFixed(2) + ' away)';
                    
                    // Change color if getting close
                    if (distance < settings.takeProfit * 0.2) {
                        tpStatus.style.color = '#00e676';
                        tpStatus.style.fontWeight = '700';
                    }
                } else {
                    tpStatus.textContent = 'Not Set';
                }
            } else {
                container.style.display = 'none';
            }
        }
        
        // Check Stop Loss and Take Profit (LIVE TRADES ONLY)
        function checkStopLossTakeProfit(lastTradeProfit) {
            // Only check if auto trading is active
            if (!isAutoTrading) return;
            
            // Get current total P/L from LIVE trades only
            const completedTrades = tradeHistory.filter(t => t.profit !== undefined && !t.isVirtual);
            const totalPL = completedTrades.reduce((sum, t) => sum + (t.profit || 0), 0);
            
            // Check Stop Loss (must be greater than 0 to be active)
            if (settings.stopLoss > 0 && totalPL <= -settings.stopLoss) {
                logActivity('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'error');
                logActivity('ðŸ›‘ STOP LOSS TRIGGERED!', 'error');
                logActivity('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'error');
                logActivity('LIVE P/L: ' + totalPL.toFixed(2) + ' | Stop Loss: -' + settings.stopLoss, 'error');
                logActivity('Auto trading STOPPED to prevent further losses', 'error');
                
                // Stop auto trading
                toggleAutoTrade();
                
                // Start restart timer if enabled
                if (timerFilterEnabled) {
                    logActivity('â° Auto-restart timer enabled - countdown will begin', 'info');
                    logActivity('Delay: ' + restartDelay + ' minute(s)', 'info');
                    startRestartTimer();
                } else {
                    logActivity('Auto-restart timer disabled - manual restart required', 'info');
                }
                
                logActivity('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'error');
                return;
            }
            
            // Check Take Profit (must be greater than 0 to be active)
            if (settings.takeProfit > 0 && totalPL >= settings.takeProfit) {
                logActivity('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
                logActivity('ðŸŽ¯ TAKE PROFIT REACHED!', 'success');
                logActivity('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
                logActivity('LIVE P/L: ' + totalPL.toFixed(2) + ' | Take Profit: +' + settings.takeProfit, 'success');
                logActivity('Auto trading STOPPED to secure profits', 'success');
                
                // Stop auto trading
                toggleAutoTrade();
                
                // Start restart timer if enabled
                if (timerFilterEnabled) {
                    logActivity('â° Auto-restart timer enabled - countdown will begin', 'info');
                    logActivity('Delay: ' + restartDelay + ' minute(s)', 'info');
                    startRestartTimer();
                } else {
                    logActivity('Auto-restart timer disabled - manual restart required', 'info');
                }
                
                logActivity('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
                return;
            }
            
            // Log status if either is active
            if (settings.stopLoss > 0 || settings.takeProfit > 0) {
                let status = 'LIVE P/L: ' + totalPL.toFixed(2);
                if (settings.stopLoss > 0) {
                    const remaining = Math.abs(totalPL + settings.stopLoss);
                    status += ' | SL: -' + settings.stopLoss + ' (';
                    status += remaining.toFixed(2) + ' away)';
                }
                if (settings.takeProfit > 0) {
                    const remaining = settings.takeProfit - totalPL;
                    status += ' | TP: +' + settings.takeProfit + ' (';
                    status += remaining.toFixed(2) + ' away)';
                }
                logActivity(status, 'info');
            }
        }

        // Change Market
        function changeMarket() {
            const selected = document.querySelector('input[name="marketSymbol"]:checked');
            settings.marketSymbol = selected.value;
            
            // Update visual selection
            document.querySelectorAll('.market-radio-item').forEach(item => {
                item.classList.remove('selected');
            });
            selected.parentElement.classList.add('selected');
            
            // Update market name display
            document.getElementById('currentMarketName').textContent = marketNames[settings.marketSymbol];
            document.getElementById('currentMarketPrice').textContent = '-';
            
            saveSettings();
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                subscribeToCandles(); // This handles both price and candle building
            }
            
            logActivity('Market changed to ' + marketNames[settings.marketSymbol], 'info');
        }

        // Change Duration Type
        function changeDurationType() {
            const selected = document.querySelector('input[name="durationType"]:checked');
            settings.durationType = selected.value;
            saveSettings();
            logActivity('Duration type changed to ' + selected.nextElementSibling.textContent, 'info');
        }

        // Change Candle Period
        function changeCandlePeriod() {
            const selected = document.querySelector('input[name="candlePeriod"]:checked');
            const newPeriod = parseInt(selected.value);
            
            if (newPeriod !== candlePeriod) {
                candlePeriod = newPeriod;
                mtfCandlePeriod = getMTFPeriod(); // Update MTF period
                
                // Clear current candle data and reset
                candleData = [];
                currentCandle = null;
                candleStartTime = null;
                totalCandleCount = 0; // Reset counter
                candleCollectionStartTime = null;
                candleCollectionComplete = false;
                
                // Clear MTF candle data
                mtfCandleData = [];
                mtfCurrentCandle = null;
                mtfCandleStartTime = null;
                
                const periodText = candlePeriod === 30 ? '30-second' : '1-minute';
                const mtfLabel = getMTFLabel();
                const speedInfo = candlePeriod === 30 ? ' (Candles will build 2x faster!)' : '';
                logActivity('Candle period changed to ' + periodText + speedInfo + ' - resetting candle data', 'info');
                
                if (settings.mtfEnabled) {
                    logActivity('MTF confirmation timeframe updated to ' + mtfLabel, 'info');
                }
                
                // If connected, resubscribe to rebuild candles with new period
                if (ws && ws.readyState === WebSocket.OPEN && currentCandleSymbol) {
                    const signalElement = document.getElementById('signalValue');
                    const detailsElement = document.getElementById('signalDetails');
                    
                    signalElement.textContent = 'LOADING...';
                    signalElement.className = 'signal-value none';
                    detailsElement.textContent = 'Building ' + periodText + ' candles from live ticks...';
                    
                    logActivity('Rebuilding candles with ' + periodText + ' period...', 'info');
                    
                    // Resubscribe MTF if enabled
                    if (settings.mtfEnabled && mtfSubscription) {
                        ws.send(JSON.stringify({ forget: mtfSubscription }));
                        mtfSubscription = null;
                        subscribeMTFCandles(settings.marketSymbol);
                    }
                }
                
                // Update MTF indicator
                updateMTFIndicator();
                saveSettings();
            }
        }

        // Toggle Filter
        function toggleFilter(filterType) {
            const switchElement = document.getElementById(filterType + 'FilterSwitch');
            const isActive = switchElement.classList.contains('active');
            
            if (isActive) {
                switchElement.classList.remove('active');
                settings[filterType + 'Enabled'] = false;
                
                // If disabling MTF, unsubscribe from higher timeframe
                if (filterType === 'mtf' && mtfSubscription) {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({ forget: mtfSubscription }));
                        mtfSubscription = null;
                        currentMtfCandleSymbol = null;
                        mtfCandleData = [];
                        logActivity('MTF subscription stopped', 'info');
                    }
                }
                
                // If disabling virtual trading
                if (filterType === 'virtual') {
                    virtualTradingEnabled = false;
                    isVirtualMode = false;
                    virtualConsecutiveLosses = 0;
                    logActivity('Virtual trading disabled', 'info');
                }
                
                // If disabling timer
                if (filterType === 'timer') {
                    timerFilterEnabled = false;
                    stopRestartTimer();
                    logActivity('Auto-restart timer disabled', 'info');
                }
            } else {
                switchElement.classList.add('active');
                settings[filterType + 'Enabled'] = true;
                
                // If enabling MTF and logged in, subscribe to higher timeframe
                if (filterType === 'mtf' && isLoggedIn) {
                    subscribeMTFCandles(settings.marketSymbol);
                }
                
                // If enabling virtual trading
                if (filterType === 'virtual') {
                    virtualTradingEnabled = true;
                    isVirtualMode = true;
                    virtualConsecutiveLosses = 0;
                    logActivity('Virtual trading enabled - starting in VIRTUAL mode', 'info');
                }
                
                // If enabling timer
                if (filterType === 'timer') {
                    timerFilterEnabled = true;
                    logActivity('Auto-restart timer enabled - will restart after SL/TP triggers', 'info');
                }
            }
            
            saveSettings();
            updateModeBadges(); // Update visual badges immediately
            
            const filterName = filterType === 'mtf' ? 'MTF' : filterType === 'virtual' ? 'Virtual Trading' : filterType.toUpperCase();
            const status = settings[filterType + 'Enabled'] ? 'enabled' : 'disabled';
            logActivity(filterName + ' filter ' + status, 'info');
            
            // Update MTF indicator
            if (filterType === 'mtf') {
                updateMTFIndicator();
            }
            
            // If trading is active, recalculate strategy with new filter settings
            if (isLoggedIn && candleData.length > 0) {
                logActivity('Applying ' + filterName + ' filter changes in real-time...', 'info');
                calculateStrategy();
            }
        }

        // Get MTF Period Label
        function getMTFLabel() {
            if (candlePeriod === 30) return '3m';
            if (candlePeriod === 60) return '5m';
            return '5m';
        }
        
        // Get MTF Period in Seconds
        function getMTFPeriod() {
            if (candlePeriod === 30) return 180; // 3 minutes
            if (candlePeriod === 60) return 300; // 5 minutes
            return 300;
        }
        
        // Update MTF Indicator Display
        function updateMTFIndicator() {
            const indicator = document.getElementById('mtfIndicator');
            if (indicator) {
                const label = getMTFLabel();
                indicator.textContent = 'Auto: ' + label;
                if (settings.mtfEnabled) {
                    indicator.classList.remove('disabled');
                } else {
                    indicator.classList.add('disabled');
                }
            }
        }

        // Start Restart Timer (after SL/TP trigger)
        function startRestartTimer() {
            if (!timerFilterEnabled) return;
            
            // Stop any existing timer
            stopRestartTimer();
            
            // Set countdown time in seconds
            restartCountdown = restartDelay * 60;
            
            // Show countdown display
            const display = document.getElementById('restartCountdownDisplay');
            display.style.display = 'block';
            
            logActivity('â° Auto-restart timer started: ' + restartDelay + ' minute(s) countdown', 'info');
            
            // Update countdown display immediately
            updateCountdownDisplay();
            
            // Start countdown interval (update every second)
            countdownInterval = setInterval(() => {
                restartCountdown--;
                updateCountdownDisplay();
                
                if (restartCountdown <= 0) {
                    // Time elapsed - restart trading
                    clearInterval(countdownInterval);
                    restartTrading();
                }
            }, 1000);
        }
        
        // Stop Restart Timer
        function stopRestartTimer() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            
            const display = document.getElementById('restartCountdownDisplay');
            display.style.display = 'none';
            
            restartCountdown = 0;
        }
        
        // Update Countdown Display
        function updateCountdownDisplay() {
            const minutes = Math.floor(restartCountdown / 60);
            const seconds = restartCountdown % 60;
            const timeString = String(minutes).padStart(2, '0') + ':' + String(seconds).padStart(2, '0');
            
            document.getElementById('countdownTimer').textContent = timeString;
            
            // Log every minute
            if (restartCountdown % 60 === 0 && restartCountdown > 0) {
                logActivity('â° Restart in ' + minutes + ' minute(s)', 'info');
            }
        }
        
        // Restart Trading (called when timer elapses)
        // Restart Trading (called when timer elapses)
        function restartTrading() {
            logActivity('â° Timer elapsed - Restarting trading cycle', 'success');
            logActivity('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
            logActivity('ðŸ”„ NEW TRADING CYCLE STARTING', 'success');
            logActivity('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
            
            // Hide countdown
            const display = document.getElementById('restartCountdownDisplay');
            display.style.display = 'none';
            
            // CLEAR TRADE HISTORY AND STATISTICS
            logActivity('ðŸ—‘ï¸ Clearing ALL trade history and statistics for fresh cycle', 'info');
            tradeHistory = [];
            
            // Clear statistics cache
            statsCache = {
                liveTrades: 0,
                liveWins: 0,
                liveLosses: 0,
                livePL: 0,
                virtualTrades: 0,
                virtualWins: 0,
                virtualLosses: 0,
                virtualPL: 0,
                lastUpdate: 0
            };
            
            updateTradeHistory();
            updateStatistics();
            logActivity('âœ“ History cleared - Starting from zero', 'success');
            
            // ENFORCE virtual trading mode if enabled (CRITICAL for auto-restart)
            if (virtualTradingEnabled) {
                isVirtualMode = true;
                virtualConsecutiveLosses = 0;
                
                // Save the reset state
                localStorage.setItem('virtualModeState', JSON.stringify({
                    isVirtualMode: isVirtualMode,
                    virtualConsecutiveLosses: virtualConsecutiveLosses
                }));
                
                logActivity('ðŸ”„ VIRTUAL MODE ENFORCED for new cycle', 'success');
                logActivity('Virtual loss threshold: ' + virtualLossThreshold + ' consecutive losses', 'info');
                updateModeBadges();
            } else {
                logActivity('âš ï¸ Virtual trading not enabled - starting in LIVE mode', 'info');
            }
            
            // Start auto trading
            if (!isAutoTrading) {
                toggleAutoTrade();
                logActivity('ðŸ”„ Auto trading STARTED with clean slate', 'success');
            } else {
                logActivity('ðŸ”„ Auto trading already active - continuing', 'info');
            }
            
            logActivity('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
        }

        // Start Contract Tracking System (Smart Duration-Based)
        function startContractTracking() {
            // Smart tracking system - no intervals needed
            // Each contract schedules its own check based on duration
            logActivity('Smart contract tracking system initialized (duration-based)', 'info');
        }
        
        // Schedule Smart Contract Check
        function scheduleContractCheck(contractId, durationSeconds, durationUnit) {
            // Calculate exact wait time based on contract duration
            let waitTimeMs = 0;
            
            if (durationUnit === 't') {
                // Ticks: each tick is ~1 second, add 5 second buffer
                waitTimeMs = (durationSeconds * 1000) + 5000;
            } else if (durationUnit === 's') {
                // Seconds: add 5 second buffer
                waitTimeMs = (durationSeconds * 1000) + 5000;
            } else if (durationUnit === 'm') {
                // Minutes: convert to ms and add 5 second buffer
                waitTimeMs = (durationSeconds * 60 * 1000) + 5000;
            } else if (durationUnit === 'h') {
                // Hours: convert to ms and add 5 second buffer
                waitTimeMs = (durationSeconds * 60 * 60 * 1000) + 5000;
            } else if (durationUnit === 'd') {
                // Days: convert to ms and add 5 second buffer
                waitTimeMs = (durationSeconds * 24 * 60 * 60 * 1000) + 5000;
            }
            
            const waitTimeSec = Math.floor(waitTimeMs / 1000);
            const contract = activeContracts.get(contractId);
            const mode = contract ? (contract.isVirtual ? 'VIRTUAL' : 'LIVE') : '';
            
            logActivity(`â±ï¸ Scheduled check for contract ${contractId} (${mode}) in ${waitTimeSec}s (${durationSeconds}${durationUnit} + 5s buffer)`, 'info');
            
            // Schedule the check
            const timeoutId = setTimeout(() => {
                checkContract(contractId);
            }, waitTimeMs);
            
            // Store timeout reference for cleanup
            contractTimeouts.set(contractId, timeoutId);
        }
        
        // Check Specific Contract
        function checkContract(contractId) {
            if (!activeContracts.has(contractId)) {
                // Contract already removed (completed before scheduled check)
                return;
            }
            
            const contract = activeContracts.get(contractId);
            const mode = contract.isVirtual ? 'VIRTUAL' : 'LIVE';
            
            logActivity(`ðŸ” Checking contract ${contractId} (${mode}) - scheduled check triggered`, 'info');
            
            // Request contract status
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    proposal_open_contract: 1,
                    contract_id: contractId
                }));
                
                // Remove from pending queue if it was there
                pendingContractChecks.delete(contractId);
                
                // Schedule safety check - if contract still not resolved after 30 seconds, force remove
                const safetyTimeoutId = setTimeout(() => {
                    if (activeContracts.has(contractId)) {
                        logActivity(`âš ï¸ Contract ${contractId} unresolved after safety timeout - forcing removal`, 'error');
                        removeContract(contractId, 'TIMEOUT');
                    }
                }, 30000); // 30 second safety timeout
                
                // Store safety timeout (will be cleared when contract is removed)
                contractTimeouts.set(contractId + '_safety', safetyTimeoutId);
                
            } else {
                // FIX #6: WebSocket disconnected - add to pending queue for retry
                logActivity(`âš ï¸ Cannot check contract ${contractId} - WebSocket disconnected, added to retry queue`, 'error');
                pendingContractChecks.add(contractId);
                
                // Schedule a retry check in 5 seconds
                const retryTimeoutId = setTimeout(() => {
                    if (pendingContractChecks.has(contractId)) {
                        logActivity(`ðŸ”„ Retrying contract check for ${contractId}...`, 'info');
                        checkContract(contractId);
                    }
                }, 5000);
                
                contractTimeouts.set(contractId + '_retry', retryTimeoutId);
            }
        }
        
        // Process pending contract checks after reconnection
        function processPendingContractChecks() {
            if (pendingContractChecks.size === 0) return;
            
            logActivity(`ðŸ”„ Processing ${pendingContractChecks.size} pending contract check(s) after reconnection`, 'info');
            
            const contractsToCheck = Array.from(pendingContractChecks);
            contractsToCheck.forEach(contractId => {
                if (activeContracts.has(contractId)) {
                    checkContract(contractId);
                }
            });
        }
        
        // Add Contract to Tracking (Smart Duration-Based)
        function trackContract(contractId, tradeType, stake, duration, durationUnit) {
            const contractInfo = {
                id: contractId,
                tradeType: tradeType,
                stake: stake,
                openTime: Date.now(),
                isVirtual: isVirtualMode,
                duration: duration,
                durationUnit: durationUnit
            };
            
            activeContracts.set(contractId, contractInfo);
            
            const mode = isVirtualMode ? 'VIRTUAL' : 'LIVE';
            logActivity(`ðŸ“Š Tracking contract ${contractId} (${mode} - ${tradeType}) - Duration: ${duration}${durationUnit}`, 'info');
            
            // Schedule smart check based on contract duration
            scheduleContractCheck(contractId, duration, durationUnit);
        }
        
        // Remove Contract from Tracking
        // Remove Contract from Tracking
        function removeContract(contractId, result) {
            if (activeContracts.has(contractId)) {
                const contract = activeContracts.get(contractId);
                const mode = contract.isVirtual ? 'VIRTUAL' : 'LIVE';
                logActivity(`âœ“ Contract ${contractId} completed (${mode} - ${result}), removed from tracking`, 'success');
                activeContracts.delete(contractId);
                
                // Remove from pending checks queue
                pendingContractChecks.delete(contractId);
                
                // Clear main scheduled timeout
                if (contractTimeouts.has(contractId)) {
                    clearTimeout(contractTimeouts.get(contractId));
                    contractTimeouts.delete(contractId);
                }
                
                // Clear safety timeout if exists
                const safetyKey = contractId + '_safety';
                if (contractTimeouts.has(safetyKey)) {
                    clearTimeout(contractTimeouts.get(safetyKey));
                    contractTimeouts.delete(safetyKey);
                }
                
                // Clear retry timeout if exists
                const retryKey = contractId + '_retry';
                if (contractTimeouts.has(retryKey)) {
                    clearTimeout(contractTimeouts.get(retryKey));
                    contractTimeouts.delete(retryKey);
                }
            }
        }
        
        // Clear All Contract Timeouts
        function clearAllContractTimeouts() {
            for (const timeoutId of contractTimeouts.values()) {
                clearTimeout(timeoutId);
            }
            contractTimeouts.clear();
            activeContracts.clear();
            pendingContractChecks.clear();
            logActivity('All contract tracking timeouts cleared', 'info');
        }

        // Save Settings
        function saveSettings() {
            settings.stPeriod = parseInt(document.getElementById('stPeriod').value);
            settings.stMultiplier = parseFloat(document.getElementById('stMultiplier').value);
            settings.rsiPeriod = parseInt(document.getElementById('rsiPeriod').value);
            settings.stakeAmount = parseFloat(document.getElementById('stakeAmount').value);
            settings.stopLoss = parseFloat(document.getElementById('stopLoss').value);
            settings.takeProfit = parseFloat(document.getElementById('takeProfit').value);
            settings.tradeDuration = parseInt(document.getElementById('tradeDuration').value);
            settings.virtualLossThreshold = parseInt(document.getElementById('virtualLossThreshold').value);
            settings.restartDelay = parseInt(document.getElementById('restartDelay').value);
            settings.reverseMode = reverseMode;
            settings.alternatorMode = alternatorMode;
            
            // Update virtual loss threshold in real-time
            virtualLossThreshold = settings.virtualLossThreshold;
            
            // Update restart delay in real-time
            restartDelay = settings.restartDelay;
            
            // Save candle period
            const candlePeriodRadio = document.querySelector('input[name="candlePeriod"]:checked');
            if (candlePeriodRadio) {
                settings.candlePeriod = parseInt(candlePeriodRadio.value);
            }
            
            localStorage.setItem('tradingSettings', JSON.stringify(settings));
            
            // Update badges to reflect current filter settings
            updateModeBadges();
            
            // Update SL/TP indicators
            updateStatistics();
            
            // Apply changes in real-time if trading is active
            if (isLoggedIn && candleData.length > 0) {
                calculateStrategy();
            }
        }

        // Load Settings
        function loadSettings() {
            const saved = localStorage.getItem('tradingSettings');
            if (saved) {
                settings = JSON.parse(saved);
                
                document.getElementById('stPeriod').value = settings.stPeriod;
                document.getElementById('stMultiplier').value = settings.stMultiplier;
                document.getElementById('rsiPeriod').value = settings.rsiPeriod;
                document.getElementById('stakeAmount').value = settings.stakeAmount;
                document.getElementById('stopLoss').value = settings.stopLoss || 0;
                document.getElementById('takeProfit').value = settings.takeProfit || 0;
                document.getElementById('tradeDuration').value = settings.tradeDuration;
                document.getElementById('virtualLossThreshold').value = settings.virtualLossThreshold || 3;
                document.getElementById('restartDelay').value = settings.restartDelay || 5;
                
                if (settings.rsiEnabled) {
                    document.getElementById('rsiFilterSwitch').classList.add('active');
                }
                if (settings.mtfEnabled) {
                    document.getElementById('mtfFilterSwitch').classList.add('active');
                }
                if (settings.virtualEnabled) {
                    document.getElementById('virtualFilterSwitch').classList.add('active');
                    virtualTradingEnabled = true;
                    isVirtualMode = true;
                }
                if (settings.timerEnabled) {
                    document.getElementById('timerFilterSwitch').classList.add('active');
                    timerFilterEnabled = true;
                }
                if (settings.reverseMode) {
                    reverseMode = true;
                    document.getElementById('reverseModeSwitch').classList.add('active');
                }
                if (settings.alternatorMode) {
                    alternatorMode = true;
                    document.getElementById('alternatorModeSwitch').classList.add('active');
                }
                
                // Load virtual loss threshold
                virtualLossThreshold = settings.virtualLossThreshold || 3;
                
                // Load restart delay
                restartDelay = settings.restartDelay || 5;
                
                const durationRadio = document.querySelector(`input[name="durationType"][value="${settings.durationType}"]`);
                if (durationRadio) durationRadio.checked = true;
                
                const marketRadio = document.querySelector(`input[name="marketSymbol"][value="${settings.marketSymbol}"]`);
                if (marketRadio) {
                    marketRadio.checked = true;
                    marketRadio.parentElement.classList.add('selected');
                }
                
                // Load and apply candle period
                if (settings.candlePeriod) {
                    candlePeriod = settings.candlePeriod;
                    mtfCandlePeriod = getMTFPeriod(); // Update MTF period
                    const candlePeriodRadio = document.querySelector(`input[name="candlePeriod"][value="${settings.candlePeriod}"]`);
                    if (candlePeriodRadio) {
                        candlePeriodRadio.checked = true;
                    }
                }
                
                // Update MTF indicator
                updateMTFIndicator();
            }
        }

        // Handle Logout
        function handleLogout() {
            const btn = document.getElementById('logoutBtn');
            
            if (logoutClickCount === 0) {
                logoutClickCount = 1;
                btn.classList.add('confirm');
                btn.textContent = 'Are you sure?';
                
                logoutTimeout = setTimeout(() => {
                    logoutClickCount = 0;
                    btn.classList.remove('confirm');
                    btn.textContent = 'Logout';
                }, 3000);
            } else {
                clearTimeout(logoutTimeout);
                logout();
            }
        }

        // Logout
        function logout() {
            // Unsubscribe from all streams before closing
            if (ws && ws.readyState === WebSocket.OPEN) {
                if (candleSubscription) {
                    ws.send(JSON.stringify({
                        forget: candleSubscription
                    }));
                }
                if (mtfSubscription) {
                    ws.send(JSON.stringify({
                        forget: mtfSubscription
                    }));
                }
            }
            
            if (ws) {
                ws.close();
            }
            
            clearInterval(timerInterval);
            isLoggedIn = false;
            
            // Stop restart timer if active
            stopRestartTimer();
            
            // Clear contract tracking and all scheduled timeouts
            clearAllContractTimeouts();
            logActivity('Contract tracking cleared', 'info');
            
            // Reset subscription IDs
            candleSubscription = null;
            currentCandleSymbol = null;
            mtfSubscription = null;
            currentMtfCandleSymbol = null;
            
            // Reset proposal and trading state
            proposalId = null;
            pendingProposal = null;
            pendingTradeType = null;
            currentSignal = 'NONE';
            isAutoTrading = false;
            candleData = [];
            
            // Reset live candle building
            currentCandle = null;
            candleStartTime = null;
            totalCandleCount = 0;
            candleCollectionStartTime = null;
            candleCollectionComplete = false;
            
            // Reset MTF candle building
            mtfCandleData = [];
            mtfCurrentCandle = null;
            mtfCandleStartTime = null;
            
            // CRITICAL FIX #2: Save virtual trading state before logout
            if (virtualTradingEnabled) {
                const virtualState = {
                    isVirtualMode: isVirtualMode,
                    virtualConsecutiveLosses: virtualConsecutiveLosses
                };
                localStorage.setItem('virtualModeState', JSON.stringify(virtualState));
                logActivity('ðŸ’¾ Virtual mode state saved: ' + (isVirtualMode ? 'VIRTUAL' : 'LIVE') + ' (Losses: ' + virtualConsecutiveLosses + ')', 'info');
            }
            
            // Note: Virtual trading state is now properly saved above
            // It will be restored on next login
            
            // Reset UI
            document.getElementById('apiToken').disabled = false;
            document.getElementById('apiToken').value = '';
            document.getElementById('loginBtn').style.display = 'block';
            document.getElementById('logoutBtn').style.display = 'none';
            document.getElementById('logoutBtn').classList.remove('confirm');
            document.getElementById('logoutBtn').textContent = 'Logout';
            document.getElementById('accountStatus').style.display = 'none';
            document.getElementById('loginSection').classList.remove('logged-in');
            
            // Reset displays
            updateConnectionStatus(false);
            document.getElementById('signalValue').textContent = 'NO SIGNAL';
            document.getElementById('signalValue').className = 'signal-value none';
            document.getElementById('signalDetails').textContent = 'Please login to start';
            document.getElementById('currentMarketPrice').textContent = '-';
            
            // Hide progress bar
            const progressContainer = document.getElementById('progressContainer');
            if (progressContainer) {
                progressContainer.classList.remove('active');
            }
            
            disableTrading();
            
            logActivity('User logged out', 'info');
            logoutClickCount = 0;
            
            // Clear saved token
            localStorage.removeItem('derivApiToken');
        }

        // Handle Clear History
        function handleClearHistory() {
            const btn = document.getElementById('clearHistoryBtn');
            
            if (clearClickCount === 0) {
                clearClickCount = 1;
                btn.classList.add('confirm');
                btn.textContent = 'Are you sure?';
                
                clearHistoryTimeout = setTimeout(() => {
                    clearClickCount = 0;
                    btn.classList.remove('confirm');
                    btn.textContent = 'Clear History';
                }, 3000);
            } else {
                clearTimeout(clearHistoryTimeout);
                clearHistory();
            }
        }

        // Clear History
        function clearHistory() {
            tradeHistory = [];
            updateTradeHistory();
            updateStatistics();
            logActivity('Trade history cleared', 'info');
            
            clearClickCount = 0;
            const btn = document.getElementById('clearHistoryBtn');
            btn.classList.remove('confirm');
            btn.textContent = 'Clear History';
        }

        // Session Timer
        function startSessionTimer() {
            sessionStartTime = new Date();
            
            timerInterval = setInterval(() => {
                const now = new Date();
                const diff = now - sessionStartTime;
                
                const hours = Math.floor(diff / 3600000);
                const minutes = Math.floor((diff % 3600000) / 60000);
                const seconds = Math.floor((diff % 60000) / 1000);
                
                document.getElementById('sessionTimer').textContent = 
                    `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }, 1000);
        }

        // Update Connection Status
        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            const textElement = document.getElementById('connectionText');
            
            if (status === true || status === 'connected') {
                statusElement.classList.add('connected');
                statusElement.classList.remove('connecting');
                textElement.textContent = 'Connected';
            } else if (status === 'connecting') {
                statusElement.classList.remove('connected');
                statusElement.classList.add('connecting');
                textElement.textContent = 'Connecting...';
            } else {
                statusElement.classList.remove('connected');
                statusElement.classList.remove('connecting');
                textElement.textContent = 'Disconnected';
            }
        }

        // Log Activity
        function logActivity(message, type = 'info') {
            const logContainer = document.getElementById('activityLog');
            const time = new Date().toLocaleTimeString();
            
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.innerHTML = `
                <span class="log-time">[${time}]</span>
                <span class="log-message log-${type}">${message}</span>
            `;
            
            logContainer.insertBefore(logEntry, logContainer.firstChild);
            
            // Keep only last 50 entries
            while (logContainer.children.length > 50) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        // Handle browser refresh
        window.addEventListener('beforeunload', function() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                // Settings are already saved automatically
            }
        });
    </script>
</body>
</html>
