<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Deriv Digit Match Pro - AI Enhanced</title>
<style>
/* --- CORE STYLES --- */
body { background: #020617; color: #e5e7eb; font-family: system-ui, -apple-system, sans-serif; margin: 0; padding: 0; }
.app { max-width: 420px; margin: auto; padding: 15px; }
.card { background: #0f172a; padding: 12px; border-radius: 12px; margin-bottom: 12px; border: 1px solid #1e293b; }
h2, h3 { text-align: center; margin-bottom: 8px; margin-top: 8px; }
h2 { color: #22c55e; }
label { font-size: 13px; opacity: 0.8; display: block; margin-top: 8px; }
input[type="number"], input[type="password"], select, button { width: 100%; padding: 10px; margin: 5px 0 10px; border-radius: 8px; border: none; box-sizing: border-box; }
input, select { background: #1e293b; color: #e5e7eb; border: 1px solid #334155; }
input:focus, select:focus { outline: none; border-color: #22c55e; }
button { background: #22c55e; color: #020617; font-weight: 700; cursor: pointer; transition: all 0.2s; }
button:hover { background: #16a34a; transform: translateY(-1px); }
button:active { transform: translateY(0); }
button:disabled { background: #374151; cursor: not-allowed; opacity: 0.5; }
.buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 12px; }
.status-container { display: flex; gap: 5px; margin-bottom: 10px; }
.status { flex: 2; text-align: center; padding: 8px; border-radius: 8px; font-weight: 600; }
.account-type { flex: 1.5; text-align: center; padding: 8px; border-radius: 8px; font-weight: 700; font-size: 11px; display: none; text-transform: uppercase; align-self: center; }
.demo-badge { background: #f59e0b; color: #020617; }
.live-badge { background: #22c55e; color: #020617; }
.connected { background: #16a34a; color: white; }
.disconnected { background: #dc2626; color: white; }
.stats { display: grid; grid-template-columns: repeat(4, 1fr); text-align: center; gap: 10px; }
.stats > div { display: flex; flex-direction: column; gap: 5px; }
.stats span { font-size: 12px; opacity: 0.7; }
.stats b { font-size: 16px; color: #22c55e; }
.table-container { overflow-x: auto; max-height: 300px; overflow-y: auto; }
table { width: 100%; font-size: 13px; border-collapse: collapse; }
thead { position: sticky; top: 0; background: #1e293b; }
th { padding: 8px; text-align: left; font-weight: 600; border-bottom: 2px solid #334155; }
td { padding: 8px; border-bottom: 1px solid #1e293b; }
tbody tr:hover { background: #1e293b; }
.win { color: #22c55e; }
.loss { color: #ef4444; }
.balance-display { text-align: center; padding: 10px; background: #0f172a; border-radius: 8px; margin-bottom: 10px; border: 1px solid #1e293b; }
.balance-display span { opacity: 0.7; font-size: 14px; }
.balance-display b { color: #22c55e; font-size: 18px; margin: 0 5px; }
.session-timer { margin-top: 8px; font-size: 12px; color: #f59e0b; font-weight: 600; }
.reset-button-permanent { background: #f59e0b !important; width: 100%; margin-bottom: 12px; font-size: 15px; display: block; }
.reset-button-permanent:hover { background: #d97706 !important; }
.analyzer-grid { display: grid; grid-template-columns: repeat(10, 1fr); gap: 5px; margin: 10px 0; }
.digit-box { aspect-ratio: 1; display: flex; align-items: center; justify-content: center; border-radius: 6px; font-weight: 700; font-size: 14px; border: 2px solid transparent; }
.digit-match { background: #8b5cf6; color: white; border-color: #22c55e; }
.digit-other { background: #1e293b; color: #94a3b8; }
.analyzer-stats { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; text-align: center; margin-top: 10px; }
.analyzer-stats > div { background: #1e293b; padding: 8px; border-radius: 6px; }
.analyzer-stats span { font-size: 11px; opacity: 0.7; display: block; }
.analyzer-stats b { font-size: 18px; display: block; margin-top: 3px; }
.log-container { background: #020617; border: 1px solid #1e293b; border-radius: 6px; height: 120px; overflow-y: auto; padding: 8px; font-family: 'Courier New', monospace; font-size: 11px; margin-top: 10px; }
.log-entry { margin-bottom: 4px; border-bottom: 1px solid #1e293b; padding-bottom: 2px; }
.log-time { color: #94a3b8; margin-right: 5px; }
.log-msg-info { color: #3b82f6; }
.log-msg-success { color: #22c55e; }
.log-msg-error { color: #ef4444; }
.log-msg-warn { color: #f59e0b; }
.btn-cycle { background: #3b82f6; color: white; margin-bottom: 5px; font-size: 14px; }
.btn-cycle.active { background: #8b5cf6; border: 2px solid #fff; }
.btn-cooldown { background: #475569; color: white; margin-bottom: 5px; font-size: 14px; }
.btn-cooldown.active { background: #f59e0b; color: #020617; border: 2px solid #020617; }
.cycle-timer-display { color: #f59e0b; font-size: 13px; font-weight: bold; text-align: center; margin-bottom: 10px; display: none; padding: 8px; border: 2px dashed #f59e0b; border-radius: 8px; background: rgba(245, 158, 11, 0.1); }

/* Radio Button Styles */
.radio-group { margin: 10px 0; }
.radio-option { display: flex; align-items: center; padding: 8px; margin: 5px 0; background: #1e293b; border-radius: 6px; cursor: pointer; border: 2px solid #334155; transition: all 0.2s; }
.radio-option:hover { border-color: #22c55e; background: #1e3a2b; }
.radio-option input[type="radio"] { margin-right: 10px; cursor: pointer; width: auto; }
.radio-option.selected { border-color: #22c55e; background: #1e3a2b; }
.radio-option label { cursor: pointer; margin: 0; opacity: 1; font-size: 13px; font-weight: 600; width: 100%; }

/* Prediction & Metrics */
.prediction-box { background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); border: 2px solid #8b5cf6; border-radius: 8px; padding: 15px; margin: 10px 0; text-align: center; }
.prediction-status { font-size: 14px; font-weight: 700; color: #94a3b8; margin-bottom: 10px; }
.prediction-digit { font-size: 48px; font-weight: 900; margin: 15px 0; }
.prediction-waiting { color: #f59e0b; }
.prediction-ready { color: #22c55e; animation: pulse 1.5s infinite; }
@keyframes pulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.8; transform: scale(1.05); }
}
.prediction-info { font-size: 11px; opacity: 0.7; margin-top: 10px; line-height: 1.5; }

.accuracy-metrics { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-top: 12px; }
.accuracy-card { background: #020617; padding: 10px; border-radius: 6px; border: 1px solid #334155; text-align: center; }
.accuracy-card .label { font-size: 10px; color: #94a3b8; margin-bottom: 5px; }
.accuracy-card .value { font-size: 18px; font-weight: 700; color: #8b5cf6; }
.confidence-bar { width: 100%; height: 8px; background: #1e293b; border-radius: 4px; overflow: hidden; margin-top: 10px; }
.confidence-fill { height: 100%; background: linear-gradient(90deg, #ef4444, #f59e0b, #22c55e); transition: width 0.3s; }
.pattern-indicator { margin-top: 10px; padding: 8px; background: #1e293b; border-radius: 6px; font-size: 11px; }
.pattern-strong { border-left: 4px solid #22c55e; }
.pattern-medium { border-left: 4px solid #f59e0b; }
.pattern-weak { border-left: 4px solid #ef4444; }

/* Toggle Switch Style */
.switch-container { display: flex; justify-content: space-between; align-items: center; background: #1e293b; padding: 10px; border-radius: 8px; border: 1px solid #ef4444; margin-bottom: 10px; }
.switch-label { color: #ef4444; font-weight: bold; font-size: 14px; }
.toggle-checkbox { width: 20px !important; height: 20px !important; margin: 0 !important; cursor: pointer; }

/* Virtual Trade Styles */
.virtual-trade-container { background: #1e293b; padding: 10px; border-radius: 8px; border: 2px solid #8b5cf6; margin-bottom: 10px; }
.virtual-trade-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
.virtual-trade-label { color: #8b5cf6; font-weight: bold; font-size: 14px; }
.virtual-mode-badge { background: #8b5cf6; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 700; display: none; }
.virtual-mode-badge.active { display: inline-block; animation: blink 1.5s infinite; }
@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}
.virtual-stats { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-top: 10px; }
.virtual-stat-box { background: #0f172a; padding: 8px; border-radius: 6px; text-align: center; border: 1px solid #334155; }
.virtual-stat-box span { font-size: 10px; color: #94a3b8; display: block; }
.virtual-stat-box b { font-size: 16px; color: #8b5cf6; display: block; margin-top: 3px; }

/* AI Model Selector */
.ai-model-selector { background: #1e293b; padding: 10px; border-radius: 8px; border: 2px solid #3b82f6; margin-bottom: 10px; }
.ai-model-label { color: #3b82f6; font-weight: bold; font-size: 14px; margin-bottom: 8px; }
.model-option { display: flex; align-items: center; padding: 6px; margin: 4px 0; background: #0f172a; border-radius: 4px; cursor: pointer; border: 2px solid #334155; transition: all 0.2s; }
.model-option:hover { border-color: #3b82f6; }
.model-option.selected { border-color: #3b82f6; background: #1e3a4b; }
.model-option input[type="radio"] { margin-right: 8px; cursor: pointer; width: auto; }
.model-option label { cursor: pointer; margin: 0; font-size: 12px; width: 100%; }
.model-description { font-size: 9px; opacity: 0.6; margin-top: 2px; }
.ai-training-status { font-size: 10px; color: #f59e0b; margin-top: 8px; text-align: center; }
</style>
</head>
<body>
<div class="app">

<h2>Deriv Digit Match Pro - AI Enhanced</h2>

<div class="status-container">
    <div id="status" class="status disconnected">Disconnected</div>
    <div id="accountType" class="account-type"></div>
</div>

<div id="balanceDisplay" class="balance-display" style="display:none;">
  <span>Balance:</span>
  <b id="balance">0.00</b>
  <span id="balanceCurrency">USD</span>
  <div id="sessionTimer" class="session-timer">Session: 00:00:00</div>
</div>

<div class="card">
  <input id="token" type="password" placeholder="Deriv API Token" required>
  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <button id="loginBtn">Login</button>
    <button id="logoutBtn" style="background: #ef4444;">Logout</button>
  </div>
</div>

<div class="card">
  <h3>ðŸ¤– AI Prediction Model</h3>
  <div class="ai-model-selector">
    <div class="ai-model-label">Select Prediction Engine:</div>
    <div class="model-option selected" data-model="markov1">
      <input type="radio" name="aiModel" value="markov1" id="modelMarkov1" checked>
      <div style="flex: 1;">
        <label for="modelMarkov1">Standard Markov (1st Order)</label>
        <div class="model-description">Basic single-digit transition analysis</div>
      </div>
    </div>
    <div class="model-option" data-model="markov2">
      <input type="radio" name="aiModel" value="markov2" id="modelMarkov2">
      <div style="flex: 1;">
        <label for="modelMarkov2">Advanced Markov (2nd Order)</label>
        <div class="model-description">Two-digit sequence patterns - 5-10% accuracy boost</div>
      </div>
    </div>
    <div class="model-option" data-model="markov3">
      <input type="radio" name="aiModel" value="markov3" id="modelMarkov3">
      <div style="flex: 1;">
        <label for="modelMarkov3">Deep Markov (3rd Order)</label>
        <div class="model-description">Three-digit sequence patterns - 10-15% accuracy boost</div>
      </div>
    </div>
    <div class="model-option" data-model="ensemble">
      <input type="radio" name="aiModel" value="ensemble" id="modelEnsemble">
      <div style="flex: 1;">
        <label for="modelEnsemble">Ensemble + Features</label>
        <div class="model-description">Multi-model voting with time/volatility features</div>
      </div>
    </div>
    <div class="ai-training-status" id="aiTrainingStatus">Model Ready</div>
  </div>
</div>

<div class="card">
  <h3>ðŸ“Š Enhanced Digit Match Analyzer</h3>
  <div class="analyzer-grid" id="digitDisplay"></div>
  <div class="analyzer-stats">
    <div><span>Predicted</span><b id="matchCount" style="color: #8b5cf6;">-</b></div>
    <div><span>Total Ticks</span><b id="totalCount" style="color: #e5e7eb;">0</b></div>
    <div><span>Frequency</span><b id="matchPercent" style="color: #8b5cf6;">0%</b></div>
  </div>
  
  <div class="prediction-box">
    <div class="prediction-status">ðŸŽ¯ AI Next Digit Prediction</div>
    <div class="prediction-digit" id="predictionDisplay">
      <span class="prediction-waiting">WAITING...</span>
    </div>
    <div class="confidence-bar">
      <div class="confidence-fill" id="confidenceBar" style="width: 0%"></div>
    </div>
    <div class="prediction-info" id="predictionInfo">Analyzing tick patterns...</div>
    
    <div class="accuracy-metrics">
      <div class="accuracy-card">
        <div class="label">Probability</div>
        <div class="value" id="probabilityValue">0%</div>
      </div>
      <div class="accuracy-card">
        <div class="label">Pattern Score</div>
        <div class="value" id="patternScore">0</div>
      </div>
      <div class="accuracy-card">
        <div class="label">Frequency</div>
        <div class="value" id="frequencyValue">0%</div>
      </div>
    </div>
    
    <div id="patternIndicator" class="pattern-indicator pattern-weak">
      <strong>Pattern Strength:</strong> <span id="patternStrength">Learning...</span>
    </div>
  </div>

  <div style="margin-top: 15px; border-top: 1px solid #334155; padding-top: 10px;">
    <div style="font-size: 12px; font-weight: 600; color: #94a3b8; display: flex; justify-content: space-between;">
      <span>SYSTEM & TRADE LOG</span>
      <span id="clearLog" style="cursor:pointer; color:#3b82f6">Clear</span>
    </div>
    <div class="log-container" id="logContainer">
      <div class="log-entry"><span class="log-time">[System]</span> <span class="log-msg-success">AI Engine Ready.</span></div>
    </div>
  </div>
</div>

<div class="card">
  <h3>Trade Settings</h3>
  
  <!-- Virtual Trade Section -->
  <div class="virtual-trade-container">
    <div class="virtual-trade-header">
      <div style="display:flex; flex-direction:column;">
        <span class="virtual-trade-label">ðŸŽ® Virtual Trade Mode</span>
        <span style="font-size:9px; opacity:0.6;">Practice until consecutive losses hit, then go LIVE</span>
      </div>
      <div style="display:flex; align-items:center; gap: 8px;">
        <span class="virtual-mode-badge" id="virtualModeBadge">VIRTUAL MODE</span>
        <div style="display:flex; align-items:center;">
          <span style="font-size:10px; margin-right:5px; opacity:0.7;">OFF/ON</span>
          <input type="checkbox" id="virtualTradeToggle" class="toggle-checkbox save-setting">
        </div>
      </div>
    </div>
    
    <label style="margin-top: 5px;">Consecutive Losses to Switch to Live</label>
    <input id="virtualLossThreshold" class="save-setting" type="number" value="3" min="1" max="20" step="1">
    
    <div class="virtual-stats">
      <div class="virtual-stat-box">
        <span>Consecutive Losses</span>
        <b id="virtualConsecLosses">0</b>
      </div>
      <div class="virtual-stat-box">
        <span>Virtual Trades</span>
        <b id="virtualTotalTrades">0</b>
      </div>
      <div class="virtual-stat-box">
        <span>Virtual P/L</span>
        <b id="virtualProfit">0.00</b>
      </div>
    </div>
  </div>
  
  <label>Stake ($)</label>
  <input id="stake" class="save-setting" type="number" value="1" min="0.35" step="0.01">
  <label>Duration (Ticks)</label>
  <input id="duration" class="save-setting" type="number" value="1" min="1" max="10">
  <label>Cooldown (seconds)</label>
  <input id="cooldown" class="save-setting" type="number" value="2" min="1">
  
  <label>Minimum Confidence Threshold (%)</label>
  <input id="minConfidence" class="save-setting" type="number" value="15" min="0" max="100" step="5">

  <label>Manual Digit Override (0 = Auto Mode)</label>
  <input id="manualDigit" class="save-setting" type="number" value="0" min="0" max="9" step="1">

  <div style="margin-top: 15px; border-top: 1px solid #334155; padding-top: 15px;">
    <div class="switch-container">
      <div style="display:flex; flex-direction:column;">
        <span class="switch-label">âš¡ Exclusive Prediction Mapper</span>
        <span style="font-size:9px; opacity:0.6;">ONLY trades if Prediction matches Condition.</span>
      </div>
      <div style="display:flex; align-items:center;">
        <span style="font-size:10px; margin-right:5px; opacity:0.7;">OFF/ON</span>
        <input type="checkbox" id="mapperToggle" class="toggle-checkbox save-setting">
      </div>
    </div>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
      <div>
        <label style="font-size: 11px; color: #94a3b8; margin-top:0;">IF AI PREDICTS:</label>
        <input id="mapperTrigger" class="save-setting" type="number" placeholder="Trigger" min="0" max="9" style="border: 1px solid #ef4444; text-align: center;">
      </div>
      <div>
        <label style="font-size: 11px; color: #94a3b8; margin-top:0;">THEN TRADE:</label>
        <input id="mapperTarget" class="save-setting" type="number" placeholder="Target" min="0" max="9" style="border: 1px solid #22c55e; text-align: center;">
      </div>
    </div>
    <div style="font-size: 10px; opacity: 0.8; color: #fca5a5; margin-top: 5px; text-align: center;">
       Logic: If ON, bot ignores ALL predictions except Trigger.
    </div>
  </div>

  <label style="margin-top: 15px;">Market</label>
  <div class="radio-group" id="marketRadios">
      <div class="radio-option" data-market="R_10">
          <input type="radio" name="market" value="R_10" id="marketR10" checked>
          <label for="marketR10">R_10</label>
      </div>
      <div class="radio-option" data-market="R_25">
          <input type="radio" name="market" value="R_25" id="marketR25">
          <label for="marketR25">R_25</label>
      </div>
      <div class="radio-option" data-market="R_50">
          <input type="radio" name="market" value="R_50" id="marketR50">
          <label for="marketR50">R_50</label>
      </div>
      <div class="radio-option" data-market="R_75">
          <input type="radio" name="market" value="R_75" id="marketR75">
          <label for="marketR75">R_75</label>
      </div>
      <div class="radio-option" data-market="R_100">
          <input type="radio" name="market" value="R_100" id="marketR100">
          <label for="marketR100">R_100</label>
      </div>
  </div>
</div>

<div class="card">
  <h3>Risk Management</h3>
  <label>Stop Loss ($)</label>
  <input id="stoploss" class="save-setting" type="number" value="10" min="1">
  <label>Take Profit ($)</label>
  <input id="takeprofit" class="save-setting" type="number" value="10" min="1">
</div>

<button id="cycleBtn" class="btn-cycle">Auto Market Cycle: OFF</button>
<button id="cooldownBtn" class="btn-cooldown">Cycle Cooldown Loop: OFF</button>
<div id="cycleTimerDisplay" class="cycle-timer-display">Next Loop in: --:--</div>

<div class="card" style="margin-top: 0;">
  <label>Wait Time (Minutes)</label>
  <input id="cycleWaitTime" class="save-setting" type="number" value="5" min="1">
</div>

<div class="buttons">
  <button id="manualBtn">Manual Trade</button>
  <button id="autoBtn">Start Auto</button>
</div>

<button id="resetBtn" class="reset-button-permanent">ðŸ”„ Reset All Stats</button>

<div class="card stats">
  <div><span>Trades</span><b id="trades">0</b></div>
  <div><span>Wins</span><b id="wins">0</b></div>
  <div><span>Losses</span><b id="losses">0</b></div>
  <div><span>P/L</span><b id="profit">0.00</b></div>
</div>

<div class="card">
<h3>Trade History</h3>
<div class="table-container">
<table>
<thead><tr><th>#</th><th>Mode</th><th>Result</th><th>P/L</th><th>Market</th></tr></thead>
<tbody id="history"></tbody>
</table>
</div>
</div>

</div>

<script>
(function() {
  'use strict';
  
  // ============ SHARED CONFIG ============
  const Config = {
    currentMarketValue: 'R_10',
    marketSequence: ["R_10", "R_25", "R_50", "R_75", "R_100"],
    accountBalance: 0,
    selectedAIModel: 'markov1'
  };

  // ============ APP MODULES ============
  const App = {
    modules: {},
    init() {
      this.modules.UI.init();
      this.modules.Connection.init();
      this.modules.AIEngine.init();
      this.modules.Analyzer.init();
      this.modules.VirtualTrade.init();
      this.modules.Trader.init();
      
      this.modules.UI.loadSettings();
      
      const savedToken = sessionStorage.getItem('derivToken');
      if (savedToken) { 
        document.getElementById('token').value = savedToken; 
        setTimeout(() => this.modules.Connection.connect(), 1000); 
      }
      
      this.modules.UI.addLog("System: AI Engine Initialized.", "success");
    }
  };

  // ============ AI ENGINE MODULE ============
  App.modules.AIEngine = (function() {
    // Higher-order Markov chains storage
    let markov2Matrix = {}; // Key: "d1-d2", Value: {0:count, 1:count, ...}
    let markov3Matrix = {}; // Key: "d1-d2-d3", Value: {0:count, 1:count, ...}
    
    // Feature engineering
    let tickTimestamps = [];
    let volatilityBuffer = [];
    
    // Ensemble weights
    const ensembleWeights = {
      markov1: 0.3,
      markov2: 0.35,
      markov3: 0.35
    };
    
    function init() {
      document.querySelectorAll('.model-option').forEach(opt => {
        opt.addEventListener('click', (e) => {
          const model = e.currentTarget.dataset.model;
          selectModel(model);
        });
      });
      
      // Load saved model selection
      const savedModel = localStorage.getItem('selectedAIModel');
      if (savedModel) {
        selectModel(savedModel);
      }
    }
    
    function selectModel(model) {
      Config.selectedAIModel = model;
      document.querySelectorAll('.model-option').forEach(el => {
        el.classList.toggle('selected', el.dataset.model === model);
      });
      const radioEl = document.getElementById('model' + model.charAt(0).toUpperCase() + model.slice(1));
      if (radioEl) radioEl.checked = true;
      
      localStorage.setItem('selectedAIModel', model);
      
      const statusEl = document.getElementById('aiTrainingStatus');
      statusEl.textContent = `${getModelName(model)} Active`;
      
      App.modules.UI.addLog(`AI Model: ${getModelName(model)} selected`, "info");
    }
    
    function getModelName(model) {
      const names = {
        markov1: 'Standard Markov',
        markov2: 'Advanced Markov (2nd Order)',
        markov3: 'Deep Markov (3rd Order)',
        ensemble: 'Ensemble Multi-Model'
      };
      return names[model] || 'Unknown Model';
    }
    
    // Update higher-order Markov models
    function updateMarkov2(history) {
      if (history.length < 3) return;
      
      const prev2 = history[2];
      const prev1 = history[1];
      const current = history[0];
      
      const key = `${prev2}-${prev1}`;
      if (!markov2Matrix[key]) {
        markov2Matrix[key] = {};
      }
      markov2Matrix[key][current] = (markov2Matrix[key][current] || 0) + 1;
    }
    
    function updateMarkov3(history) {
      if (history.length < 4) return;
      
      const prev3 = history[3];
      const prev2 = history[2];
      const prev1 = history[1];
      const current = history[0];
      
      const key = `${prev3}-${prev2}-${prev1}`;
      if (!markov3Matrix[key]) {
        markov3Matrix[key] = {};
      }
      markov3Matrix[key][current] = (markov3Matrix[key][current] || 0) + 1;
    }
    
    // Predict using 2nd order Markov
    function predictMarkov2(history) {
      if (history.length < 2) return { digit: null, confidence: 0 };
      
      const prev2 = history[1];
      const prev1 = history[0];
      const key = `${prev2}-${prev1}`;
      
      const counts = markov2Matrix[key];
      if (!counts) return { digit: null, confidence: 0 };
      
      const total = Object.values(counts).reduce((a, b) => a + b, 0);
      if (total < 10) return { digit: null, confidence: 0 }; // Need min samples
      
      let maxDigit = -1;
      let maxCount = -1;
      
      for (let d = 0; d < 10; d++) {
        const count = counts[d] || 0;
        if (count > maxCount) {
          maxCount = count;
          maxDigit = d;
        }
      }
      
      const probability = (maxCount / total) * 100;
      return { digit: maxDigit, confidence: probability };
    }
    
    // Predict using 3rd order Markov with Laplace smoothing
    function predictMarkov3(history) {
      if (history.length < 3) return { digit: null, confidence: 0 };
      
      const prev3 = history[2];
      const prev2 = history[1];
      const prev1 = history[0];
      const key = `${prev3}-${prev2}-${prev1}`;
      
      const counts = markov3Matrix[key];
      if (!counts) return { digit: null, confidence: 0 };
      
      const total = Object.values(counts).reduce((a, b) => a + b, 0);
      if (total < 8) return { digit: null, confidence: 0 }; // Need min samples
      
      // Apply Laplace smoothing for sparse data
      const alpha = 0.5; // Smoothing parameter
      const smoothedCounts = {};
      let smoothedTotal = total + (alpha * 10);
      
      let maxDigit = -1;
      let maxProb = -1;
      
      for (let d = 0; d < 10; d++) {
        const rawCount = counts[d] || 0;
        const smoothedCount = rawCount + alpha;
        smoothedCounts[d] = smoothedCount;
        
        const prob = smoothedCount / smoothedTotal;
        if (prob > maxProb) {
          maxProb = prob;
          maxDigit = d;
        }
      }
      
      const probability = maxProb * 100;
      return { digit: maxDigit, confidence: probability };
    }
    
    // Calculate volatility feature
    function calculateVolatility(history, window = 10) {
      if (history.length < window) return 0;
      
      const recent = history.slice(0, window);
      const mean = recent.reduce((a, b) => a + b, 0) / window;
      const variance = recent.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / window;
      return Math.sqrt(variance);
    }
    
    // Time-based features
    function getTimeFeatures() {
      const now = new Date();
      const hour = now.getHours();
      const minute = now.getMinutes();
      
      // Cyclical encoding for time
      const hourSin = Math.sin(2 * Math.PI * hour / 24);
      const hourCos = Math.cos(2 * Math.PI * hour / 24);
      const minuteSin = Math.sin(2 * Math.PI * minute / 60);
      const minuteCos = Math.cos(2 * Math.PI * minute / 60);
      
      return { hourSin, hourCos, minuteSin, minuteCos };
    }
    
    // Ensemble prediction combining multiple models
    function predictEnsemble(history, markov1Pred) {
      const predictions = [];
      const weights = [];
      
      // Get predictions from each model
      if (markov1Pred.digit !== null) {
        predictions.push(markov1Pred);
        weights.push(ensembleWeights.markov1);
      }
      
      const markov2Pred = predictMarkov2(history);
      if (markov2Pred.digit !== null) {
        predictions.push(markov2Pred);
        weights.push(ensembleWeights.markov2);
      }
      
      const markov3Pred = predictMarkov3(history);
      if (markov3Pred.digit !== null) {
        predictions.push(markov3Pred);
        weights.push(ensembleWeights.markov3);
      }
      
      if (predictions.length === 0) {
        return { digit: null, confidence: 0 };
      }
      
      // Voting mechanism with weighted confidence
      const votes = {};
      const confidences = {};
      
      predictions.forEach((pred, idx) => {
        const digit = pred.digit;
        const weight = weights[idx];
        const weightedConf = pred.confidence * weight;
        
        votes[digit] = (votes[digit] || 0) + weight;
        confidences[digit] = (confidences[digit] || 0) + weightedConf;
      });
      
      // Find digit with highest weighted vote
      let bestDigit = -1;
      let bestVote = -1;
      
      for (let d = 0; d < 10; d++) {
        const vote = votes[d] || 0;
        if (vote > bestVote) {
          bestVote = vote;
          bestDigit = d;
        }
      }
      
      // Calculate ensemble confidence
      const totalWeight = weights.reduce((a, b) => a + b, 0);
      const avgConfidence = confidences[bestDigit] / totalWeight;
      
      // Boost confidence if multiple models agree
      const agreement = predictions.filter(p => p.digit === bestDigit).length;
      const agreementBoost = 1 + (agreement - 1) * 0.15; // 15% boost per agreeing model
      const finalConfidence = Math.min(avgConfidence * agreementBoost, 95);
      
      return { digit: bestDigit, confidence: finalConfidence };
    }
    
    // Master prediction function
    function getPrediction(history, markov1Pred) {
      const model = Config.selectedAIModel;
      
      switch(model) {
        case 'markov1':
          return markov1Pred;
        
        case 'markov2':
          const pred2 = predictMarkov2(history);
          return pred2.digit !== null ? pred2 : markov1Pred;
        
        case 'markov3':
          const pred3 = predictMarkov3(history);
          return pred3.digit !== null ? pred3 : markov1Pred;
        
        case 'ensemble':
          return predictEnsemble(history, markov1Pred);
        
        default:
          return markov1Pred;
      }
    }
    
    // Update all models with new tick
    function updateModels(history) {
      updateMarkov2(history);
      updateMarkov3(history);
      
      // Update volatility buffer
      if (history.length > 0) {
        const volatility = calculateVolatility(history, 10);
        volatilityBuffer.push(volatility);
        if (volatilityBuffer.length > 100) volatilityBuffer.shift();
      }
      
      // Update tick timestamps for frequency analysis
      tickTimestamps.push(Date.now());
      if (tickTimestamps.length > 100) tickTimestamps.shift();
    }
    
    function reset() {
      markov2Matrix = {};
      markov3Matrix = {};
      tickTimestamps = [];
      volatilityBuffer = [];
      App.modules.UI.addLog("AI models reset for new market", "warn");
    }
    
    function getData() {
      return {
        markov2Matrix,
        markov3Matrix,
        volatilityBuffer,
        tickTimestamps
      };
    }
    
    function setData(data) {
      if (data.markov2Matrix) markov2Matrix = data.markov2Matrix;
      if (data.markov3Matrix) markov3Matrix = data.markov3Matrix;
      if (data.volatilityBuffer) volatilityBuffer = data.volatilityBuffer;
      if (data.tickTimestamps) tickTimestamps = data.tickTimestamps;
    }
    
    return {
      init,
      updateModels,
      getPrediction,
      reset,
      getData,
      setData,
      calculateVolatility,
      getTimeFeatures
    };
  })();

  // ============ CONNECTION MODULE ============
  App.modules.Connection = (function() {
    let ws = null;
    let isConnected = false;
    let isExplicitLogout = false;
    let lastRequestTime = 0;
    
    function connect() {
      const token = document.getElementById('token').value.trim();
      if (!token) { 
        App.modules.UI.addLog("Error: API Token missing.", "error"); 
        return; 
      }
      if (ws) ws.close();
      sessionStorage.setItem('derivToken', token);
      isExplicitLogout = false;
      App.modules.UI.updateStatus('Connecting...', 'disconnected');
      
      ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=1089');
      
      ws.onopen = () => { 
        App.modules.UI.addLog("WebSocket Connected.", "info"); 
        sendAPIRequest({ authorize: token }); 
      };
      
      ws.onmessage = (msg) => handleMessage(JSON.parse(msg.data));
      
      ws.onclose = () => {
        isConnected = false;
        App.modules.UI.updateStatus('Disconnected', 'disconnected');
        document.getElementById('accountType').style.display = 'none';
        if (!isExplicitLogout) { 
          App.modules.UI.addLog("Connection lost. Reconnecting in 5s...", "warn"); 
          setTimeout(connect, 5000); 
        }
      };
      
      ws.onerror = (error) => { console.error("WebSocket error:", error); };
    }
    
    function handleMessage(data) {
      if (data.error) { 
        App.modules.UI.addLog(`API ERROR: ${data.error.message}`, "error"); 
        return; 
      }
      
      if (data.authorize) {
        isConnected = true;
        App.modules.UI.updateStatus('Connected', 'connected');
        const accTypeEl = document.getElementById('accountType');
        const isVirtual = data.authorize.is_virtual === 1 || data.authorize.loginid.includes('VRTC');
        accTypeEl.textContent = isVirtual ? 'Demo Account' : 'Live Account';
        accTypeEl.className = 'account-type ' + (isVirtual ? 'demo-badge' : 'live-badge');
        accTypeEl.style.display = 'block';
        App.modules.UI.addLog(`Authorized: ${data.authorize.email}`, "success");
        sendAPIRequest({ balance: 1, subscribe: 1 });
        subscribeToTicks();
        App.modules.UI.startSessionTimer();
        
        const persistedAuto = localStorage.getItem('isAutoRunning') === 'true';
        if(persistedAuto && !App.modules.Trader.getAutoRunning()) {
          App.modules.Trader.resumeAutoTrade();
        }
      }
      
      if (data.balance) { 
        Config.accountBalance = data.balance.balance; 
        App.modules.UI.updateBalance(); 
      }
      
      if (data.tick) {
        const lastDigit = parseInt(data.tick.quote.toString().slice(-1));
        App.modules.Analyzer.processTick(lastDigit);
      }
      
      if (data.buy) {
        App.modules.Trader.setContractId(data.buy.contract_id);
        App.modules.UI.addLog(`Trade Placed (ID: ${data.buy.contract_id})`, "success");
        sendAPIRequest({ proposal_open_contract: 1, contract_id: data.buy.contract_id, subscribe: 1 });
      }
      
      if (data.proposal_open_contract) {
        const contract = data.proposal_open_contract;
        if (contract.is_settled === 1 || ['won', 'lost', 'sold'].includes(contract.status)) {
          App.modules.Trader.handleTradeResult(contract);
          App.modules.Trader.setContractId(null);
          if (data.subscription) sendAPIRequest({ forget: data.subscription.id });
        }
      }
    }
    
    function sendAPIRequest(data) { 
      if (ws && ws.readyState === WebSocket.OPEN) { 
        const now = Date.now();
        if (now - lastRequestTime < 100) { 
          setTimeout(() => sendAPIRequest(data), 100);
          return false;
        }
        lastRequestTime = now;
        ws.send(JSON.stringify(data)); 
        return true; 
      } 
      return false; 
    }
    
    function subscribeToTicks() {
      const market = Config.currentMarketValue;
      sendAPIRequest({ forget_all: "ticks" });
      App.modules.Analyzer.resetForNewMarket();
      document.getElementById('digitDisplay').innerHTML = '';
      App.modules.UI.addLog(`Watching ${market}...`, "info");
      sendAPIRequest({ ticks: market, subscribe: 1 });
    }
    
    return {
      init() {
        document.getElementById('loginBtn').addEventListener('click', connect);
        document.getElementById('logoutBtn').addEventListener('click', () => { 
          isExplicitLogout = true; 
          localStorage.removeItem('isAutoRunning');
          if (ws) ws.close(); 
          sessionStorage.removeItem('derivToken'); 
          App.modules.UI.addLog("Logging out...", "info");
          setTimeout(() => location.reload(), 500);
        });
      },
      connect,
      subscribeToTicks,
      sendAPIRequest,
      isConnected: () => isConnected
    };
  })();

  // ============ ANALYZER MODULE ============
  App.modules.Analyzer = (function() {
    let digitHistory = [];
    let transitionMatrix = Array(10).fill(0).map(() => Array(10).fill(0));
    let totalTransitions = Array(10).fill(0);
    
    let predictedDigit = null;
    let predictionConfidence = 0;
    let lastDigit = null;
    
    function processTick(digit) {
      // Store current digit for virtual trade validation
      lastDigit = digit;
      
      // 1. Update History & Math FIRST
      digitHistory.unshift(digit);
      if (digitHistory.length > 1000) digitHistory.pop();
      
      if (digitHistory.length > 1) {
        const prevDigit = digitHistory[1];
        transitionMatrix[prevDigit][digit]++;
        totalTransitions[prevDigit]++;
      }
      
      // 2. Update AI models (higher-order Markov chains)
      App.modules.AIEngine.updateModels(digitHistory);
      
      // 3. CALCULATE PREDICTION INTERNALLY (Before UI)
      const internalPred = calculateInternalPrediction(digit);
      
      // 4. Process pending virtual trade if exists
      App.modules.VirtualTrade.processTickResult(digit);
      
      // 5. TRADE CHECK (Pass the prediction to Trader)
      if (App.modules.Trader.getAutoRunning() && !App.modules.Trader.getCycleCooldown()) {
         App.modules.Trader.checkAndAutoTrade(internalPred); 
      }
      
      // 6. UPDATE UI
      updateDisplay();
      updatePredictionUI(internalPred, digit);
    }
    
    function calculateInternalPrediction(lastDigit) {
      const row = transitionMatrix[lastDigit];
      const total = totalTransitions[lastDigit];
      
      // Calculate basic Markov 1st order prediction
      let markov1Prediction = { digit: null, confidence: 0 };
      
      if (total >= 15) {
        let bestNextDigit = -1;
        let highestCount = -1;
        
        for(let i=0; i<10; i++) {
          if(row[i] > highestCount) {
            highestCount = row[i];
            bestNextDigit = i;
          }
        }
        
        const probability = (highestCount / total) * 100;
        markov1Prediction = { digit: bestNextDigit, confidence: probability };
      }
      
      // Get AI-enhanced prediction based on selected model
      const aiPrediction = App.modules.AIEngine.getPrediction(digitHistory, markov1Prediction);
      
      return aiPrediction;
    }
    
    function updatePredictionUI(pred, lastDigit) {
      predictedDigit = pred.digit;
      predictionConfidence = pred.confidence;
      
      const total = totalTransitions[lastDigit];
      
      if (pred.digit === null) {
        const minSamples = Config.selectedAIModel === 'markov1' ? 15 : 
                          Config.selectedAIModel === 'markov2' ? 10 : 8;
        document.getElementById('predictionInfo').textContent = `Gathering data for digit ${lastDigit}... (${total}/${minSamples})`;
        App.modules.UI.updatePredictionDisplay(null, 0);
        return;
      }

      const modelName = getModelDisplayName();
      const info = `${modelName}: When ${lastDigit} appears, ${pred.digit} follows ${pred.confidence.toFixed(1)}% of the time.`;
      document.getElementById('predictionInfo').textContent = info;
      
      const strengthEl = document.getElementById('patternStrength');
      const indicatorEl = document.getElementById('patternIndicator');
      
      if (pred.confidence > 20) {
        strengthEl.textContent = "Strong Trend";
        indicatorEl.className = "pattern-indicator pattern-strong";
      } else if (pred.confidence > 14) {
        strengthEl.textContent = "Moderate Trend";
        indicatorEl.className = "pattern-indicator pattern-medium";
      } else {
        strengthEl.textContent = "Random / Weak";
        indicatorEl.className = "pattern-indicator pattern-weak";
      }
      
      document.getElementById('probabilityValue').textContent = pred.confidence.toFixed(1) + '%';
      document.getElementById('patternScore').textContent = total;
      
      const freq = digitHistory.filter(d => d === pred.digit).length;
      const freqPct = digitHistory.length > 0 ? (freq / digitHistory.length * 100) : 0;
      document.getElementById('frequencyValue').textContent = freqPct.toFixed(1) + '%';
      
      App.modules.UI.updatePredictionDisplay(pred.digit, pred.confidence);
    }
    
    function getModelDisplayName() {
      const model = Config.selectedAIModel;
      const names = {
        markov1: 'Markov-1',
        markov2: 'Markov-2',
        markov3: 'Markov-3',
        ensemble: 'Ensemble'
      };
      return names[model] || 'AI';
    }
    
    function updateDisplay() {
      const container = document.getElementById('digitDisplay');
      container.innerHTML = '';
      digitHistory.slice(0, 50).forEach((digit, i) => {
        const box = document.createElement('div');
        box.className = `digit-box ${i===0 ? 'digit-match' : 'digit-other'}`;
        box.textContent = digit;
        container.appendChild(box);
      });
      
      const last = digitHistory[0];
      if(last !== undefined) {
          const total = digitHistory.length;
          const count = digitHistory.filter(d => d === last).length;
          document.getElementById('matchCount').textContent = last;
          document.getElementById('totalCount').textContent = total;
          document.getElementById('matchPercent').textContent = ((count/total)*100).toFixed(1) + "%";
      }
    }
    
    return {
      init() {},
      processTick,
      resetForNewMarket: () => {
        digitHistory = [];
        transitionMatrix = Array(10).fill(0).map(() => Array(10).fill(0));
        totalTransitions = Array(10).fill(0);
        predictedDigit = null;
        predictionConfidence = 0;
        lastDigit = null;
        App.modules.AIEngine.reset();
        App.modules.UI.addLog("Memory wiped for new market", "warn");
      },
      getPrediction: () => {
        return { digit: predictedDigit, confidence: predictionConfidence };
      },
      getLastDigit: () => lastDigit,
      getData: () => ({ 
        transitionMatrix, 
        totalTransitions,
        aiData: App.modules.AIEngine.getData()
      }),
      setData: (data) => {
        if(data.transitionMatrix) transitionMatrix = data.transitionMatrix;
        if(data.totalTransitions) totalTransitions = data.totalTransitions;
        if(data.aiData) App.modules.AIEngine.setData(data.aiData);
      }
    };
  })();

  // ============ VIRTUAL TRADE MODULE ============
  App.modules.VirtualTrade = (function() {
    let isVirtualMode = false;
    let virtualStats = {
      totalTrades: 0,
      consecLosses: 0,
      profit: 0
    };
    let pendingVirtualTrade = null;
    
    function init() {
      document.getElementById('virtualTradeToggle').addEventListener('change', (e) => {
        const isEnabled = e.target.checked;
        if (isEnabled) {
          resetVirtualStats();
          App.modules.UI.addLog("Virtual Trade Mode ENABLED", "info");
          document.getElementById('virtualModeBadge').classList.add('active');
        } else {
          App.modules.UI.addLog("Virtual Trade Mode DISABLED", "warn");
          document.getElementById('virtualModeBadge').classList.remove('active');
        }
        App.modules.UI.saveSettings();
      });
      
      // Load saved virtual stats
      const saved = localStorage.getItem('virtual_stats_dm_pro');
      if (saved) {
        virtualStats = JSON.parse(saved);
        updateVirtualUI();
      }
    }
    
    function isEnabled() {
      return document.getElementById('virtualTradeToggle').checked;
    }
    
    function shouldSwitchToLive() {
      const threshold = parseInt(document.getElementById('virtualLossThreshold').value);
      return virtualStats.consecLosses >= threshold;
    }
    
    function queueVirtualTrade(targetDigit, confidence) {
      if (!isVirtualMode) {
        isVirtualMode = true;
      }
      
      // Store the pending trade
      pendingVirtualTrade = {
        targetDigit: targetDigit,
        confidence: confidence,
        timestamp: Date.now()
      };
      
      App.modules.UI.addLog(`[VIRTUAL] Trade queued: Digit ${targetDigit} (Prob: ${confidence.toFixed(1)}%)`, "info");
    }
    
    function processTickResult(actualDigit) {
      // Check if there's a pending virtual trade to process
      if (!pendingVirtualTrade) return;
      
      const trade = pendingVirtualTrade;
      pendingVirtualTrade = null; // Clear immediately to prevent duplicate processing
      
      virtualStats.totalTrades++;
      
      // Check if the trade won
      const isWin = (actualDigit === trade.targetDigit);
      const stake = parseFloat(document.getElementById('stake').value);
      const payout = isWin ? stake * 0.95 : -stake; // Approximate 95% payout
      
      virtualStats.profit += payout;
      
      if (isWin) {
        virtualStats.consecLosses = 0;
        App.modules.UI.addLog(`[VIRTUAL] WIN: Digit ${trade.targetDigit} matched ${actualDigit} ($${payout.toFixed(2)})`, "success");
      } else {
        virtualStats.consecLosses++;
        App.modules.UI.addLog(`[VIRTUAL] LOSS: Expected ${trade.targetDigit}, got ${actualDigit} ($${payout.toFixed(2)}) | Consecutive: ${virtualStats.consecLosses}`, "error");
      }
      
      // Add to history
      App.modules.UI.addToHistory(virtualStats.totalTrades, isWin ? 'Win' : 'Loss', payout, Config.currentMarketValue, true);
      
      updateVirtualUI();
      saveVirtualStats();
      
      // Check if should switch to live
      if (shouldSwitchToLive()) {
        switchToLiveMode();
      }
      
      return { isWin, payout };
    }
    
    function switchToLiveMode() {
      App.modules.UI.addLog(`ðŸ”´ SWITCHING TO LIVE MODE - ${virtualStats.consecLosses} consecutive losses reached!`, "warn");
      document.getElementById('virtualTradeToggle').checked = false;
      document.getElementById('virtualModeBadge').classList.remove('active');
      isVirtualMode = false;
      
      // Reset consecutive losses but keep total stats
      virtualStats.consecLosses = 0;
      updateVirtualUI();
      saveVirtualStats();
    }
    
    function updateVirtualUI() {
      document.getElementById('virtualConsecLosses').textContent = virtualStats.consecLosses;
      document.getElementById('virtualTotalTrades').textContent = virtualStats.totalTrades;
      const profitEl = document.getElementById('virtualProfit');
      profitEl.textContent = virtualStats.profit.toFixed(2);
      profitEl.style.color = virtualStats.profit > 0 ? '#22c55e' : (virtualStats.profit < 0 ? '#ef4444' : '#8b5cf6');
    }
    
    function saveVirtualStats() {
      localStorage.setItem('virtual_stats_dm_pro', JSON.stringify(virtualStats));
    }
    
    function resetVirtualStats() {
      virtualStats = {
        totalTrades: 0,
        consecLosses: 0,
        profit: 0
      };
      isVirtualMode = false;
      pendingVirtualTrade = null;
      updateVirtualUI();
      saveVirtualStats();
    }
    
    return {
      init,
      isEnabled,
      queueVirtualTrade,
      processTickResult,
      resetVirtualStats,
      getStats: () => virtualStats
    };
  })();

  // ============ TRADER MODULE ============
  App.modules.Trader = (function() {
    let isAutoRunning = false;
    let currentContractId = null;
    let stats = { trades: 0, wins: 0, losses: 0, profit: 0 };
    let lastTradeTime = 0;
    
    let isMarketCycleActive = false;
    let isCooldownLoopActive = false;
    let isCycleCooldown = false;
    let currentMarketIndex = 0;
    let cycleTimerId = null;
    
    // Accepts final target digit
    function placeTrade(targetDigit, conf, isVirtual = false) {
      if (!App.modules.Connection.isConnected() && !isVirtual) {
        App.modules.UI.addLog("Error: Not connected to Deriv", "error");
        return;
      }
      
      const stake = parseFloat(document.getElementById('stake').value);
      const duration = parseInt(document.getElementById('duration').value);
      const market = Config.currentMarketValue;
      
      // Validate inputs
      if (isNaN(stake) || stake < 0.35) {
        App.modules.UI.addLog("Error: Invalid stake amount", "error");
        return;
      }
      
      if (isNaN(targetDigit) || targetDigit < 0 || targetDigit > 9) {
        App.modules.UI.addLog("Error: Invalid target digit", "error");
        return;
      }
      
      if (isVirtual) {
        App.modules.UI.addLog(`[VIRTUAL] Buying Digit ${targetDigit} (AI Prob: ${conf.toFixed(1)}%)`, "info");
        App.modules.VirtualTrade.queueVirtualTrade(targetDigit, conf);
        return;
      }
      
      App.modules.UI.addLog(`[LIVE] Buying Digit ${targetDigit} (AI Prob: ${conf.toFixed(1)}%)`, "info");
      
      App.modules.Connection.sendAPIRequest({
        buy: 1,
        price: stake,
        parameters: { 
          contract_type: 'DIGITMATCH', 
          symbol: market, 
          duration: duration, 
          duration_unit: 't', 
          barrier: targetDigit.toString(),
          amount: stake, 
          basis: 'stake', 
          currency: 'USD' 
        }
      });
    }
    
    function checkAndAutoTrade(prediction) {
      // Skip if contract is pending
      if (currentContractId !== null) return;
      
      // Skip if prediction is not ready
      if (prediction.digit === null || prediction.digit === undefined) return; 
      
      const now = Date.now();
      const cooldownSec = parseFloat(document.getElementById('cooldown').value);
      
      // Check if in virtual mode
      const isVirtualEnabled = App.modules.VirtualTrade.isEnabled();
      
      // === EXCLUSIVE PREDICTION MAPPER LOGIC ===
      const isMapperOn = document.getElementById('mapperToggle').checked;
      const mapTrigger = document.getElementById('mapperTrigger').value;
      const mapTarget = document.getElementById('mapperTarget').value;
      
      let finalTarget = prediction.digit;
      let finalConfidence = prediction.confidence;
      
      if (isMapperOn && mapTrigger !== "" && mapTarget !== "") {
          const trigger = parseInt(mapTrigger);
          const target = parseInt(mapTarget);
        
        // Validate mapper inputs
          if (isNaN(trigger) || isNaN(target) || trigger < 0 || trigger > 9 || target < 0 || target > 9) {
            return;
          }
          
          if (prediction.digit === trigger) {
              finalTarget = target;
              App.modules.UI.addLog(`âš¡ Map Active: AI said ${trigger}, Trading ${target}`, "warn");
          } else {
              // Mapper is ON but prediction doesn't match trigger - skip this trade
              return; 
          }
      } else {
        // Manual digit override (if not using mapper)
        const manualDigit = parseInt(document.getElementById('manualDigit').value);
        if (!isNaN(manualDigit) && manualDigit !== 0 && prediction.digit !== manualDigit) {
          return;
        }
      }
      
      // Validate final target
      if (isNaN(finalTarget) || finalTarget < 0 || finalTarget > 9) {
        App.modules.UI.addLog("Error: Invalid final target digit", "error");
        return;
      }
      
      // Check confidence threshold
      const userMinConf = parseFloat(document.getElementById('minConfidence').value);
      if (finalConfidence < userMinConf) return;
      
      // Check cooldown - reduced from 150ms minimum for faster execution
      if (now - lastTradeTime < (cooldownSec * 1000)) return;
      
      lastTradeTime = now;
      
      // Route to virtual or live trade
      if (isVirtualEnabled) {
        placeTrade(finalTarget, finalConfidence, true);
      } else {
        placeTrade(finalTarget, finalConfidence, false);
      }
    }
    
    function handleTradeResult(contract) {
      const isWin = contract.status === 'won';
      const pl = parseFloat(contract.profit || 0);
      
      stats.trades++;
      if(isWin) stats.wins++; else stats.losses++;
      stats.profit += pl;
      
      App.modules.UI.addLog(`[LIVE] Result: ${isWin?'WIN':'LOSS'} ($${pl.toFixed(2)})`, isWin?'success':'error');
      App.modules.UI.updateStats(stats);
      App.modules.UI.addToHistory(stats.trades, isWin?'Win':'Loss', pl, Config.currentMarketValue, false);
      
      localStorage.setItem('trade_stats_dm_pro', JSON.stringify(stats));
      localStorage.setItem('trade_history_dm_pro', document.getElementById('history').innerHTML);
      
      checkTargets();
    }
    
    function checkTargets() {
      const tp = parseFloat(document.getElementById('takeprofit').value);
      const sl = parseFloat(document.getElementById('stoploss').value);
      
      if (stats.profit <= -sl) {
        toggleAuto(false);
        App.modules.UI.addLog("Stop Loss Hit.", "error");
        return;
      }
      
      if (stats.profit >= tp) {
        if (isMarketCycleActive) {
           advanceCycle();
        } else {
           toggleAuto(false);
           App.modules.UI.addLog("Take Profit Hit.", "success");
        }
      }
    }
    
    function advanceCycle() {
      if (currentMarketIndex < Config.marketSequence.length - 1) {
        currentMarketIndex++;
        const next = Config.marketSequence[currentMarketIndex];
        App.modules.UI.addLog(`Cycle Target Reached. Switching to ${next}`, "success");
        
        stats = { trades: 0, wins: 0, losses: 0, profit: 0 };
        App.modules.UI.updateStats(stats);
        
        App.modules.UI.selectMarket(next);
      } else {
        App.modules.UI.addLog("Full Market Cycle Complete.", "success");
        stats = { trades: 0, wins: 0, losses: 0, profit: 0 };
        App.modules.UI.updateStats(stats);
        
        if (isCooldownLoopActive) {
          startCycleCooldown();
        } else {
          toggleAuto(false);
          isMarketCycleActive = false;
          document.getElementById('cycleBtn').classList.remove('active');
          document.getElementById('cycleBtn').textContent = "Auto Market Cycle: OFF";
        }
      }
    }
    
    function startCycleCooldown() {
      isCycleCooldown = true;
      let min = parseInt(document.getElementById('cycleWaitTime').value);
      let sec = min * 60;
      const disp = document.getElementById('cycleTimerDisplay');
      disp.style.display = 'block';
      
      App.modules.UI.addLog(`Cycle cooldown active: waiting ${min}m...`, "warn");
      
      if (cycleTimerId) clearInterval(cycleTimerId);
      cycleTimerId = setInterval(() => {
        sec--;
        const m = Math.floor(sec/60);
        const s = sec%60;
        disp.textContent = `Next Loop in: ${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
        
        if (sec <= 0) {
          clearInterval(cycleTimerId);
          isCycleCooldown = false;
          currentMarketIndex = 0;
          disp.style.display = 'none';
          const nextMarket = Config.marketSequence[0];
          Config.currentMarketValue = nextMarket;
          App.modules.UI.selectMarket(nextMarket);
          document.getElementById('cycleBtn').textContent = `Auto Market Cycle: ON (${nextMarket})`;
          App.modules.UI.addLog(`Cooldown finished. Restarting cycle at ${nextMarket}.`, "success");
        }
      }, 1000);
    }
    
    function toggleAuto(forceState) {
      if (typeof forceState === 'boolean') isAutoRunning = forceState;
      else isAutoRunning = !isAutoRunning;
      
      const btn = document.getElementById('autoBtn');
      if (isAutoRunning) {
        localStorage.setItem('isAutoRunning', 'true');
        btn.textContent = "Stop Auto";
        btn.style.background = "#ef4444";
        
        const mode = App.modules.VirtualTrade.isEnabled() ? "VIRTUAL" : "LIVE";
        const model = Config.selectedAIModel.toUpperCase();
        App.modules.UI.addLog(`Auto-Trade Enabled in ${mode} mode using ${model}.`, "success");
      } else {
        localStorage.removeItem('isAutoRunning');
        btn.textContent = "Start Auto";
        btn.style.background = "#22c55e";
        App.modules.UI.addLog("Auto-Trade Stopped.", "warn");
      }
    }
    
    function toggleMarketCycle() {
      isMarketCycleActive = !isMarketCycleActive;
      const btn = document.getElementById('cycleBtn');
      if (isMarketCycleActive) {
        btn.classList.add('active');
        currentMarketIndex = Config.marketSequence.indexOf(Config.currentMarketValue);
        if(currentMarketIndex === -1) currentMarketIndex = 0;
        btn.textContent = `Auto Market Cycle: ON (${Config.marketSequence[currentMarketIndex]})`;
        App.modules.UI.addLog(`Market Cycle Started at ${Config.marketSequence[currentMarketIndex]}.`, "info");
      } else {
        btn.classList.remove('active');
        btn.textContent = "Auto Market Cycle: OFF";
        App.modules.UI.addLog(`Market Cycle Disabled.`, "warn");
      }
    }
    
    function toggleCooldownLoop() {
      isCooldownLoopActive = !isCooldownLoopActive;
      const btn = document.getElementById('cooldownBtn');
      if (isCooldownLoopActive) {
        btn.classList.add('active');
        btn.textContent = "Cycle Cooldown Loop: ON";
        App.modules.UI.addLog(`Cooldown Loop Enabled.`, "info");
      } else {
        btn.classList.remove('active');
        btn.textContent = "Cycle Cooldown Loop: OFF";
        App.modules.UI.addLog(`Cooldown Loop Disabled.`, "warn");
      }
    }
    
    function resetStats() {
      stats = { trades: 0, wins: 0, losses: 0, profit: 0 };
      App.modules.UI.updateStats(stats);
      document.getElementById('history').innerHTML = '';
      localStorage.removeItem('trade_stats_dm_pro');
      localStorage.removeItem('trade_history_dm_pro');
      
      // Also reset virtual stats
      App.modules.VirtualTrade.resetVirtualStats();
      
      App.modules.UI.addLog("All stats reset.", "info");
    }
    
    return {
      init() {
        document.getElementById('autoBtn').addEventListener('click', () => toggleAuto());
        document.getElementById('manualBtn').addEventListener('click', () => {
            const pred = App.modules.Analyzer.getPrediction();
            if(pred.digit !== null && pred.digit !== undefined) {
              const isVirtual = App.modules.VirtualTrade.isEnabled();
              placeTrade(pred.digit, pred.confidence, isVirtual);
            } else {
              App.modules.UI.addLog("No prediction available yet", "warn");
            }
        });
        document.getElementById('cycleBtn').addEventListener('click', toggleMarketCycle);
        document.getElementById('cooldownBtn').addEventListener('click', toggleCooldownLoop);
        document.getElementById('resetBtn').addEventListener('click', resetStats);
        
        const s = localStorage.getItem('trade_stats_dm_pro');
        if(s) { stats = JSON.parse(s); App.modules.UI.updateStats(stats); }
      },
      checkAndAutoTrade,
      setContractId: (id) => currentContractId = id,
      handleTradeResult,
      getAutoRunning: () => isAutoRunning,
      getCycleCooldown: () => isCycleCooldown,
      resumeAutoTrade: () => toggleAuto(true)
    };
  })();

  // ============ UI MODULE ============
  App.modules.UI = (function() {
    let sessionStartTime = null;
    let timerIntervalId = null;
    
    function init() {
      document.querySelectorAll('#marketRadios .radio-option').forEach(opt => {
        opt.addEventListener('click', (e) => {
          const m = e.currentTarget.dataset.market;
          selectMarket(m);
        });
      });
      
      document.querySelectorAll('.save-setting').forEach(el => {
        el.addEventListener('change', saveSettings);
        el.addEventListener('input', saveSettings);
      });
      
      document.getElementById('clearLog').addEventListener('click', () => {
         document.getElementById('logContainer').innerHTML = '';
      });
    }
    
    function addLog(msg, type = 'info') {
      const container = document.getElementById('logContainer');
      const time = new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `<span class="log-time">[${time}]</span> <span class="log-msg-${type}">${msg}</span>`;
      container.appendChild(entry);
      container.scrollTop = container.scrollHeight;
    }
    
    function updateStatus(text, className) { 
      const s = document.getElementById('status'); 
      s.textContent = text; 
      s.className = 'status ' + className; 
    }
    
    function updateBalance() { 
      document.getElementById('balanceDisplay').style.display = 'block'; 
      document.getElementById('balance').textContent = parseFloat(Config.accountBalance).toFixed(2); 
    }
    
    function updateStats(stats) {
      document.getElementById('trades').textContent = stats.trades;
      document.getElementById('wins').textContent = stats.wins;
      document.getElementById('losses').textContent = stats.losses;
      const p = document.getElementById('profit');
      p.textContent = stats.profit.toFixed(2);
      p.style.color = stats.profit > 0 ? '#22c55e' : (stats.profit < 0 ? '#ef4444' : '#e5e7eb');
    }
    
    function startSessionTimer() {
      if (timerIntervalId) clearInterval(timerIntervalId);
      sessionStartTime = Date.now(); 
      timerIntervalId = setInterval(() => {
        const now = Date.now();
        const s = Math.floor((now - sessionStartTime) / 1000);
        document.getElementById('sessionTimer').textContent = `Session: ${Math.floor(s/3600).toString().padStart(2,'0')}:${Math.floor((s%3600)/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`;
      }, 1000);
    }
    
    function addToHistory(n, res, pl, m, isVirtual = false) {
      const row = document.getElementById('history').insertRow(0);
      const cls = res === 'Win' ? 'win' : 'loss';
      const mode = isVirtual ? 'Virtual' : 'Live';
      row.innerHTML = `<td>${n}</td><td style="color: ${isVirtual ? '#8b5cf6' : '#22c55e'}">${mode}</td><td class="${cls}">${res}</td><td class="${cls}">${pl.toFixed(2)}</td><td>${m}</td>`;
    }
    
    function updatePredictionDisplay(digit, conf) {
      const box = document.getElementById('predictionDisplay');
      const bar = document.getElementById('confidenceBar');
      
      const visualPercent = Math.min(100, (conf / 25) * 100);
      bar.style.width = visualPercent + '%';
      
      if (digit !== null && digit !== undefined) {
        const color = conf > 18 ? '#22c55e' : (conf > 14 ? '#f59e0b' : '#94a3b8');
        box.innerHTML = `<span class="prediction-ready" style="color:${color}">DIGIT ${digit}</span>`;
      } else {
        box.innerHTML = `<span class="prediction-waiting">WAITING...</span>`;
      }
    }
    
    function saveSettings() {
      const set = {
        analyzer: App.modules.Analyzer.getData(),
        market: Config.currentMarketValue,
        mapperToggle: document.getElementById('mapperToggle').checked,
        virtualTradeToggle: document.getElementById('virtualTradeToggle').checked,
        selectedAIModel: Config.selectedAIModel
      };
      document.querySelectorAll('.save-setting').forEach(el => {
        if(el.type !== 'checkbox') set[el.id] = el.value;
      });
      localStorage.setItem('settings_dm_pro', JSON.stringify(set));
    }
    
    function loadSettings() {
      const s = localStorage.getItem('settings_dm_pro');
      if(s) {
        const set = JSON.parse(s);
        for(let k in set) {
          const el = document.getElementById(k);
          if(el && el.type !== 'checkbox') el.value = set[k];
        }
        
        if(set.mapperToggle) document.getElementById('mapperToggle').checked = set.mapperToggle;
        if(set.virtualTradeToggle) {
          document.getElementById('virtualTradeToggle').checked = set.virtualTradeToggle;
          if(set.virtualTradeToggle) {
            document.getElementById('virtualModeBadge').classList.add('active');
          }
        }
        
        if(set.analyzer) App.modules.Analyzer.setData(set.analyzer);
        if(set.market) {
          Config.currentMarketValue = set.market;
          selectMarket(set.market);
        }
        
        if(set.selectedAIModel) {
          // Defer AI model selection until after AIEngine is initialized
          setTimeout(() => {
            const modelRadio = document.querySelector(`input[name="aiModel"][value="${set.selectedAIModel}"]`);
            if (modelRadio) {
              modelRadio.click();
            }
          }, 100);
        }
      }
      
      const h = localStorage.getItem('trade_history_dm_pro');
      if(h) document.getElementById('history').innerHTML = h;
    }
    
    function selectMarket(m) {
      Config.currentMarketValue = m;
      document.querySelectorAll('.radio-option').forEach(el => {
        el.classList.toggle('selected', el.dataset.market === m);
      });
      const radioEl = document.getElementById('market'+m.replace('_',''));
      if(radioEl) radioEl.checked = true;
      
      if (App.modules.Connection.isConnected()) {
        App.modules.Connection.subscribeToTicks();
      }
      saveSettings();
    }
    
    return {
      init,
      addLog,
      updateStatus,
      updateBalance,
      updateStats,
      startSessionTimer,
      addToHistory,
      updatePredictionDisplay,
      saveSettings,
      loadSettings,
      selectMarket
    };
  })();

  // ============ INITIALIZE APP ============
  window.addEventListener('DOMContentLoaded', () => {
    App.init();
  });

})();
</script>
</body>
</html>