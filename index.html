<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ben Sniper - Deriv Trading Bot</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 10px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: linear-gradient(135deg, #1e2749 0%, #2d3561 100%);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .connection-badge {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            border: 2px solid;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            transition: all 0.3s ease;
        }

        .connection-badge.connected {
            border-color: #2ecc71;
            color: #2ecc71;
        }

        .connection-badge.disconnected {
            border-color: #ff4757;
            color: #ff4757;
        }

        .connection-badge.reconnecting {
            border-color: #f39c12;
            color: #f39c12;
        }

        .connection-badge-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: badge-pulse 2s infinite;
        }

        .connection-badge.connected .connection-badge-dot {
            background-color: #2ecc71;
        }

        .connection-badge.disconnected .connection-badge-dot {
            background-color: #ff4757;
        }

        .connection-badge.reconnecting .connection-badge-dot {
            background-color: #f39c12;
        }

        @keyframes badge-pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.6;
                transform: scale(1.2);
            }
        }

        .header h1 {
            color: #00d4ff;
            font-size: 28px;
            margin-bottom: 15px;
            text-align: center;
            padding-right: 150px;
        }

        .login-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        .login-input-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .login-input {
            flex: 1;
            min-width: 200px;
            padding: 12px;
            background: #2a3250;
            border: 2px solid #3d4663;
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .login-input:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            color: #0a0e27;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff4757 0%, #cc3544 100%);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 71, 87, 0.4);
        }

        .btn-danger.confirm-state {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            animation: pulse-warning 1s infinite;
        }

        @keyframes pulse-warning {
            0%, 100% {
                box-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
            }
            50% {
                box-shadow: 0 0 20px rgba(231, 76, 60, 0.8);
            }
        }

        .btn-success {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.4);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            color: white;
        }

        .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.4);
        }

        .btn-info {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .btn-info:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .account-info {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 10px;
            padding: 15px;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 5px;
            margin-top: 10px;
        }

        .info-item {
            text-align: center;
        }

        .info-label {
            font-size: 11px;
            color: #8899aa;
            text-transform: uppercase;
        }

        .info-value {
            font-size: 16px;
            font-weight: 700;
            color: #00d4ff;
            margin-top: 5px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: #1e2749;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .panel-title {
            color: #00d4ff;
            font-size: 18px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3d4663;
        }

        .markets-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .market-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #2a3250;
            border-radius: 5px;
            border: 1px solid #3d4663;
            position: relative;
        }

        .market-name {
            font-size: 13px;
            color: #e0e0e0;
            flex: 1;
        }

        .market-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .subscription-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #3d4663;
            transition: all 0.3s ease;
        }

        .subscription-indicator.subscribing {
            background-color: #f1c40f;
            box-shadow: 0 0 10px rgba(241, 196, 15, 0.6);
            animation: pulse-yellow 1s infinite;
        }

        .subscription-indicator.subscribed {
            background-color: #2ecc71;
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.6);
            animation: glow 2s infinite;
        }

        @keyframes pulse-yellow {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.6;
                transform: scale(1.2);
            }
        }

        @keyframes glow {
            0%, 100% {
                box-shadow: 0 0 5px rgba(46, 204, 113, 0.6);
            }
            50% {
                box-shadow: 0 0 15px rgba(46, 204, 113, 0.9);
            }
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #3d4663;
            transition: 0.3s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #00d4ff;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .filter-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 15px;
        }

        .filter-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #2a3250;
            border-radius: 5px;
            border: 1px solid #3d4663;
        }

        .filter-label {
            font-size: 14px;
            color: #e0e0e0;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-label {
            font-size: 12px;
            color: #8899aa;
            text-transform: uppercase;
        }

        .input-field {
            padding: 10px;
            background: #2a3250;
            border: 2px solid #3d4663;
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .input-field:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .select-field {
            padding: 10px;
            background: #2a3250;
            border: 2px solid #3d4663;
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 14px;
            cursor: pointer;
        }

        .select-field:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .radio-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 8px 12px;
            background: #2a3250;
            border: 2px solid #3d4663;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .radio-option:hover {
            border-color: #00d4ff;
            background: #323d5a;
        }

        .radio-option input[type="radio"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #00d4ff;
        }

        .radio-option label {
            font-size: 13px;
            color: #e0e0e0;
            cursor: pointer;
            user-select: none;
        }

        .radio-option input[type="radio"]:checked + label {
            color: #00d4ff;
            font-weight: 600;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .control-buttons .btn {
            flex: 1;
            min-width: 120px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-card {
            background: #2a3250;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            border: 1px solid #3d4663;
        }

        .stat-label {
            font-size: 11px;
            color: #8899aa;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #00d4ff;
        }

        .stat-value.profit {
            color: #2ecc71;
        }

        .stat-value.loss {
            color: #ff4757;
        }

        .signal-monitor {
            background: #1e2749;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
        }

        .monitor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 15px;
            background: #2a3250;
            border-radius: 20px;
        }

        .pulse-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #ff4757;
            animation: pulse 2s infinite;
        }

        .pulse-dot.active {
            background-color: #2ecc71;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.5;
                transform: scale(1.1);
            }
        }

        .status-text {
            font-size: 13px;
            color: #ff4757;
            font-weight: 600;
        }

        .status-text.active {
            color: #2ecc71;
        }

        .signals-container {
            max-height: 300px;
            overflow-y: auto;
            background: #0a0e27;
            padding: 15px;
            border-radius: 5px;
        }

        .signals-container::-webkit-scrollbar {
            width: 8px;
        }

        .signals-container::-webkit-scrollbar-track {
            background: #1e2749;
            border-radius: 10px;
        }

        .signals-container::-webkit-scrollbar-thumb {
            background: #00d4ff;
            border-radius: 10px;
        }

        .signal-item {
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 5px;
            border-left: 4px solid #3d4663;
            background: #1e2749;
            transition: all 0.3s ease;
        }

        .signal-item.win {
            border-left-color: #2ecc71;
            background: rgba(46, 204, 113, 0.1);
        }

        .signal-item.loss {
            border-left-color: #ff4757;
            background: rgba(255, 71, 87, 0.1);
        }

        .signal-item.skipped {
            border-left-color: #f39c12;
            background: rgba(243, 156, 18, 0.1);
        }

        .signal-text {
            font-size: 13px;
            color: #e0e0e0;
        }

        .trade-history {
            background: #1e2749;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
        }

        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .history-table {
            width: 100%;
            border-collapse: collapse;
            background: #0a0e27;
            border-radius: 5px;
            overflow: hidden;
        }

        .history-table thead {
            background: #2a3250;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .history-table th {
            padding: 12px;
            text-align: left;
            font-size: 12px;
            color: #8899aa;
            text-transform: uppercase;
            font-weight: 600;
        }

        .history-table td {
            padding: 12px;
            border-top: 1px solid #1e2749;
            font-size: 13px;
            color: #e0e0e0;
        }

        .history-table-container {
            max-height: 500px;
            overflow-y: auto;
            overflow-x: auto;
            border-radius: 5px;
        }

        .history-table-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .history-table-container::-webkit-scrollbar-track {
            background: #1e2749;
            border-radius: 10px;
        }

        .history-table-container::-webkit-scrollbar-thumb {
            background: #00d4ff;
            border-radius: 10px;
        }

        .history-table-container::-webkit-scrollbar-thumb:hover {
            background: #0099cc;
        }

        .result-win {
            color: #2ecc71;
            font-weight: 600;
        }

        .result-loss {
            color: #ff4757;
            font-weight: 600;
        }

        .activities-log {
            background: #1e2749;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .log-container {
            max-height: 300px;
            overflow-y: auto;
            background: #0a0e27;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }

        .log-container::-webkit-scrollbar {
            width: 8px;
        }

        .log-container::-webkit-scrollbar-track {
            background: #1e2749;
            border-radius: 10px;
        }

        .log-container::-webkit-scrollbar-thumb {
            background: #00d4ff;
            border-radius: 10px;
        }

        .log-entry {
            font-size: 12px;
            color: #8899aa;
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .log-entry .timestamp {
            color: #00d4ff;
            margin-right: 10px;
        }

        .log-entry.error {
            color: #ff4757;
        }

        .log-entry.success {
            color: #2ecc71;
        }

        .log-entry.warning {
            color: #f39c12;
        }

        .reverse-mode-badge {
            display: inline-block;
            padding: 4px 10px;
            background: rgba(243, 156, 18, 0.2);
            border: 1px solid #f39c12;
            border-radius: 4px;
            color: #f39c12;
            font-size: 11px;
            font-weight: 600;
            margin-left: 10px;
        }

        .one-candle-badge {
            display: inline-block;
            padding: 4px 10px;
            background: rgba(155, 89, 182, 0.2);
            border: 1px solid #9b59b6;
            border-radius: 4px;
            color: #9b59b6;
            font-size: 11px;
            font-weight: 600;
            margin-left: 10px;
        }

        .alternator-mode-badge {
            display: inline-block;
            padding: 4px 10px;
            background: rgba(52, 152, 219, 0.2);
            border: 1px solid #3498db;
            border-radius: 4px;
            color: #3498db;
            font-size: 11px;
            font-weight: 600;
            margin-left: 10px;
        }

        .conflict-alert {
            background: rgba(243, 156, 18, 0.15);
            border: 2px solid #f39c12;
            border-radius: 5px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }

        .conflict-alert.active {
            display: block;
            animation: conflict-pulse 2s infinite;
        }

        @keyframes conflict-pulse {
            0%, 100% {
                background: rgba(243, 156, 18, 0.15);
            }
            50% {
                background: rgba(243, 156, 18, 0.25);
            }
        }

        .conflict-title {
            color: #f39c12;
            font-weight: 700;
            font-size: 14px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .conflict-list {
            color: #e0e0e0;
            font-size: 12px;
            line-height: 1.6;
            margin-left: 24px;
        }

        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 22px;
                padding-right: 0;
                margin-top: 40px;
            }

            .connection-badge {
                top: 10px;
                right: 10px;
                font-size: 10px;
                padding: 6px 12px;
            }

            .markets-grid {
                grid-template-columns: 1fr;
            }

            .settings-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .control-buttons {
                flex-direction: column;
            }

            .control-buttons .btn {
                width: 100%;
            }

            .history-table {
                font-size: 11px;
            }

            .history-table th,
            .history-table td {
                padding: 8px 5px;
            }

            .radio-group {
                flex-direction: column;
                gap: 10px;
            }

            .radio-option {
                width: 100%;
            }
        }

        .timer-display {
            text-align: center;
            padding: 10px;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 5px;
            margin-top: 10px;
        }

        .timer-label {
            font-size: 11px;
            color: #8899aa;
            text-transform: uppercase;
        }

        .timer-value {
            font-size: 20px;
            font-weight: 700;
            color: #00d4ff;
            margin-top: 5px;
            font-family: 'Courier New', monospace;
        }

        .hidden {
            display: none;
        }

        .candle-counter {
            font-size: 13px;
            color: #f1c40f;
            font-weight: 600;
            margin-top: 10px;
            text-align: center;
            padding: 8px;
            background: rgba(241, 196, 15, 0.1);
            border-radius: 5px;
        }

        .trade-count-display {
            text-align: center;
            font-size: 12px;
            color: #8899aa;
            margin-top: 10px;
            padding: 8px;
            background: rgba(0, 212, 255, 0.05);
            border-radius: 5px;
        }

        .refresh-indicator {
            text-align: center;
            font-size: 11px;
            color: #9b59b6;
            margin-top: 5px;
            padding: 6px;
            background: rgba(155, 89, 182, 0.1);
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <!-- Connection Badge -->
            <div class="connection-badge disconnected" id="connectionBadge">
                <div class="connection-badge-dot"></div>
                <span id="connectionStatus">Disconnected</span>
            </div>

            <h1>‚ö° BEN SNIPER - Deriv Trading Bot</h1>
            
            <div class="login-section" id="loginSection">
                <div class="login-input-group">
                    <input type="password" class="login-input" id="apiToken" placeholder="Enter Deriv API Token">
                    <button class="btn btn-primary" id="loginBtn">Login</button>
                </div>
            </div>

            <div class="account-info hidden" id="accountInfo">
                <div class="info-item">
                    <div class="info-label">Account Type</div>
                    <div class="info-value" id="accountType">-</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Currency</div>
                    <div class="info-value" id="accountCurrency">-</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Balance</div>
                    <div class="info-value" id="accountBalance">-</div>
                </div>
                <div class="info-item">
                    <button class="btn btn-danger" id="logoutBtn">Logout</button>
                </div>
            </div>

            <div class="timer-display hidden" id="timerDisplay">
                <div class="timer-label">Session Time</div>
                <div class="timer-value" id="timerValue">00:00:00</div>
            </div>
            
            <div class="refresh-indicator hidden" id="refreshIndicator">
                Next refresh in: <span id="refreshTimer">--:--:--</span>
            </div>
        </div>

        <div class="signal-monitor">
            <div class="monitor-header">
                <h2 class="panel-title">üìä Signal Monitor<span id="reverseModeIndicator" class="reverse-mode-badge hidden">REVERSE MODE</span><span id="oneCandleIndicator" class="one-candle-badge hidden">ONE CANDLE</span><span id="alternatorModeIndicator" class="alternator-mode-badge hidden">ALTERNATOR</span></h2>
                <div class="status-indicator">
                    <div class="pulse-dot" id="statusDot"></div>
                    <span class="status-text" id="statusText">Bot Inactive</span>
                </div>
            </div>
            <div id="candleCounter" class="candle-counter hidden">Building candles: 0 / 0 required</div>
            <div class="signals-container" id="signalsContainer">
                <div class="signal-item">
                    <div class="signal-text">Waiting for bot activation...</div>
                </div>
            </div>
        </div>

        <div class="main-grid">
            <div class="panel">
                <h2 class="panel-title">üéØ Market Selection</h2>
                <div class="markets-grid" id="marketsGrid"></div>
            </div>

            <div class="panel">
                <h2 class="panel-title">üîß Filters</h2>
                <div class="filter-section">
                    <div class="filter-item">
                        <span class="filter-label">Zero Closing Filter(Perfect 0)</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="zeroClosingFilter">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <span class="filter-label">Ignore Height</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="ignoreHeightFilter">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <span class="filter-label">One Candle (Single Candle Analysis)</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="oneCandleFilter">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <span class="filter-label">Reverse Candle</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="reverseCandleFilter">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <span class="filter-label">Auto Refresh Browser</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="autoRefreshFilter">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>

                <!-- Conflict Alert Box -->
                <div class="conflict-alert" id="conflictAlert">
                    <div class="conflict-title">
                        ‚ö†Ô∏è Filter Conflict Detected
                    </div>
                    <div class="conflict-list" id="conflictList"></div>
                </div>

                <h2 class="panel-title" style="margin-top: 20px;">‚öôÔ∏è Trade Settings</h2>
                <div class="settings-grid">
                    <div class="input-group">
                        <label class="input-label">Stake Amount</label>
                        <input type="number" class="input-field" id="stakeAmount" value="1" min="0.35" step="0.01">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Stop Loss</label>
                        <input type="number" class="input-field" id="stopLoss" value="10" min="0" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Take Profit</label>
                        <input type="number" class="input-field" id="takeProfit" value="20" min="0" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Duration Type</label>
                        <div class="radio-group">
                            <div class="radio-option">
                                <input type="radio" id="durationTypeTicks" name="durationType" value="t" checked>
                                <label for="durationTypeTicks">Ticks</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="durationTypeSeconds" name="durationType" value="s">
                                <label for="durationTypeSeconds">Seconds</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="durationTypeMinutes" name="durationType" value="m">
                                <label for="durationTypeMinutes">Minutes</label>
                            </div>
                        </div>
                    </div>
                    <div class="input-group">
                        <label class="input-label">Duration Value</label>
                        <input type="number" class="input-field" id="durationValue" value="5" min="1" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Min Lower Wick % (Buy)</label>
                        <input type="number" class="input-field" id="minLowerWickBuy" value="50" min="0" max="100" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Min Upper Wick % (Sell)</label>
                        <input type="number" class="input-field" id="minUpperWickSell" value="50" min="0" max="100" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Min Upper Wick % (Buy)</label>
                        <input type="number" class="input-field" id="minUpperWickBuy" value="20" min="0" max="100" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Min Lower Wick % (Sell)</label>
                        <input type="number" class="input-field" id="minLowerWickSell" value="20" min="0" max="100" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Matching Diff % (Buy)</label>
                        <input type="number" class="input-field" id="matchingDiffBuy" value="0.3" min="0" max="5" step="0.1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Matching Diff % (Sell)</label>
                        <input type="number" class="input-field" id="matchingDiffSell" value="0.3" min="0" max="5" step="0.1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Auto Refresh (Hours)</label>
                        <input type="number" class="input-field" id="refreshInterval" value="1" min="0.1" max="24" step="0.1">
                    </div>
                </div>

                <div class="control-buttons">
                    <button class="btn btn-success" id="autoTradeBtn" disabled>Start Auto Trade</button>
                    <button class="btn btn-warning" id="reverseModeBtn" disabled>Reverse Mode: OFF</button>
                    <button class="btn btn-info" id="alternatorModeBtn" disabled>Alternator: OFF</button>
                </div>
            </div>
        </div>

        <div class="panel">
            <h2 class="panel-title">üìà Trading Statistics</h2>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Total Trades</div>
                    <div class="stat-value" id="totalTrades">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Wins</div>
                    <div class="stat-value profit" id="totalWins">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Losses</div>
                    <div class="stat-value loss" id="totalLosses">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Skipped</div>
                    <div class="stat-value" id="totalSkipped">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">P/L</div>
                    <div class="stat-value" id="profitLoss">0.00</div>
                </div>
            </div>
        </div>

        <div class="trade-history">
            <div class="history-header">
                <h2 class="panel-title">üìã Trade History</h2>
                <button class="btn btn-danger" id="clearHistoryBtn">Clear History</button>
            </div>
            <div class="trade-count-display" id="tradeCountDisplay">Showing 0 of 0 trades</div>
            <div class="history-table-container">
                <table class="history-table">
                    <thead>
                        <tr>
                            <th>S/N</th>
                            <th>Time</th>
                            <th>Market</th>
                            <th>Type</th>
                            <th>Stake</th>
                            <th>Result</th>
                        </tr>
                    </thead>
                    <tbody id="historyTableBody">
                        <tr>
                            <td colspan="6" style="text-align: center; color: #8899aa;">No trades yet</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="activities-log">
            <h2 class="panel-title">üìù Activity Log</h2>
            <div class="log-container" id="logContainer">
                <div class="log-entry">
                    <span class="timestamp">[--:--:--]</span> System initialized. Waiting for login...
                </div>
            </div>
        </div>
    </div>

    <script>
        // Market definitions
        const markets = {
            '1HZ10V': 'Volatility 10 (1s)',
            '1HZ25V': 'Volatility 25 (1s)',
            '1HZ50V': 'Volatility 50 (1s)',
            '1HZ75V': 'Volatility 75 (1s)',
            '1HZ100V': 'Volatility 100 (1s)',
            'R_10': 'Volatility 10',
            'R_25': 'Volatility 25',
            'R_50': 'Volatility 50',
            'R_75': 'Volatility 75',
            'R_100': 'Volatility 100',
            'stpRNG': 'Step Index 100',
            'stpRNG2': 'Step Index 200',
            'stpRNG3': 'Step Index 300',
            'stpRNG4': 'Step Index 400',
            'stpRNG5': 'Step Index 500'
        };

        // Global state
        let ws = null;
        let isLoggedIn = false;
        let isAutoTrading = false;
        let isReverseMode = false;
        let isAlternatorMode = false;
        let activation_time = 0;
        let activeMarkets = {};
        let marketSubscriptions = {};
        let pendingSubscriptions = {};
        let candleData = {};
        let currentOHLC = {};
        let currentMinute = {};
        let tradeHistory = [];
        let sessionTimer = null;
        let sessionStartTime = null;
        let accountInfo = {};
        let tradeStats = {
            total: 0,
            wins: 0,
            losses: 0,
            skipped: 0,
            profitLoss: 0
        };
        let pendingTrades = new Map();
        let isFirstSignal = true;
        let lastHeartbeat = Date.now();
        let tradedCandles = {};
        let requestIdCounter = 0;
        let pendingProposals = new Map();
        let processedContracts = new Set();
        
        // ALTERNATOR MODE: Track next trade type for each market separately
        let marketAlternatorState = {};
        
        // Time synchronization variables
        let serverTimeOffset = 0;
        let isTimeSynced = false;
        let candleWatchdogTimer = null;
        
        // Browser visibility tracking
        let isPageVisible = true;
        let lastVisibilityChange = Date.now();
        
        // Candle processing throttle - FLOATING BROWSER FIX
        let lastCandleProcessTime = {};
        let isProcessingTicks = false;

        // Auto-reconnect variables
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 10;
        let reconnectTimeout = null;
        let wasAutoTradingBeforeDisconnect = false;

        // Auto-refresh variables
        let autoRefreshTimer = null;
        let refreshCountdownTimer = null;
        let nextRefreshTime = null;

        // Clear history double-tap state
        let clearHistoryConfirmState = false;
        let clearHistoryTimeout = null;

        // Initialize markets and alternator state
        Object.keys(markets).forEach(symbol => {
            activeMarkets[symbol] = true;
            candleData[symbol] = [];
            currentOHLC[symbol] = undefined;
            currentMinute[symbol] = undefined;
            tradedCandles[symbol] = new Set();
            marketAlternatorState[symbol] = 'CALL'; // Start with CALL for each market
        });

        // Update connection badge
        function updateConnectionBadge(status) {
            const badge = document.getElementById('connectionBadge');
            const statusText = document.getElementById('connectionStatus');
            
            badge.className = 'connection-badge ' + status;
            
            if (status === 'connected') {
                statusText.textContent = 'Connected';
            } else if (status === 'disconnected') {
                statusText.textContent = 'Disconnected';
            } else if (status === 'reconnecting') {
                statusText.textContent = 'Reconnecting...';
            }
        }

        // Update subscription indicator for a specific market
        function updateSubscriptionIndicator(symbol, state) {
            const indicator = document.querySelector(`[data-indicator="${symbol}"]`);
            if (indicator) {
                indicator.className = 'subscription-indicator';
                if (state === 'subscribing') {
                    indicator.classList.add('subscribing');
                } else if (state === 'subscribed') {
                    indicator.classList.add('subscribed');
                }
            }
        }

        // Update reverse mode indicator
        function updateReverseModeIndicator() {
            const indicator = document.getElementById('reverseModeIndicator');
            if (isReverseMode) {
                indicator.classList.remove('hidden');
            } else {
                indicator.classList.add('hidden');
            }
        }

        // Update alternator mode indicator
        function updateAlternatorModeIndicator() {
            const indicator = document.getElementById('alternatorModeIndicator');
            if (isAlternatorMode) {
                indicator.classList.remove('hidden');
            } else {
                indicator.classList.add('hidden');
            }
        }

        // Update one candle mode indicator
        function updateOneCandleIndicator() {
            const indicator = document.getElementById('oneCandleIndicator');
            const oneCandleEnabled = document.getElementById('oneCandleFilter').checked;
            if (oneCandleEnabled) {
                indicator.classList.remove('hidden');
            } else {
                indicator.classList.add('hidden');
            }
        }

        // Check for filter conflicts
        function checkFilterConflicts() {
            const ignoreHeight = document.getElementById('ignoreHeightFilter').checked;
            const oneCandle = document.getElementById('oneCandleFilter').checked;
            const conflictAlert = document.getElementById('conflictAlert');
            const conflictList = document.getElementById('conflictList');
            
            const conflicts = [];
            
            if (ignoreHeight && oneCandle) {
                conflicts.push('‚Ä¢ "Ignore Height" and "One Candle" are both enabled. These filters work together:<br>&nbsp;&nbsp;- One Candle: Uses only first candle for analysis (no second candle needed)<br>&nbsp;&nbsp;- Ignore Height: Allows the single candle to be any height<br>&nbsp;&nbsp;‚Üí Both filters will be applied for maximum flexibility');
            }

            if (isReverseMode && isAlternatorMode) {
                conflicts.push('‚Ä¢ "Reverse Mode" and "Alternator Mode" are both enabled:<br>&nbsp;&nbsp;- Alternator enforces BUY-SELL-BUY pattern per market<br>&nbsp;&nbsp;- Reverse Mode inverts signals<br>&nbsp;&nbsp;‚Üí Combined effect: Alternator operates on reversed signals');
            }
            
            if (conflicts.length > 0) {
                conflictList.innerHTML = conflicts.join('<br><br>');
                conflictAlert.classList.add('active');
            } else {
                conflictAlert.classList.remove('active');
            }
        }

        // Update candle counter
        function updateCandleCounter() {
            if (!isAutoTrading) {
                document.getElementById('candleCounter').classList.add('hidden');
                return;
            }

            const oneCandleFilter = document.getElementById('oneCandleFilter').checked;
            
            let requiredCandles = oneCandleFilter ? 1 : 3;
            
            let minCandles = Infinity;
            let activeCount = 0;
            
            Object.keys(activeMarkets).forEach(symbol => {
                if (activeMarkets[symbol] && marketSubscriptions[symbol]) {
                    activeCount++;
                    const count = candleData[symbol].length;
                    if (count < minCandles) {
                        minCandles = count;
                    }
                }
            });

            if (activeCount === 0) {
                document.getElementById('candleCounter').classList.add('hidden');
                return;
            }

            if (minCandles === Infinity) minCandles = 0;

            const counterElement = document.getElementById('candleCounter');
            
            if (minCandles >= requiredCandles) {
                const mode = oneCandleFilter ? 'ONE CANDLE MODE' : 'TWO CANDLE MODE';
                counterElement.textContent = `‚úì Ready to analyze [${mode}] - All markets have ${requiredCandles}+ candles`;
                counterElement.style.color = '#2ecc71';
                counterElement.style.background = 'rgba(46, 204, 113, 0.1)';
            } else {
                counterElement.textContent = `Building candles: ${minCandles} / ${requiredCandles} required (${requiredCandles - minCandles} more needed)`;
                counterElement.style.color = '#f1c40f';
                counterElement.style.background = 'rgba(241, 196, 15, 0.1)';
            }
            
            counterElement.classList.remove('hidden');
        }

        // Update trade count display
        function updateTradeCountDisplay() {
            const totalTrades = tradeHistory.length;
            const displayElement = document.getElementById('tradeCountDisplay');
            
            if (totalTrades === 0) {
                displayElement.textContent = 'No trades yet';
            } else if (totalTrades <= 100) {
                displayElement.textContent = `Showing all ${totalTrades} trade${totalTrades === 1 ? '' : 's'}`;
            } else {
                displayElement.textContent = `Showing latest 100 of ${totalTrades} total trades`;
            }
        }

        // Auto-refresh functions
        function startAutoRefresh() {
            const refreshInterval = parseFloat(document.getElementById('refreshInterval').value);
            const intervalMs = refreshInterval * 60 * 60 * 1000;
            
            nextRefreshTime = Date.now() + intervalMs;
            
            if (autoRefreshTimer) clearTimeout(autoRefreshTimer);
            autoRefreshTimer = setTimeout(() => {
                performAutoRefresh();
            }, intervalMs);
            
            if (refreshCountdownTimer) clearInterval(refreshCountdownTimer);
            refreshCountdownTimer = setInterval(updateRefreshCountdown, 1000);
            
            document.getElementById('refreshIndicator').classList.remove('hidden');
            logActivity(`Auto-refresh enabled: Browser will refresh every ${refreshInterval} hour(s)`, 'success');
        }

        function stopAutoRefresh() {
            if (autoRefreshTimer) {
                clearTimeout(autoRefreshTimer);
                autoRefreshTimer = null;
            }
            if (refreshCountdownTimer) {
                clearInterval(refreshCountdownTimer);
                refreshCountdownTimer = null;
            }
            nextRefreshTime = null;
            document.getElementById('refreshIndicator').classList.add('hidden');
            logActivity('Auto-refresh disabled', 'info');
        }

        function updateRefreshCountdown() {
            if (!nextRefreshTime) return;
            
            const remaining = nextRefreshTime - Date.now();
            if (remaining <= 0) {
                document.getElementById('refreshTimer').textContent = '00:00:00';
                return;
            }
            
            const hours = Math.floor(remaining / 3600000);
            const minutes = Math.floor((remaining % 3600000) / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            
            document.getElementById('refreshTimer').textContent = 
                `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function performAutoRefresh() {
            logActivity('Auto-refresh triggered - Reloading browser...', 'warning');
            
            localStorage.setItem('autoRefreshActive', 'true');
            localStorage.setItem('refreshTimestamp', Date.now().toString());
            
            saveSettings();
            
            setTimeout(() => {
                window.location.reload();
            }, 1000);
        }

        function handlePostRefreshRecovery() {
            const wasAutoRefresh = localStorage.getItem('autoRefreshActive');
            const refreshTimestamp = localStorage.getItem('refreshTimestamp');
            
            if (wasAutoRefresh === 'true') {
                localStorage.removeItem('autoRefreshActive');
                localStorage.removeItem('refreshTimestamp');
                
                const timeSinceRefresh = refreshTimestamp ? Date.now() - parseInt(refreshTimestamp) : 0;
                
                logActivity('Browser auto-refreshed successfully', 'success');
                logActivity(`Time since refresh: ${Math.floor(timeSinceRefresh / 1000)}s`, 'info');
                
                const autoRefreshEnabled = document.getElementById('autoRefreshFilter').checked;
                if (autoRefreshEnabled) {
                    setTimeout(() => {
                        if (document.getElementById('autoRefreshFilter').checked) {
                            startAutoRefresh();
                        }
                    }, 2000);
                }
            }
        }

        // Get duration type value from radio buttons
        function getDurationType() {
            const radios = document.getElementsByName('durationType');
            for (let radio of radios) {
                if (radio.checked) {
                    return radio.value;
                }
            }
            return 't'; // default to ticks
        }

        // Set duration type radio button
        function setDurationType(value) {
            const radios = document.getElementsByName('durationType');
            for (let radio of radios) {
                radio.checked = (radio.value === value);
            }
        }

        // Reset clear history button state
        function resetClearHistoryButton() {
            const btn = document.getElementById('clearHistoryBtn');
            btn.textContent = 'Clear History';
            btn.classList.remove('confirm-state');
            clearHistoryConfirmState = false;
            if (clearHistoryTimeout) {
                clearTimeout(clearHistoryTimeout);
                clearHistoryTimeout = null;
            }
        }

        // ALTERNATOR MODE: Get next trade type for a specific market
        function getNextAlternatorTradeType(symbol) {
            if (!isAlternatorMode) {
                return null; // Alternator mode disabled
            }
            
            // Return the next expected trade type for this market
            return marketAlternatorState[symbol];
        }

        // ALTERNATOR MODE: Update alternator state after trade execution
        function updateAlternatorState(symbol, executedType) {
            if (!isAlternatorMode) return;
            
            // Flip to opposite trade type for next signal on this market
            if (executedType === 'CALL') {
                marketAlternatorState[symbol] = 'PUT';
                logActivity(`[ALTERNATOR] ${markets[symbol]}: Next trade will be SELL (PUT)`, 'info');
            } else if (executedType === 'PUT') {
                marketAlternatorState[symbol] = 'CALL';
                logActivity(`[ALTERNATOR] ${markets[symbol]}: Next trade will be BUY (CALL)`, 'info');
            }
        }

        // ALTERNATOR MODE: Reset all markets to starting state
        function resetAlternatorStates() {
            Object.keys(markets).forEach(symbol => {
                marketAlternatorState[symbol] = 'CALL'; // Reset all to CALL
            });
            logActivity('[ALTERNATOR] All markets reset to BUY (CALL) starting position', 'success');
        }

        // Load saved settings
        function loadSettings() {
            const savedToken = sessionStorage.getItem('derivToken');
            const savedMarkets = sessionStorage.getItem('activeMarkets');
            const savedZeroFilter = sessionStorage.getItem('zeroClosingFilter');
            const savedIgnoreHeightFilter = sessionStorage.getItem('ignoreHeightFilter');
            const savedOneCandleFilter = sessionStorage.getItem('oneCandleFilter');
            const savedReverseCandleFilter = sessionStorage.getItem('reverseCandleFilter');
            const savedAutoRefreshFilter = sessionStorage.getItem('autoRefreshFilter');
            const savedReverseMode = sessionStorage.getItem('reverseMode');
            const savedAlternatorMode = sessionStorage.getItem('alternatorMode');
            const savedAlternatorStates = sessionStorage.getItem('alternatorStates');
            const savedStake = sessionStorage.getItem('stakeAmount');
            const savedStopLoss = sessionStorage.getItem('stopLoss');
            const savedTakeProfit = sessionStorage.getItem('takeProfit');
            const savedDurationType = sessionStorage.getItem('durationType');
            const savedDurationValue = sessionStorage.getItem('durationValue');
            const savedMinLowerWickBuy = sessionStorage.getItem('minLowerWickBuy');
            const savedMinUpperWickSell = sessionStorage.getItem('minUpperWickSell');
            const savedMinUpperWickBuy = sessionStorage.getItem('minUpperWickBuy');
            const savedMinLowerWickSell = sessionStorage.getItem('minLowerWickSell');
            const savedMatchingDiffBuy = sessionStorage.getItem('matchingDiffBuy');
            const savedMatchingDiffSell = sessionStorage.getItem('matchingDiffSell');
            const savedRefreshInterval = sessionStorage.getItem('refreshInterval');
            const savedTradeHistory = sessionStorage.getItem('tradeHistory');
            const savedStats = sessionStorage.getItem('tradeStats');

            if (savedToken) {
                document.getElementById('apiToken').value = savedToken;
            }

            if (savedMarkets) {
                activeMarkets = JSON.parse(savedMarkets);
            }

            if (savedZeroFilter) {
                document.getElementById('zeroClosingFilter').checked = savedZeroFilter === 'true';
            }

            if (savedIgnoreHeightFilter) {
                document.getElementById('ignoreHeightFilter').checked = savedIgnoreHeightFilter === 'true';
            }

            if (savedOneCandleFilter) {
                document.getElementById('oneCandleFilter').checked = savedOneCandleFilter === 'true';
            }

            if (savedReverseCandleFilter) {
                document.getElementById('reverseCandleFilter').checked = savedReverseCandleFilter === 'true';
            }

            if (savedAutoRefreshFilter) {
                document.getElementById('autoRefreshFilter').checked = savedAutoRefreshFilter === 'true';
            }

            if (savedReverseMode) {
                isReverseMode = savedReverseMode === 'true';
                updateReverseModeButton();
                updateReverseModeIndicator();
            }

            if (savedAlternatorMode) {
                isAlternatorMode = savedAlternatorMode === 'true';
                updateAlternatorModeButton();
                updateAlternatorModeIndicator();
            }

            if (savedAlternatorStates) {
                try {
                    marketAlternatorState = JSON.parse(savedAlternatorStates);
                } catch (e) {
                    console.error('Error loading alternator states:', e);
                }
            }

            if (savedStake) document.getElementById('stakeAmount').value = savedStake;
            if (savedStopLoss) document.getElementById('stopLoss').value = savedStopLoss;
            if (savedTakeProfit) document.getElementById('takeProfit').value = savedTakeProfit;
            if (savedDurationType) setDurationType(savedDurationType);
            if (savedDurationValue) document.getElementById('durationValue').value = savedDurationValue;
            if (savedMinLowerWickBuy) document.getElementById('minLowerWickBuy').value = savedMinLowerWickBuy;
            if (savedMinUpperWickSell) document.getElementById('minUpperWickSell').value = savedMinUpperWickSell;
            if (savedMinUpperWickBuy) document.getElementById('minUpperWickBuy').value = savedMinUpperWickBuy;
            if (savedMinLowerWickSell) document.getElementById('minLowerWickSell').value = savedMinLowerWickSell;
            if (savedMatchingDiffBuy) document.getElementById('matchingDiffBuy').value = savedMatchingDiffBuy;
            if (savedMatchingDiffSell) document.getElementById('matchingDiffSell').value = savedMatchingDiffSell;
            if (savedRefreshInterval) document.getElementById('refreshInterval').value = savedRefreshInterval;

            if (savedTradeHistory) {
                try {
                    tradeHistory = JSON.parse(savedTradeHistory);
                    updateTradeHistoryTable();
                } catch (e) {
                    console.error('Error loading trade history:', e);
                    tradeHistory = [];
                }
            }

            if (savedStats) {
                try {
                    tradeStats = JSON.parse(savedStats);
                    updateStats();
                } catch (e) {
                    console.error('Error loading trade stats:', e);
                    tradeStats = { total: 0, wins: 0, losses: 0, skipped: 0, profitLoss: 0 };
                }
            }

            updateOneCandleIndicator();
            checkFilterConflicts();
        }

        // Save settings
        function saveSettings() {
            try {
                sessionStorage.setItem('derivToken', document.getElementById('apiToken').value);
                sessionStorage.setItem('activeMarkets', JSON.stringify(activeMarkets));
                sessionStorage.setItem('zeroClosingFilter', document.getElementById('zeroClosingFilter').checked);
                sessionStorage.setItem('ignoreHeightFilter', document.getElementById('ignoreHeightFilter').checked);
                sessionStorage.setItem('oneCandleFilter', document.getElementById('oneCandleFilter').checked);
                sessionStorage.setItem('reverseCandleFilter', document.getElementById('reverseCandleFilter').checked);
                sessionStorage.setItem('autoRefreshFilter', document.getElementById('autoRefreshFilter').checked);
                sessionStorage.setItem('reverseMode', isReverseMode);
                sessionStorage.setItem('alternatorMode', isAlternatorMode);
                sessionStorage.setItem('alternatorStates', JSON.stringify(marketAlternatorState));
                sessionStorage.setItem('stakeAmount', document.getElementById('stakeAmount').value);
                sessionStorage.setItem('stopLoss', document.getElementById('stopLoss').value);
                sessionStorage.setItem('takeProfit', document.getElementById('takeProfit').value);
                sessionStorage.setItem('durationType', getDurationType());
                sessionStorage.setItem('durationValue', document.getElementById('durationValue').value);
                sessionStorage.setItem('minLowerWickBuy', document.getElementById('minLowerWickBuy').value);
                sessionStorage.setItem('minUpperWickSell',document.getElementById('minUpperWickSell').value);
                sessionStorage.setItem('minUpperWickBuy', document.getElementById('minUpperWickBuy').value);
                sessionStorage.setItem('minLowerWickSell', document.getElementById('minLowerWickSell').value);
                sessionStorage.setItem('matchingDiffBuy', document.getElementById('matchingDiffBuy').value);
                sessionStorage.setItem('matchingDiffSell', document.getElementById('matchingDiffSell').value);
                sessionStorage.setItem('refreshInterval', document.getElementById('refreshInterval').value);
                sessionStorage.setItem('tradeHistory', JSON.stringify(tradeHistory));
                sessionStorage.setItem('tradeStats', JSON.stringify(tradeStats));
                sessionStorage.setItem('wasAutoTrading', isAutoTrading);
            } catch (e) {
                console.error('Error saving settings:', e);
                logActivity('Warning: Failed to save some settings', 'warning');
            }
        }

        // Render markets with subscription indicators
        function renderMarkets() {
            const grid = document.getElementById('marketsGrid');
            grid.innerHTML = '';

            Object.entries(markets).forEach(([symbol, name]) => {
                const div = document.createElement('div');
                div.className = 'market-item';
                div.innerHTML = `
                    <span class="market-name">${name}</span>
                    <div class="market-controls">
                        <div class="subscription-indicator" data-indicator="${symbol}"></div>
                        <label class="toggle-switch">
                            <input type="checkbox" ${activeMarkets[symbol] ? 'checked' : ''} data-symbol="${symbol}">
                            <span class="slider"></span>
                        </label>
                    </div>
                `;
                grid.appendChild(div);

                const toggle = div.querySelector('input');
                toggle.addEventListener('change', (e) => {
                    activeMarkets[symbol] = e.target.checked;
                    logActivity(`Market ${name} ${e.target.checked ? 'enabled' : 'disabled'}`);
                    saveSettings();
                    
                    if (isLoggedIn && isAutoTrading) {
                        if (e.target.checked) {
                            subscribeToMarket(symbol);
                        } else {
                            unsubscribeFromMarket(symbol);
                        }
                    }
                });
            });
        }

        // Log activity
        function logActivity(message, type = 'info') {
            const container = document.getElementById('logContainer');
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<span class="timestamp">[${time}]</span> ${message}`;
            container.insertBefore(entry, container.firstChild);
            
            while (container.children.length > 100) {
                container.removeChild(container.lastChild);
            }
        }

        // Function to safely close a candle - FLOATING BROWSER FIX
        function finalizeCandle(symbol, closeTime, closePrice) {
            if (!currentOHLC[symbol]) return;
            
            // FLOATING BROWSER FIX: Prevent rapid candle finalization
            const now = Date.now();
            if (lastCandleProcessTime[symbol] && (now - lastCandleProcessTime[symbol]) < 500) {
                console.log(`[THROTTLE] Skipping rapid candle finalization for ${symbol}`);
                return;
            }
            lastCandleProcessTime[symbol] = now;

            const completedCandle = {
                time: currentMinute[symbol],
                open: currentOHLC[symbol].open,
                high: currentOHLC[symbol].high,
                low: currentOHLC[symbol].low,
                close: currentOHLC[symbol].close
            };

            candleData[symbol].push(completedCandle);
            
            if (candleData[symbol].length > 100) {
                candleData[symbol].shift();
            }

            currentMinute[symbol] = closeTime;
            
            currentOHLC[symbol] = {
                open: closePrice,
                high: closePrice,
                low: closePrice,
                close: closePrice
            };

            updateCandleCounter();
            
            const oneCandleFilter = document.getElementById('oneCandleFilter').checked;
            
            let requiredCandles = oneCandleFilter ? 1 : 3;
            
            if (isAutoTrading && candleData[symbol].length >= requiredCandles) {
                checkForSignals(symbol);
            }
        }

        // Enhanced Connect to Deriv API with auto-reconnect
        function connectWebSocket(token, isReconnect = false) {
            return new Promise((resolve, reject) => {
                if (reconnectTimeout) {
                    clearTimeout(reconnectTimeout);
                    reconnectTimeout = null;
                }

                ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=116948');

                ws.onopen = () => {
                    if (isReconnect) {
                        logActivity('WebSocket reconnected successfully', 'success');
                        reconnectAttempts = 0;
                    } else {
                        logActivity('WebSocket connected', 'success');
                    }
                    updateConnectionBadge('connected');
                    lastHeartbeat = Date.now();
                    ws.send(JSON.stringify({ authorize: token }));
                };

                ws.onmessage = (msg) => {
                    lastHeartbeat = Date.now();
                    const data = JSON.parse(msg.data);
                    handleWebSocketMessage(data, resolve, reject);
                };

                ws.onerror = (error) => {
                    logActivity('WebSocket error', 'error');
                    updateConnectionBadge('disconnected');
                    
                    if (sessionTimer) {
                        stopSessionTimer();
                        logActivity('Session timer reset due to connection error', 'warning');
                    }
                    
                    reject(error);
                };

                ws.onclose = () => {
                    logActivity('WebSocket disconnected', 'error');
                    updateConnectionBadge('disconnected');
                    
                    if (sessionTimer) {
                        stopSessionTimer();
                        logActivity('Session timer reset due to disconnection', 'warning');
                    }
                    
                    Object.keys(markets).forEach(symbol => {
                        updateSubscriptionIndicator(symbol, 'disconnected');
                    });
                    
                    marketSubscriptions = {};
                    pendingSubscriptions = {};
                    
                    if (isLoggedIn && reconnectAttempts < maxReconnectAttempts) {
                        wasAutoTradingBeforeDisconnect = isAutoTrading;
                        reconnectAttempts++;
                        const delay = Math.min(1000 * Math.pow(2, reconnectAttempts - 1), 30000);
                        
                        updateConnectionBadge('reconnecting');
                        logActivity(`Reconnection attempt ${reconnectAttempts}/${maxReconnectAttempts} in ${delay/1000}s...`, 'warning');
                        
                        reconnectTimeout = setTimeout(() => {
                            const savedToken = sessionStorage.getItem('derivToken');
                            if (savedToken) {
                                connectWebSocket(savedToken, true)
                                    .then(() => {
                                        logActivity('Reconnected successfully!', 'success');
                                        
                                        if (!sessionTimer) {
                                            startSessionTimer();
                                            logActivity('Session timer restarted after reconnection', 'success');
                                        }
                                        
                                        if (wasAutoTradingBeforeDisconnect && !isAutoTrading) {
                                            logActivity('Resuming auto trading...', 'info');
                                            setTimeout(() => startAutoTrading(), 1000);
                                        } else if (isAutoTrading) {
                                            subscribeToActiveMarkets();
                                        }
                                    })
                                    .catch(err => {
                                        logActivity(`Reconnection attempt ${reconnectAttempts} failed`, 'error');
                                    });
                            }
                        }, delay);
                    } else if (reconnectAttempts >= maxReconnectAttempts) {
                        logActivity('Max reconnection attempts reached. Please refresh the page or login again.', 'error');
                        reconnectAttempts = 0;
                    }
                };
            });
        }

        // Handle WebSocket messages
        function handleWebSocketMessage(data, resolve, reject) {
            if (data.error) {
                if (data.error.code !== 'AlreadySubscribed') {
                    logActivity('API Error: ' + data.error.message, 'error');
                    
                    if (data.echo_req && data.echo_req.ticks) {
                        const symbol = data.echo_req.ticks;
                        delete pendingSubscriptions[symbol];
                        updateSubscriptionIndicator(symbol, 'disconnected');
                    }
                }
                if (reject && data.error.code !== 'AlreadySubscribed') {
                    reject(new Error(data.error.message));
                }
                return;
            }

            if (data.msg_type === 'authorize') {
                accountInfo = {
                    type: data.authorize.account_list.find(a => a.loginid === data.authorize.loginid)?.is_virtual ? 'Demo' : 'Real',
                    currency: data.authorize.currency,
                    balance: data.authorize.balance,
                    loginid: data.authorize.loginid
                };

                document.getElementById('accountType').textContent = accountInfo.type;
                document.getElementById('accountCurrency').textContent = accountInfo.currency;
                document.getElementById('accountBalance').textContent = parseFloat(accountInfo.balance).toFixed(2);

                logActivity(`Logged in as ${accountInfo.loginid} (${accountInfo.type})`, 'success');
                
                ws.send(JSON.stringify({ balance: 1, subscribe: 1 }));

                if (resolve) resolve();
            }

            if (data.msg_type === 'balance') {
                accountInfo.balance = data.balance.balance;
                document.getElementById('accountBalance').textContent = parseFloat(accountInfo.balance).toFixed(2);
            }

            if (data.msg_type === 'tick' && data.tick) {
                const symbol = data.tick.symbol;
                if (!activeMarkets[symbol]) return;
                
                // FLOATING BROWSER FIX: Prevent tick processing race conditions
                if (isProcessingTicks) {
                    return;
                }
                isProcessingTicks = true;

                const epoch = data.tick.epoch;
                const quote = parseFloat(data.tick.quote);
                const now = Date.now();
                
                const calculatedOffset = now - (epoch * 1000);
                if (!isTimeSynced) {
                    serverTimeOffset = calculatedOffset;
                    isTimeSynced = true;
                } else {
                    serverTimeOffset = (serverTimeOffset * 0.9) + (calculatedOffset * 0.1);
                }

                const tickMinute = Math.floor(epoch / 60) * 60;

                if (currentMinute[symbol] === undefined) {
                    currentMinute[symbol] = tickMinute;
                    currentOHLC[symbol] = { open: quote, high: quote, low: quote, close: quote };
                }

                if (tickMinute > currentMinute[symbol]) {
                    finalizeCandle(symbol, tickMinute, quote);
                }

                if (currentOHLC[symbol]) {
                    currentOHLC[symbol].high = Math.max(currentOHLC[symbol].high, quote);
                    currentOHLC[symbol].low = Math.min(currentOHLC[symbol].low, quote);
                    currentOHLC[symbol].close = quote;
                }

                if (data.subscription && data.subscription.id && !marketSubscriptions[symbol]) {
                    marketSubscriptions[symbol] = data.subscription.id;
                    delete pendingSubscriptions[symbol];
                    updateSubscriptionIndicator(symbol, 'subscribed');
                    logActivity(`${markets[symbol]} subscribed successfully`, 'success');
                }
                
                isProcessingTicks = false;
            }

            if (data.msg_type === 'proposal' && data.proposal) {
                const reqId = data.req_id;
                if (pendingProposals.has(reqId)) {
                    const proposalData = pendingProposals.get(reqId);
                    proposalData.resolve(data);
                    pendingProposals.delete(reqId);
                }
            }

            if (data.msg_type === 'buy') {
                if (data.buy && data.buy.contract_id) {
                    const proposalId = data.echo_req?.buy;
                    const tradeInfo = pendingTrades.get(proposalId);
                    
                    if (tradeInfo) {
                        pendingTrades.delete(proposalId);
                        pendingTrades.set(data.buy.contract_id, tradeInfo);
                    }
                    
                    ws.send(JSON.stringify({
                        proposal_open_contract: 1,
                        contract_id: data.buy.contract_id,
                        subscribe: 1
                    }));
                    
                    logActivity(`Trade opened: Contract ID ${data.buy.contract_id}`, 'success');
                }
            }

            if (data.msg_type === 'proposal_open_contract') {
                handleTradeResult(data.proposal_open_contract);
            }

            if (data.msg_type === 'forget') {
                if (data.forget) {
                    logActivity(`Unsubscribed from subscription ID: ${data.forget}`, 'info');
                }
            }

            if (data.msg_type === 'ping') {
                ws.send(JSON.stringify({ ping: 1 }));
            }
        }

        // AGGRESSIVE FIX: Handle trade result with proper duplicate prevention
        function handleTradeResult(contract) {
            if (!['won', 'lost', 'sold'].includes(contract.status)) {
                return;
            }
            
            if (processedContracts.has(contract.contract_id)) {
                console.log(`[DUPLICATE PREVENTED] Contract ${contract.contract_id} already processed`);
                return;
            }

            processedContracts.add(contract.contract_id);

            const profit = parseFloat(contract.profit || 0);
            const isWin = profit > 0;

            tradeStats.total++;
            if (isWin) tradeStats.wins++;
            else tradeStats.losses++;
            tradeStats.profitLoss += profit;

            const trade = {
                id: contract.contract_id,
                time: new Date().toLocaleTimeString(),
                date: new Date().toLocaleDateString(),
                market: markets[contract.underlying] || contract.underlying || 'Unknown',
                type: contract.contract_type || 'Unknown',
                stake: parseFloat(contract.buy_price || 0).toFixed(2),
                result: profit.toFixed(2),
                isWin: isWin
            };

            if (!Array.isArray(tradeHistory)) {
                tradeHistory = [];
                logActivity('Trade history reinitialized', 'warning');
            }

            tradeHistory.unshift(trade);
            
            if (tradeHistory.length > 100) {
                tradeHistory = tradeHistory.slice(0, 100);
            }

            updateStats();
            updateTradeHistoryTable();
            saveSettings();

            logActivity(`‚úÖ TRADE RECORDED: ${trade.market} - ${trade.type} - P/L: ${trade.result} (ID: ${contract.contract_id})`, isWin ? 'success' : 'error');

            const stopLoss = parseFloat(document.getElementById('stopLoss').value);
            const takeProfit = parseFloat(document.getElementById('takeProfit').value);

            if (stopLoss > 0 && Math.abs(tradeStats.profitLoss) >= stopLoss && tradeStats.profitLoss < 0) {
                logActivity(`Stop loss reached: ${tradeStats.profitLoss.toFixed(2)}`, 'error');
                stopAutoTrading();
            }

            if (takeProfit > 0 && tradeStats.profitLoss >= takeProfit) {
                logActivity(`Take profit reached: ${tradeStats.profitLoss.toFixed(2)}`, 'success');
                stopAutoTrading();
            }

            if (pendingTrades.has(contract.contract_id)) {
                pendingTrades.delete(contract.contract_id);
            }

            setTimeout(() => {
                processedContracts.delete(contract.contract_id);
            }, 300000);
        }

        // Login
        document.getElementById('loginBtn').addEventListener('click', async () => {
            const token = document.getElementById('apiToken').value.trim();
            if (!token) {
                logActivity('Please enter API token', 'error');
                return;
            }

            document.getElementById('loginBtn').disabled = true;
            document.getElementById('loginBtn').textContent = 'Connecting...';

            try {
                await connectWebSocket(token);
                isLoggedIn = true;
                reconnectAttempts = 0;
                
                document.getElementById('loginSection').classList.add('hidden');
                document.getElementById('accountInfo').classList.remove('hidden');
                document.getElementById('timerDisplay').classList.remove('hidden');
                document.getElementById('autoTradeBtn').disabled = false;
                document.getElementById('reverseModeBtn').disabled = false;
                document.getElementById('alternatorModeBtn').disabled = false;

                saveSettings();
                startSessionTimer();
                logActivity('Login successful', 'success');
                
                if (document.getElementById('autoRefreshFilter').checked) {
                    startAutoRefresh();
                }
            } catch (error) {
                logActivity('Login failed: ' + error.message, 'error');
                document.getElementById('loginBtn').disabled = false;
                document.getElementById('loginBtn').textContent = 'Login';
                updateConnectionBadge('disconnected');
            }
        });

        // Logout
        document.getElementById('logoutBtn').addEventListener('click', () => {
            if (isAutoTrading) {
                stopAutoTrading();
            }

            if (ws) {
                ws.close();
                ws = null;
            }

            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }

            isLoggedIn = false;
            reconnectAttempts = 0;
            stopSessionTimer();
            stopAutoRefresh();
            updateConnectionBadge('disconnected');

            document.getElementById('apiToken').value = '';
            sessionStorage.removeItem('derivToken');

            document.getElementById('loginSection').classList.remove('hidden');
            document.getElementById('accountInfo').classList.add('hidden');
            document.getElementById('timerDisplay').classList.add('hidden');
            document.getElementById('autoTradeBtn').disabled = true;
            document.getElementById('reverseModeBtn').disabled = true;
            document.getElementById('alternatorModeBtn').disabled = true;
            document.getElementById('loginBtn').disabled = false;
            document.getElementById('loginBtn').textContent = 'Login';

            logActivity('Logged out successfully - Token cleared', 'success');
        });

        // Session timer
        function startSessionTimer() {
            sessionStartTime = Date.now();
            sessionTimer = setInterval(() => {
                const elapsed = Date.now() - sessionStartTime;
                const hours = Math.floor(elapsed / 3600000);
                const minutes = Math.floor((elapsed % 3600000) / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                
                document.getElementById('timerValue').textContent = 
                    `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }, 1000);
        }

        function stopSessionTimer() {
            if (sessionTimer) {
                clearInterval(sessionTimer);
                sessionTimer = null;
            }
            sessionStartTime = null;
            document.getElementById('timerValue').textContent = '00:00:00';
        }

        // Subscribe to market
        function subscribeToMarket(symbol) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                logActivity('Cannot subscribe: WebSocket not connected', 'error');
                return;
            }

            if (marketSubscriptions[symbol]) {
                logActivity(`Already subscribed to ${markets[symbol]}`, 'info');
                updateSubscriptionIndicator(symbol, 'subscribed');
                return;
            }

            if (pendingSubscriptions[symbol]) {
                logActivity(`Already subscribing to ${markets[symbol]}`, 'info');
                return;
            }

            pendingSubscriptions[symbol] = true;
            updateSubscriptionIndicator(symbol, 'subscribing');

            const subscribeMsg = {
                ticks: symbol,
                subscribe: 1
            };

            ws.send(JSON.stringify(subscribeMsg));
            logActivity(`Subscribing to ${markets[symbol]}...`, 'info');

            setTimeout(() => {
                if (pendingSubscriptions[symbol] && !marketSubscriptions[symbol]) {
                    delete pendingSubscriptions[symbol];
                    updateSubscriptionIndicator(symbol, 'disconnected');
                    logActivity(`Subscription timeout for ${markets[symbol]}`, 'error');
                }
            }, 10000);
        }

        function unsubscribeFromMarket(symbol) {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;

            if (marketSubscriptions[symbol]) {
                ws.send(JSON.stringify({ forget: marketSubscriptions[symbol] }));
                delete marketSubscriptions[symbol];
                candleData[symbol] = [];
                currentOHLC[symbol] = undefined;
                currentMinute[symbol] = undefined;
                tradedCandles[symbol].clear();
                updateSubscriptionIndicator(symbol, 'disconnected');
                logActivity(`Unsubscribed from ${markets[symbol]}`);
            }

            if (pendingSubscriptions[symbol]) {
                delete pendingSubscriptions[symbol];
                updateSubscriptionIndicator(symbol, 'disconnected');
            }
            
            updateCandleCounter();
        }

        // Subscribe to all active markets
        function subscribeToActiveMarkets() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                logActivity('Cannot subscribe: WebSocket not connected', 'error');
                return;
            }

            let subscribeCount = 0;
            Object.keys(activeMarkets).forEach(symbol => {
                if (activeMarkets[symbol]) {
                    subscribeToMarket(symbol);
                    subscribeCount++;
                }
            });

            logActivity(`Subscribing to ${subscribeCount} active markets...`, 'info');
        }

        // Unsubscribe from all markets
        function unsubscribeFromAllMarkets() {
            Object.keys(marketSubscriptions).forEach(symbol => {
                unsubscribeFromMarket(symbol);
            });
            Object.keys(pendingSubscriptions).forEach(symbol => {
                delete pendingSubscriptions[symbol];
                updateSubscriptionIndicator(symbol, 'disconnected');
            });
        }

        // ‚úÖ FIXED: Check for trading signals with proper execution order
        function checkForSignals(symbol) {
            const oneCandleFilter = document.getElementById('oneCandleFilter').checked;
            
            let requiredCandles = oneCandleFilter ? 1 : 3;
            
            if (candleData[symbol].length < requiredCandles) return;

            const candles = candleData[symbol];
            const lastCandle = candles[candles.length - 1];

            if (!lastCandle) return;

            const candle_start_time = lastCandle.time;
            if (candle_start_time < activation_time) {
                return;
            }

            const candleKey = `${lastCandle.time}`;
            
            // ‚úÖ FIX #1: Check if already traded FIRST (before any processing)
            if (tradedCandles[symbol].has(candleKey)) {
                // Silent skip - already traded this candle
                return;
            }

            const zeroClosingFilter = document.getElementById('zeroClosingFilter').checked;
            const ignoreHeightFilter = document.getElementById('ignoreHeightFilter').checked;
            const reverseCandleFilter = document.getElementById('reverseCandleFilter').checked;
            const minLowerWickBuy = parseFloat(document.getElementById('minLowerWickBuy').value) / 100;
            const minUpperWickSell = parseFloat(document.getElementById('minUpperWickSell').value) / 100;
            const minUpperWickBuy = parseFloat(document.getElementById('minUpperWickBuy').value) / 100;
            const minLowerWickSell = parseFloat(document.getElementById('minLowerWickSell').value) / 100;

            // ONE CANDLE MODE
            if (oneCandleFilter) {
                const buySignal = checkOneCandleBuy(lastCandle, zeroClosingFilter, ignoreHeightFilter, reverseCandleFilter, minLowerWickBuy, minUpperWickBuy);
                if (buySignal) {
                    let tradeType = isReverseMode ? 'PUT' : 'CALL';

                    // ‚úÖ FIX #2: Check WebSocket connection BEFORE marking as traded
                    if (!ws || ws.readyState !== WebSocket.OPEN) {
                        logActivity(`‚ö†Ô∏è Signal skipped for ${markets[symbol]}: WebSocket not connected`, 'warning');
                        tradeStats.skipped++;
                        updateStats();
                        saveSettings();
                        return;
                    }

                    // ALTERNATOR MODE: Check if this trade type is allowed
                    if (isAlternatorMode) {
                        const expectedType = getNextAlternatorTradeType(symbol);
                        if (tradeType !== expectedType) {
                            logActivity(`‚ö†Ô∏è [ALTERNATOR BLOCK] ${markets[symbol]}: BUY signal detected but expecting ${expectedType === 'CALL' ? 'BUY' : 'SELL'}. Signal skipped.`, 'warning');
                            tradeStats.skipped++;
                            updateStats();
                            
                            // Add skipped signal to monitor
                            const patternName = reverseCandleFilter ? 'Reverse One Candle Buy' : 'One Candle Buy';
                            const signalText = isReverseMode ? `${patternName} SELL (REVERSED) - BLOCKED BY ALTERNATOR` : `${patternName} BUY - BLOCKED BY ALTERNATOR`;
                            addSignal(symbol, signalText, 'skipped');
                            
                            saveSettings();
                            return;
                        }
                    }

                    // ‚úÖ FIX #3: Mark candle as traded BEFORE executing trade
                    tradedCandles[symbol].add(candleKey);

                    // ‚úÖ FIX #4: Display signal
                    const patternName = reverseCandleFilter ? 'Reverse One Candle Buy' : 'One Candle Buy';
                    const signalText = isReverseMode ? `${patternName} SELL (REVERSED)` : `${patternName} BUY`;
                    addSignal(symbol, signalText);

                    // ‚úÖ FIX #5: Execute trade with proper error handling
                    executeTrade(symbol, tradeType, candleKey).catch(error => {
                        logActivity(`‚ùå Trade failed for ${markets[symbol]}: ${error.message}`, 'error');
                        // Optional: Allow retry by removing from tradedCandles
                        // tradedCandles[symbol].delete(candleKey);
                    });
                }

                const sellSignal = checkOneCandleSell(lastCandle, zeroClosingFilter, ignoreHeightFilter, reverseCandleFilter, minUpperWickSell, minLowerWickSell);
                if (sellSignal) {
                    let tradeType = isReverseMode ? 'CALL' : 'PUT';

                    // ‚úÖ FIX #2: Check WebSocket connection BEFORE marking as traded
                    if (!ws || ws.readyState !== WebSocket.OPEN) {
                        logActivity(`‚ö†Ô∏è Signal skipped for ${markets[symbol]}: WebSocket not connected`, 'warning');
                        tradeStats.skipped++;
                        updateStats();
                        saveSettings();
                        return;
                    }

                    // ALTERNATOR MODE: Check if this trade type is allowed
                    if (isAlternatorMode) {
                        const expectedType = getNextAlternatorTradeType(symbol);
                        if (tradeType !== expectedType) {
                            logActivity(`‚ö†Ô∏è [ALTERNATOR BLOCK] ${markets[symbol]}: SELL signal detected but expecting ${expectedType === 'CALL' ? 'BUY' : 'SELL'}. Signal skipped.`, 'warning');
                            tradeStats.skipped++;
                            updateStats();
                            
                            // Add skipped signal to monitor
                            const patternName = reverseCandleFilter ? 'Reverse One Candle Sell' : 'One Candle Sell';
                            const signalText = isReverseMode ? `${patternName} BUY (REVERSED) - BLOCKED BY ALTERNATOR` : `${patternName} SELL - BLOCKED BY ALTERNATOR`;
                            addSignal(symbol, signalText, 'skipped');
                            
                            saveSettings();
                            return;
                        }
                    }

                    // ‚úÖ FIX #3: Mark candle as traded BEFORE executing trade
                    tradedCandles[symbol].add(candleKey);

                    // ‚úÖ FIX #4: Display signal
                    const patternName = reverseCandleFilter ? 'Reverse One Candle Sell' : 'One Candle Sell';
                    const signalText = isReverseMode ? `${patternName} BUY (REVERSED)` : `${patternName} SELL`;
                    addSignal(symbol, signalText);

                    // ‚úÖ FIX #5: Execute trade with proper error handling
                    executeTrade(symbol, tradeType, candleKey).catch(error => {
                        logActivity(`‚ùå Trade failed for ${markets[symbol]}: ${error.message}`, 'error');
                        // Optional: Allow retry by removing from tradedCandles
                        // tradedCandles[symbol].delete(candleKey);
                    });
                }
            } else {
                // TWO CANDLE MODE
                const prevCandle = candles[candles.length - 2];
                if (!prevCandle) return;

                const matchingDiffBuy = parseFloat(document.getElementById('matchingDiffBuy').value) / 100;
                const matchingDiffSell = parseFloat(document.getElementById('matchingDiffSell').value) / 100;

                const buySignal = checkTweezersBottom(prevCandle, lastCandle, zeroClosingFilter, ignoreHeightFilter, reverseCandleFilter, minLowerWickBuy, minUpperWickBuy, matchingDiffBuy);
                if (buySignal) {
                    let tradeType = isReverseMode ? 'PUT' : 'CALL';

                    // ‚úÖ FIX #2: Check WebSocket connection BEFORE marking as traded
                    if (!ws || ws.readyState !== WebSocket.OPEN) {
                        logActivity(`‚ö†Ô∏è Signal skipped for ${markets[symbol]}: WebSocket not connected`, 'warning');
                        tradeStats.skipped++;
                        updateStats();
                        saveSettings();
                        return;
                    }

                    // ALTERNATOR MODE: Check if this trade type is allowed
                    if (isAlternatorMode) {
                        const expectedType = getNextAlternatorTradeType(symbol);
                        if (tradeType !== expectedType) {
                            logActivity(`‚ö†Ô∏è [ALTERNATOR BLOCK] ${markets[symbol]}: BUY signal detected but expecting ${expectedType === 'CALL' ? 'BUY' : 'SELL'}. Signal skipped.`, 'warning');
                            tradeStats.skipped++;
                            updateStats();
                            
                            // Add skipped signal to monitor
                            const patternName = reverseCandleFilter ? 'Reverse Tweezers Bottom' : 'Tweezers Bottom';
                            const signalText = isReverseMode ? `${patternName} SELL (REVERSED) - BLOCKED BY ALTERNATOR` : `${patternName} BUY - BLOCKED BY ALTERNATOR`;
                            addSignal(symbol, signalText, 'skipped');
                            
                            saveSettings();
                            return;
                        }
                    }

                    // ‚úÖ FIX #3: Mark candle as traded BEFORE executing trade
                    tradedCandles[symbol].add(candleKey);

                    // ‚úÖ FIX #4: Display signal
                    const patternName = reverseCandleFilter ? 'Reverse Tweezers Bottom' : 'Tweezers Bottom';
                    const signalText = isReverseMode ? `${patternName} SELL (REVERSED)` : `${patternName} BUY`;
                    addSignal(symbol, signalText);

                    // ‚úÖ FIX #5: Execute trade with proper error handling
                    executeTrade(symbol, tradeType, candleKey).catch(error => {
                        logActivity(`‚ùå Trade failed for ${markets[symbol]}: ${error.message}`, 'error');
                        // Optional: Allow retry by removing from tradedCandles
                        // tradedCandles[symbol].delete(candleKey);
                    });
                }

                const sellSignal = checkTweezersTop(prevCandle, lastCandle, zeroClosingFilter, ignoreHeightFilter, reverseCandleFilter, minUpperWickSell, minLowerWickSell, matchingDiffSell);
                if (sellSignal) {
                    let tradeType = isReverseMode ? 'CALL' : 'PUT';

                    // ‚úÖ FIX #2: Check WebSocket connection BEFORE marking as traded
                    if (!ws || ws.readyState !== WebSocket.OPEN) {
                        logActivity(`‚ö†Ô∏è Signal skipped for ${markets[symbol]}: WebSocket not connected`, 'warning');
                        tradeStats.skipped++;
                        updateStats();
                        saveSettings();
                        return;
                    }

                    // ALTERNATOR MODE: Check if this trade type is allowed
                    if (isAlternatorMode) {
                        const expectedType = getNextAlternatorTradeType(symbol);
                        if (tradeType !== expectedType) {
                            logActivity(`‚ö†Ô∏è [ALTERNATOR BLOCK] ${markets[symbol]}: SELL signal detected but expecting ${expectedType === 'CALL' ? 'BUY' : 'SELL'}. Signal skipped.`, 'warning');
                            tradeStats.skipped++;
                            updateStats();
                            
                            // Add skipped signal to monitor
                            const patternName = reverseCandleFilter ? 'Reverse Tweezers Top' : 'Tweezers Top';
                            const signalText = isReverseMode ? `${patternName} BUY (REVERSED) - BLOCKED BY ALTERNATOR` : `${patternName} SELL - BLOCKED BY ALTERNATOR`;
                            addSignal(symbol, signalText, 'skipped');
                            
                            saveSettings();
                            return;
                        }
                    }

                    // ‚úÖ FIX #3: Mark candle as traded BEFORE executing trade
                    tradedCandles[symbol].add(candleKey);

                    // ‚úÖ FIX #4: Display signal
                    const patternName = reverseCandleFilter ? 'Reverse Tweezers Top' : 'Tweezers Top';
                    const signalText = isReverseMode ? `${patternName} BUY (REVERSED)` : `${patternName} SELL`;
                    addSignal(symbol, signalText);

                    // ‚úÖ FIX #5: Execute trade with proper error handling
                    executeTrade(symbol, tradeType, candleKey).catch(error => {
                        logActivity(`‚ùå Trade failed for ${markets[symbol]}: ${error.message}`, 'error');
                        // Optional: Allow retry by removing from tradedCandles
                        // tradedCandles[symbol].delete(candleKey);
                    });
                }
            }
        }

        // ONE CANDLE MODE - Check single candle for BUY signal (Red candle)
        function checkOneCandleBuy(candle, zeroClosing, ignoreHeight, reverseCandle, minLowerWickPercent, minUpperWickPercent) {
            const isCandleRed = candle.close < candle.open;
            const isCandleGreen = candle.close > candle.open;
            
            if (reverseCandle) {
                if (!isCandleGreen) return false;
            } else {
                if (!isCandleRed) return false;
            }

            const candleRange = candle.high - candle.low;
            if (candleRange === 0) return false;

            const lowerWick = Math.min(candle.open, candle.close) - candle.low;
            const upperWick = candle.high - Math.max(candle.open, candle.close);

            if (lowerWick / candleRange < minLowerWickPercent) return false;

            if (zeroClosing) {
                if (upperWick !== 0) return false;
            } else {
                if (upperWick / candleRange > minUpperWickPercent) return false;
            }

            return true;
        }

        // ONE CANDLE MODE - Check single candle for SELL signal (Green candle)
        function checkOneCandleSell(candle, zeroClosing, ignoreHeight, reverseCandle, minUpperWickPercent, minLowerWickPercent) {
            const isCandleGreen = candle.close > candle.open;
            const isCandleRed = candle.close < candle.open;
            
            if (reverseCandle) {
                if (!isCandleRed) return false;
            } else {
                if (!isCandleGreen) return false;
            }

            const candleRange = candle.high - candle.low;
            if (candleRange === 0) return false;

            const upperWick = candle.high - Math.max(candle.open, candle.close);
            const lowerWick = Math.min(candle.open, candle.close) - candle.low;

            if (upperWick / candleRange < minUpperWickPercent) return false;

            if (zeroClosing) {
                if (lowerWick !== 0) return false;
            } else {
                if (lowerWick / candleRange > minLowerWickPercent) return false;
            }

            return true;
        }

        // TWO CANDLE MODE - Check Tweezers Bottom with all filters
        function checkTweezersBottom(candle1, candle2, zeroClosing, ignoreHeight, reverseCandle, minLowerWickPercent, minUpperWickPercent, matchingDiff) {
            const isCandle1Red = candle1.close < candle1.open;
            const isCandle1Green = candle1.close > candle1.open;
            
            if (reverseCandle) {
                if (!isCandle1Green) return false;
            } else {
                if (!isCandle1Red) return false;
            }

            const candle1Range = candle1.high - candle1.low;
            if (candle1Range === 0) return false;

            const candle1LowerWick = Math.min(candle1.open, candle1.close) - candle1.low;
            const candle1UpperWick = candle1.high - Math.max(candle1.open, candle1.close);

            if (candle1LowerWick / candle1Range < minLowerWickPercent) return false;

            if (zeroClosing) {
                if (candle1UpperWick !== 0) return false;
            } else {
                if (candle1UpperWick / candle1Range > minUpperWickPercent) return false;
            }

            const isCandle2Green = candle2.close > candle2.open;
            const isCandle2Red = candle2.close < candle2.open;
            
            if (reverseCandle) {
                if (!isCandle2Red) return false;
            } else {
                if (!isCandle2Green) return false;
            }

            const candle2Range = candle2.high - candle2.low;
            if (candle2Range === 0) return false;

            const candle2LowerWick = Math.min(candle2.open, candle2.close) - candle2.low;
            const candle2UpperWick = candle2.high - Math.max(candle2.open, candle2.close);

            if (candle2LowerWick / candle2Range < minLowerWickPercent) return false;

            if (zeroClosing) {
                if (candle2UpperWick !== 0) return false;
            } else {
                if (candle2UpperWick / candle2Range > minUpperWickPercent) return false;
            }

            const lowDiff = Math.abs(candle1.low - candle2.low) / candle1.low;
            if (lowDiff > matchingDiff) return false;

            if (ignoreHeight) {
                return true;
            } else {
                if (candle2.close < candle1.high) return false;
            }

            return true;
        }

        // TWO CANDLE MODE - Check Tweezers Top with all filters
        function checkTweezersTop(candle1, candle2, zeroClosing, ignoreHeight, reverseCandle, minUpperWickPercent, minLowerWickPercent, matchingDiff) {
            const isCandle1Green = candle1.close > candle1.open;
            const isCandle1Red = candle1.close < candle1.open;
            
            if (reverseCandle) {
                if (!isCandle1Red) return false;
            } else {
                if (!isCandle1Green) return false;
            }

            const candle1Range = candle1.high - candle1.low;
            if (candle1Range === 0) return false;

            const candle1UpperWick = candle1.high - Math.max(candle1.open, candle1.close);
            const candle1LowerWick = Math.min(candle1.open, candle1.close) - candle1.low;

            if (candle1UpperWick / candle1Range < minUpperWickPercent) return false;

            if (zeroClosing) {
                if (candle1LowerWick !== 0) return false;
            } else {
                if (candle1LowerWick / candle1Range > minLowerWickPercent) return false;
            }

            const isCandle2Red = candle2.close < candle2.open;
            const isCandle2Green = candle2.close > candle2.open;
            
            if (reverseCandle) {
                if (!isCandle2Green) return false;
            } else {
                if (!isCandle2Red) return false;
            }

            const candle2Range = candle2.high - candle2.low;
            if (candle2Range === 0) return false;

            const candle2UpperWick = candle2.high - Math.max(candle2.open, candle2.close);
            const candle2LowerWick = Math.min(candle2.open, candle2.close) - candle2.low;

            if (candle2UpperWick / candle2Range < minUpperWickPercent) return false;

            if (zeroClosing) {
                if (candle2LowerWick !== 0) return false;
            } else {
                if (candle2LowerWick / candle2Range > minLowerWickPercent) return false;
            }

            const highDiff = Math.abs(candle1.high - candle2.high) / candle1.high;
            if (highDiff > matchingDiff) return false;

            if (ignoreHeight) {
                return true;
            } else {
                if (candle2.close > candle1.low) return false;
            }

            return true;
        }

        // Add signal to monitor with status
        let signalCounter = 0;
        function addSignal(symbol, pattern, status = 'active') {
            const container = document.getElementById('signalsContainer');
            
            if (isFirstSignal) {
                container.innerHTML = '';
                isFirstSignal = false;
            }

            const signalId = `signal-${signalCounter++}`;
            
            const time = new Date().toLocaleTimeString();
            const signalDiv = document.createElement('div');
            signalDiv.className = `signal-item ${status}`;
            signalDiv.id = signalId;
            signalDiv.innerHTML = `<div class="signal-text">[${time}] ${markets[symbol]} - ${pattern}</div>`;
            
            container.insertBefore(signalDiv, container.firstChild);
            
            while (container.children.length > 50) {
                container.removeChild(container.lastChild);
            }

            return signalId;
        }

        // ‚úÖ FIXED: Execute trade with proper error handling
        async function executeTrade(symbol, type, candleKey) {
            // This check is redundant now (done before calling), but kept for safety
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                const error = new Error('WebSocket not connected');
                logActivity(`Cannot execute trade: ${error.message}`, 'error');
                throw error;
            }

            const stake = parseFloat(document.getElementById('stakeAmount').value);
            const durationType = getDurationType();
            const durationValue = parseInt(document.getElementById('durationValue').value);

            const reqId = ++requestIdCounter;

            const proposal = {
                proposal: 1,
                amount: stake,
                basis: 'stake',
                contract_type: type,
                currency: accountInfo.currency,
                duration: durationValue,
                duration_unit: durationType,
                symbol: symbol,
                req_id: reqId
            };

            try {
                ws.send(JSON.stringify(proposal));
                
                const proposalResponse = await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        pendingProposals.delete(reqId);
                        reject(new Error('Proposal timeout (5s)'));
                    }, 5000);
                    
                    pendingProposals.set(reqId, { resolve, reject, timeout });
                });

                if (pendingProposals.has(reqId)) {
                    clearTimeout(pendingProposals.get(reqId).timeout);
                    pendingProposals.delete(reqId);
                }

                if (proposalResponse.proposal) {
                    const proposalId = proposalResponse.proposal.id;
                    const tradeInfo = {
                        symbol: symbol,
                        type: type,
                        stake: stake,
                        candle_time: candleKey
                    };
                    
                    pendingTrades.set(proposalId, tradeInfo);
                    
                    ws.send(JSON.stringify({
                        buy: proposalId,
                        price: stake
                    }));

                    // ALTERNATOR MODE: Update state after successful trade execution
                    if (isAlternatorMode) {
                        updateAlternatorState(symbol, type);
                        saveSettings(); // Save alternator state
                    }

                    logActivity(`‚úÖ Trade executed: ${type} on ${markets[symbol]} - Stake: ${stake}`, 'success');
                }
            } catch (error) {
                logActivity(`‚ùå Trade execution failed for ${markets[symbol]}: ${error.message}`, 'error');
                throw error; // Re-throw to be caught by caller
            }
        }

        // Update statistics
        function updateStats() {
            document.getElementById('totalTrades').textContent = tradeStats.total;
            document.getElementById('totalWins').textContent = tradeStats.wins;
            document.getElementById('totalLosses').textContent = tradeStats.losses;
            document.getElementById('totalSkipped').textContent = tradeStats.skipped;
            
            const plElement = document.getElementById('profitLoss');
            plElement.textContent = tradeStats.profitLoss.toFixed(2);
            plElement.className = 'stat-value ' + (tradeStats.profitLoss >= 0 ? 'profit' : 'loss');
        }

        // AGGRESSIVE FIX: Update trade history table with better handling
        function updateTradeHistoryTable() {
            const tbody = document.getElementById('historyTableBody');
            
            if (!Array.isArray(tradeHistory)) {
                console.error('tradeHistory is not an array, reinitializing');
                tradeHistory = [];
            }
            
            if (tradeHistory.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #8899aa;">No trades yet</td></tr>';
                updateTradeCountDisplay();
                return;
            }

            tbody.innerHTML = '';
            
            const displayCount = Math.min(tradeHistory.length, 100);
            
            for (let i = 0; i < displayCount; i++) {
                const trade = tradeHistory[i];
                
                if (!trade || typeof trade !== 'object') {
                    console.warn(`Invalid trade at index ${i}`, trade);
                    continue;
                }
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${i + 1}</td>
                    <td>${trade.time || '-'}</td>
                    <td>${trade.market || 'Unknown'}</td>
                    <td>${trade.type || '-'}</td>
                    <td>${trade.stake || '0.00'}</td>
                    <td class="${trade.isWin ? 'result-win' : 'result-loss'}">${trade.result || '0.00'}</td>
                `;
                tbody.appendChild(row);
            }
            
            tbody.offsetHeight;
            
            updateTradeCountDisplay();
            
            console.log(`[TABLE UPDATE] Displayed ${displayCount} trades from ${tradeHistory.length} total`);
        }

        // Start auto trading
        function startAutoTrading() {
            if (!isLoggedIn) {
                logActivity('Please login first', 'error');
                return;
            }

            if (!ws || ws.readyState !== WebSocket.OPEN) {
                logActivity('WebSocket not connected. Please check connection.', 'error');
                return;
            }

            isAutoTrading = true;
            isFirstSignal = true;
            
            activation_time = Math.floor(Date.now() / 1000);
            
            processedContracts.clear();
            
            Object.keys(markets).forEach(symbol => {
                candleData[symbol] = [];
                currentOHLC[symbol] = undefined;
                currentMinute[symbol] = undefined;
                tradedCandles[symbol].clear();
            });
            
            // ALTERNATOR MODE: Reset all markets when starting
            if (isAlternatorMode) {
                resetAlternatorStates();
            }
            
            document.getElementById('autoTradeBtn').textContent = 'Stop Auto Trade';
            document.getElementById('autoTradeBtn').className = 'btn btn-danger';
            
            const statusText = document.getElementById('statusText');
            const statusDot = document.getElementById('statusDot');
            statusText.textContent = 'Bot Active - Analyzing Markets';
            statusText.className = 'status-text active';
            statusDot.className = 'pulse-dot active';

            const container = document.getElementById('signalsContainer');
            container.innerHTML = '<div class="signal-item"><div class="signal-text">Bot activated. Monitoring markets for signals...</div></div>';

            const oneCandleFilter = document.getElementById('oneCandleFilter').checked;
            
            let requiredCandles = oneCandleFilter ? 1 : 3;
            
            logActivity('Auto trading started', 'success');
            logActivity(`Activation time set: ${new Date(activation_time * 1000).toLocaleTimeString()}`, 'info');
            logActivity(`Mode: ${oneCandleFilter ? 'ONE CANDLE' : 'TWO CANDLE (Tweezers)'}`, 'info');
            logActivity(`Reverse Mode: ${isReverseMode ? 'ON' : 'OFF'}`, isReverseMode ? 'success' : 'info');
            logActivity(`Alternator Mode: ${isAlternatorMode ? 'ON - BUY-SELL-BUY pattern enforced per market' : 'OFF'}`, isAlternatorMode ? 'success' : 'info');
            
            const activeFilters = [];
            if (oneCandleFilter) activeFilters.push('One Candle Mode (Single candle: Red=Buy, Green=Sell)');
            if (document.getElementById('zeroClosingFilter').checked) activeFilters.push('Zero Closing (Perfect 0)');
            if (document.getElementById('ignoreHeightFilter').checked) activeFilters.push('Ignore Height');
            if (document.getElementById('reverseCandleFilter').checked) activeFilters.push('Reverse Candle');
            
            if (activeFilters.length > 0) {
                logActivity(`Active filters: ${activeFilters.join(', ')}`, 'info');
            } else {
                logActivity('No filters active', 'info');
            }
            
            logActivity(`Waiting for ${requiredCandles} candle(s) before analyzing`, 'info');
            logActivity('‚úÖ FIXED: Trade execution order optimized', 'success');
            logActivity('‚úÖ FIXED: WebSocket check before signal display', 'success');
            logActivity('‚úÖ FIXED: Candle marked as traded before execution', 'success');
            logActivity('‚úÖ FIXED: Proper error handling for failed trades', 'success');
            logActivity('‚úÖ Skipped signals tracking enabled', 'success');
            logActivity('‚úÖ Alternator Mode: Per-market enforcement ACTIVE', 'success');

            updateCandleCounter();
            subscribeToActiveMarkets();

            if (candleWatchdogTimer) clearInterval(candleWatchdogTimer);
            
            let watchdogLastRun = 0;
            
            candleWatchdogTimer = setInterval(() => {
                const now = Date.now();
                
                if (now - watchdogLastRun < 1000) {
                    return;
                }
                watchdogLastRun = now;
                
                if (!isTimeSynced) return;
                
                const estimatedServerTime = Date.now() - serverTimeOffset;
                const currentServerMinute = Math.floor(estimatedServerTime / 1000 / 60) * 60;

                Object.keys(activeMarkets).forEach(symbol => {
                    if (!activeMarkets[symbol] || !marketSubscriptions[symbol]) return;
                    if (currentMinute[symbol] === undefined) return;

                    if (currentServerMinute > currentMinute[symbol] + 90) {
                        const lastPrice = currentOHLC[symbol].close;
                        logActivity(`‚ö†Ô∏è Forcing candle closure for ${markets[symbol]} (>90s delay)`, 'warning');
                        finalizeCandle(symbol, currentServerMinute, lastPrice);
                    }
                });
            }, 2000);

            saveSettings();
        }

        // Stop auto trading
        function stopAutoTrading() {
            isAutoTrading = false;
            activation_time = 0;
            
            document.getElementById('autoTradeBtn').textContent = 'Start Auto Trade';
            document.getElementById('autoTradeBtn').className = 'btn btn-success';
            
            const statusText = document.getElementById('statusText');
            const statusDot = document.getElementById('statusDot');
            statusText.textContent = 'Bot Inactive';
            statusText.className = 'status-text';
            statusDot.className = 'pulse-dot';

            logActivity('Auto trading stopped', 'error');

            unsubscribeFromAllMarkets();

            const container = document.getElementById('signalsContainer');
            container.innerHTML = '<div class="signal-item"><div class="signal-text">Waiting for bot activation...</div></div>';
            
            document.getElementById('candleCounter').classList.add('hidden');
            
            if (candleWatchdogTimer) {
                clearInterval(candleWatchdogTimer);
                candleWatchdogTimer = null;
            }

            saveSettings();
        }

        // Update reverse mode button
        function updateReverseModeButton() {
            const btn = document.getElementById('reverseModeBtn');
            if (isReverseMode) {
                btn.textContent = 'Reverse Mode: ON';
                btn.className = 'btn btn-warning';
            } else {
                btn.textContent = 'Reverse Mode: OFF';
                btn.className = 'btn btn-warning';
            }
        }

        // Update alternator mode button
        function updateAlternatorModeButton() {
            const btn = document.getElementById('alternatorModeBtn');
            if (isAlternatorMode) {
                btn.textContent = 'Alternator: ON';
                btn.className = 'btn btn-info';
            } else {
                btn.textContent = 'Alternator: OFF';
                btn.className = 'btn btn-info';
            }
        }

        // Auto trade button
        document.getElementById('autoTradeBtn').addEventListener('click', () => {
            if (isAutoTrading) {
                stopAutoTrading();
            } else {
                startAutoTrading();
            }
        });

        // Reverse mode button
        document.getElementById('reverseModeBtn').addEventListener('click', () => {
            isReverseMode = !isReverseMode;
            updateReverseModeButton();
            updateReverseModeIndicator();
            checkFilterConflicts();
            saveSettings();
            
            if (isReverseMode) {
                logActivity('Reverse Mode ENABLED: Buy signals will execute Sell, Sell signals will execute Buy', 'success');
            } else {
                logActivity('Reverse Mode DISABLED: Normal trading mode', 'info');
            }
        });

        // ALTERNATOR MODE button
        document.getElementById('alternatorModeBtn').addEventListener('click', () => {
            isAlternatorMode = !isAlternatorMode;
            updateAlternatorModeButton();
            updateAlternatorModeIndicator();
            checkFilterConflicts();
            
            if (isAlternatorMode) {
                resetAlternatorStates();
                logActivity('‚úÖ ALTERNATOR MODE ENABLED: BUY-SELL-BUY pattern enforced separately for each market', 'success');
                logActivity('[ALTERNATOR] Each market will alternate: CALL‚ÜíPUT‚ÜíCALL‚ÜíPUT...', 'success');
                logActivity('[ALTERNATOR] All markets reset to BUY (CALL) starting position', 'success');
            } else {
                logActivity('ALTERNATOR MODE DISABLED: Normal signal processing', 'info');
            }
            
            saveSettings();
        });

        // Clear history button with double-tap confirmation
        document.getElementById('clearHistoryBtn').addEventListener('click', () => {
            const btn = document.getElementById('clearHistoryBtn');
            
            if (!clearHistoryConfirmState) {
                clearHistoryConfirmState = true;
                btn.textContent = 'Are you sure?';
                btn.classList.add('confirm-state');
                logActivity('Click again to confirm clearing trade history', 'warning');
                
                clearHistoryTimeout = setTimeout(() => {
                    resetClearHistoryButton();
                    logActivity('Clear history cancelled', 'info');
                }, 3000);
            } else {
                clearTimeout(clearHistoryTimeout);
                
                tradeHistory = [];
                tradeStats = { total: 0, wins: 0, losses: 0, skipped: 0, profitLoss: 0 };
                processedContracts.clear();
                updateStats();
                updateTradeHistoryTable();
                saveSettings();
                
                logActivity('Trade history cleared successfully', 'success');
                resetClearHistoryButton();
            }
        });

        // Filter change listeners
        document.getElementById('zeroClosingFilter').addEventListener('change', () => {
            const enabled = document.getElementById('zeroClosingFilter').checked;
            logActivity(`Zero closing filter (Perfect 0) ${enabled ? 'enabled' : 'disabled'}`);
            saveSettings();
        });

        document.getElementById('ignoreHeightFilter').addEventListener('change', () => {
            const enabled = document.getElementById('ignoreHeightFilter').checked;
            logActivity(`Ignore height filter ${enabled ? 'enabled' : 'disabled'}`);
            checkFilterConflicts();
            saveSettings();
        });

        document.getElementById('oneCandleFilter').addEventListener('change', () => {
            const enabled = document.getElementById('oneCandleFilter').checked;
            logActivity(`One Candle filter ${enabled ? 'enabled (Single candle: Red=Buy, Green=Sell)' : 'disabled'}`);
            updateOneCandleIndicator();
            checkFilterConflicts();
            if (isAutoTrading) {
                updateCandleCounter();
            }
            saveSettings();
        });

        document.getElementById('reverseCandleFilter').addEventListener('change', () => {
            const enabled = document.getElementById('reverseCandleFilter').checked;
            logActivity(`Reverse Candle filter ${enabled ? 'enabled' : 'disabled'}`);
            saveSettings();
        });

        document.getElementById('autoRefreshFilter').addEventListener('change', () => {
            const enabled = document.getElementById('autoRefreshFilter').checked;
            
            if (enabled) {
                const interval = document.getElementById('refreshInterval').value;
                logActivity(`Auto-refresh filter enabled (${interval} hour(s))`, 'success');
                
                if (isLoggedIn) {
                    startAutoRefresh();
                } else {
                    logActivity('Auto-refresh will start after login', 'info');
                }
            } else {
                logActivity('Auto-refresh filter disabled', 'info');
                stopAutoRefresh();
            }
            
            saveSettings();
        });

        document.getElementById('refreshInterval').addEventListener('change', () => {
            const interval = document.getElementById('refreshInterval').value;
            logActivity(`Auto-refresh interval updated to ${interval} hour(s)`);
            saveSettings();
            
            if (document.getElementById('autoRefreshFilter').checked && isLoggedIn) {
                stopAutoRefresh();
                startAutoRefresh();
            }
        });

        // Duration type radio button listeners
        document.getElementsByName('durationType').forEach(radio => {
            radio.addEventListener('change', () => {
                const typeLabels = { 't': 'Ticks', 's': 'Seconds', 'm': 'Minutes' };
                logActivity(`Duration type updated to ${typeLabels[radio.value]}`);
                saveSettings();
            });
        });
    
        // Settings change listeners
        document.getElementById('stakeAmount').addEventListener('change', () => {
            logActivity(`Stake amount updated to ${document.getElementById('stakeAmount').value}`);
            saveSettings();
        });

        document.getElementById('stopLoss').addEventListener('change', () => {
            logActivity(`Stop loss updated to ${document.getElementById('stopLoss').value}`);
            saveSettings();
        });

        document.getElementById('takeProfit').addEventListener('change', () => {
            logActivity(`Take profit updated to ${document.getElementById('takeProfit').value}`);
            saveSettings();
        });

        document.getElementById('durationValue').addEventListener('change', () => {
            logActivity(`Duration value updated to ${document.getElementById('durationValue').value}`);
            saveSettings();
        });

        document.getElementById('minLowerWickBuy').addEventListener('blur', saveSettings);
        document.getElementById('minUpperWickSell').addEventListener('blur', saveSettings);
        document.getElementById('minUpperWickBuy').addEventListener('blur', saveSettings);
        document.getElementById('minLowerWickSell').addEventListener('blur', saveSettings);
        document.getElementById('matchingDiffBuy').addEventListener('blur', saveSettings);
        document.getElementById('matchingDiffSell').addEventListener('blur', saveSettings);

        // Monitor WebSocket health
        function checkWebSocketHealth() {
            if (isLoggedIn && ws && ws.readyState === WebSocket.OPEN) {
                const timeSinceLastMessage = Date.now() - lastHeartbeat;
                
                if (timeSinceLastMessage > 30000) {
                    ws.send(JSON.stringify({ ping: 1 }));
                }

                if (timeSinceLastMessage > 60000) {
                    logActivity('No response from server. Connection may be lost.', 'warning');
                }
            }
        }

        setInterval(checkWebSocketHealth, 10000);

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveSettings();
                logActivity('Settings saved manually', 'success');
            }

            if ((e.ctrlKey || e.metaKey) && e.key === ' ') {
                e.preventDefault();
                if (isLoggedIn && document.getElementById('autoTradeBtn').disabled === false) {
                    if (isAutoTrading) {
                        stopAutoTrading();
                    } else {
                        startAutoTrading();
                    }
                }
            }
        });

        // Visual connection status
        function updateConnectionStatus() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                document.body.style.borderTop = '3px solid #ff4757';
            } else {
                document.body.style.borderTop = '3px solid #2ecc71';
            }
        }

        setInterval(updateConnectionStatus, 1000);

        // Network status monitoring
        window.addEventListener('online', () => {
            logActivity('Network connection restored', 'success');
            updateConnectionBadge('connected');
            
            if (isLoggedIn && (!ws || ws.readyState !== WebSocket.OPEN)) {
                const token = sessionStorage.getItem('derivToken');
                if (token) {
                    logActivity('Attempting to reconnect...', 'info');
                    connectWebSocket(token, true).catch(err => {
                        logActivity('Reconnection failed', 'error');
                    });
                }
            }
        });

        window.addEventListener('offline', () => {
            logActivity('Network connection lost!', 'error');
            updateConnectionBadge('disconnected');
            
            if (sessionTimer) {
                stopSessionTimer();
                logActivity('Session timer reset due to network failure', 'warning');
            }
        });

        // Auto-reconnect on page refresh/reload
        window.addEventListener('beforeunload', () => {
            saveSettings();
        });

        window.addEventListener('load', () => {
            handlePostRefreshRecovery();
            
            const savedToken = sessionStorage.getItem('derivToken');
            const wasAutoTrading = sessionStorage.getItem('wasAutoTrading') === 'true';
            
            if (savedToken && !isLoggedIn) {
                document.getElementById('apiToken').value = savedToken;
                logActivity('Saved token found. Auto-login in 0.5s...', 'info');
                
                setTimeout(() => {
                    document.getElementById('loginBtn').click();
                    
                    if (wasAutoTrading) {
                        setTimeout(() => {
                            if (isLoggedIn && !isAutoTrading) {
                                logActivity('Resuming auto trading after refresh...', 'info');
                                startAutoTrading();
                            }
                        }, 2000);
                    }
                }, 500);
            }
        });

        // Error boundaries
        window.addEventListener('error', (e) => {
            logActivity(`Unexpected error: ${e.message}`, 'error');
            console.error('Error details:', e);
        });

        window.addEventListener('unhandledrejection', (e) => {
            logActivity(`Unhandled promise rejection: ${e.reason}`, 'error');
            console.error('Promise rejection details:', e);
        });

        // Export trade history
        window.exportTradeHistory = function() {
            if (tradeHistory.length === 0) {
                logActivity('No trade history to export', 'error');
                return;
            }

            const csv = [
                ['S/N', 'Time', 'Market', 'Type', 'Stake', 'Result'],
                ...tradeHistory.map((trade, index) => [
                    index + 1,
                    trade.time,
                    trade.market,
                    trade.type,
                    trade.stake,
                    trade.result
                ])
            ].map(row => row.join(',')).join('\n');

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ben-sniper-trades-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            URL.revokeObjectURL(url);

            logActivity('Trade history exported successfully', 'success');
        };

        // Initialize app
        loadSettings();
        renderMarkets();
        logActivity('System initialized. Please login to continue.', 'success');
        
        // FLOATING BROWSER FIX: Log visibility changes but don't pause trading
        document.addEventListener('visibilitychange', () => {
            const wasVisible = isPageVisible;
            isPageVisible = !document.hidden;
            lastVisibilityChange = Date.now();
            
            if (isPageVisible && !wasVisible) {
                logActivity('üîÑ Browser window restored', 'info');
            } else if (!isPageVisible && wasVisible) {
                logActivity('‚è∏Ô∏è Browser window minimized (still active)', 'info');
            }
        });

        // Log system information
        logActivity(`Browser: ${navigator.userAgent}`, 'info');
        logActivity(`Available markets: ${Object.keys(markets).length}`, 'info');

        // Log startup complete
        setTimeout(() => {
            logActivity('Ben Sniper Bot initialized successfully!', 'success');
            logActivity('‚úÖ CRITICAL FIX: Trade execution order completely optimized', 'success');
            logActivity('‚úÖ FIX #1: Candle traded check happens FIRST', 'success');
            logActivity('‚úÖ FIX #2: WebSocket validation BEFORE marking candle', 'success');
            logActivity('‚úÖ FIX #3: Candle marked as traded BEFORE execution', 'success');
            logActivity('‚úÖ FIX #4: Signal display only after validation', 'success');
            logActivity('‚úÖ FIX #5: Proper async/await error handling', 'success');
            logActivity('‚úÖ Skipped signals now tracked in statistics', 'success');
            logActivity('‚úÖ Alternator Mode: Per-market BUY-SELL-BUY enforcement', 'success');
            logActivity('‚úÖ Trade history: Duplicate prevention enabled', 'success');
            logActivity('‚úÖ Floating browser: Race condition prevention active', 'success');
            logActivity('Features: One Candle, Zero Closing, Ignore Height, Reverse Candle, Auto-Refresh, Alternator', 'success');
            logActivity('Modes: TWO CANDLE (Tweezers) or ONE CANDLE (Single candle pattern)', 'success');
            logActivity('Signal Flow: Check Already Traded ‚Üí Validate WS ‚Üí Mark Traded ‚Üí Display Signal ‚Üí Execute Trade', 'success');
            logActivity('Auto-Reconnect: Enabled with exponential backoff', 'success');
            logActivity('Tip: Press Ctrl+Space to toggle auto trading', 'info');
            logActivity('Tip: Use exportTradeHistory() in console to export trades', 'info');
            logActivity('App ID: 116948 | All systems operational', 'success');
        }, 1000);
    </script>
</body>
</html>