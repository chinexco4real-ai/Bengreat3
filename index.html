<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Deriv Digit Over 5 Pro - Advanced ML Edition v3 (PSF + LSTM)</title>
<style>
/* --- STYLES PRESERVED --- */
body { background: #020617; color: #e5e7eb; font-family: system-ui, -apple-system, sans-serif; margin: 0; padding: 0; }
.app { max-width: 420px; margin: auto; padding: 15px; }
.card { background: #0f172a; padding: 12px; border-radius: 12px; margin-bottom: 12px; border: 1px solid #1e293b; }
h2, h3 { text-align: center; margin-bottom: 8px; margin-top: 8px; }
h2 { color: #22c55e; }
label { font-size: 13px; opacity: 0.8; display: block; margin-top: 8px; }
input, select, button { width: 100%; padding: 10px; margin: 5px 0 10px; border-radius: 8px; border: none; box-sizing: border-box; }
input, select { background: #1e293b; color: #e5e7eb; border: 1px solid #334155; }
input:focus, select:focus { outline: none; border-color: #22c55e; }
button { background: #22c55e; color: #020617; font-weight: 700; cursor: pointer; transition: all 0.2s; }
button:hover { background: #16a34a; transform: translateY(-1px); }
button:active { transform: translateY(0); }
button:disabled { background: #374151; cursor: not-allowed; opacity: 0.5; }
.buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 12px; }
.status-container { display: flex; gap: 5px; margin-bottom: 10px; }
.status { flex: 2; text-align: center; padding: 8px; border-radius: 8px; font-weight: 600; }
.account-type { flex: 1.5; text-align: center; padding: 8px; border-radius: 8px; font-weight: 700; font-size: 11px; display: none; text-transform: uppercase; align-self: center; }
.demo-badge { background: #f59e0b; color: #020617; }
.live-badge { background: #22c55e; color: #020617; }
.connected { background: #16a34a; color: white; }
.disconnected { background: #dc2626; color: white; }
.stats { display: grid; grid-template-columns: repeat(4, 1fr); text-align: center; gap: 10px; }
.stats > div { display: flex; flex-direction: column; gap: 5px; }
.stats span { font-size: 12px; opacity: 0.7; }
.stats b { font-size: 16px; color: #22c55e; }
.table-container { overflow-x: auto; max-height: 300px; overflow-y: auto; }
table { width: 100%; font-size: 13px; border-collapse: collapse; }
thead { position: sticky; top: 0; background: #1e293b; }
th { padding: 8px; text-align: left; font-weight: 600; border-bottom: 2px solid #334155; }
td { padding: 8px; border-bottom: 1px solid #1e293b; }
tbody tr:hover { background: #1e293b; }
.win { color: #22c55e; }
.loss { color: #ef4444; }
.balance-display { text-align: center; padding: 10px; background: #0f172a; border-radius: 8px; margin-bottom: 10px; border: 1px solid #1e293b; }
.balance-display span { opacity: 0.7; font-size: 14px; }
.balance-display b { color: #22c55e; font-size: 18px; margin: 0 5px; }
.session-timer { margin-top: 8px; font-size: 12px; color: #f59e0b; font-weight: 600; }
.shutdown-timer { font-size: 12px; color: #ef4444; font-weight: 700; margin-top: 4px; display: none; }
.reset-button-permanent { background: #f59e0b !important; width: 100%; margin-bottom: 12px; font-size: 15px; display: block; }
.reset-button-permanent:hover { background: #d97706 !important; }
.analyzer-grid { display: grid; grid-template-columns: repeat(10, 1fr); gap: 5px; margin: 10px 0; }
.digit-box { aspect-ratio: 1; display: flex; align-items: center; justify-content: center; border-radius: 6px; font-weight: 700; font-size: 14px; border: 2px solid transparent; }
.digit-over { background: #22c55e; color: #020617; }
.digit-under { background: #ef4444; color: white; }
.analyzer-stats { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; text-align: center; margin-top: 10px; }
.analyzer-stats > div { background: #1e293b; padding: 8px; border-radius: 6px; }
.analyzer-stats span { font-size: 11px; opacity: 0.7; display: block; }
.analyzer-stats b { font-size: 18px; display: block; margin-top: 3px; }
.log-container { background: #020617; border: 1px solid #1e293b; border-radius: 6px; height: 120px; overflow-y: auto; padding: 8px; font-family: 'Courier New', monospace; font-size: 11px; margin-top: 10px; }
.log-entry { margin-bottom: 4px; border-bottom: 1px solid #1e293b; padding-bottom: 2px; }
.log-time { color: #94a3b8; margin-right: 5px; }
.log-msg-info { color: #3b82f6; }
.log-msg-success { color: #22c55e; }
.log-msg-error { color: #ef4444; }
.log-msg-warn { color: #f59e0b; }
.btn-cycle { background: #3b82f6; color: white; margin-bottom: 5px; font-size: 14px; }
.btn-cycle.active { background: #8b5cf6; border: 2px solid #fff; }
.btn-cooldown { background: #475569; color: white; margin-bottom: 5px; font-size: 14px; }
.btn-cooldown.active { background: #f59e0b; color: #020617; border: 2px solid #020617; }
.btn-reverse { background: #334155; color: white; margin-bottom: 12px; font-size: 14px; }
.btn-reverse.active { background: #f43f5e; }
.cycle-timer-display { color: #f59e0b; font-size: 13px; font-weight: bold; text-align: center; margin-bottom: 10px; display: none; padding: 8px; border: 2px dashed #f59e0b; border-radius: 8px; background: rgba(245, 158, 11, 0.1); }
.specific-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-bottom: 10px; }
.specific-grid input { text-align: center; padding: 8px 0; margin: 0; }
.window-timer { margin-top: 10px; font-size: 12px; text-align: center; font-weight: 800; padding: 8px; border-radius: 6px; background: #020617; border: 2px solid #334155; transition: all 0.3s; }

/* Sequence UI Styles */
.sequence-slot { background: #1e293b; border: 1px solid #334155; border-radius: 8px; padding: 10px; margin-bottom: 10px; }
.sequence-slot-title { font-size: 11px; font-weight: 700; color: #3b82f6; margin-bottom: 5px; text-transform: uppercase; }
.seq-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; }
.seq-grid input { font-size: 11px; padding: 5px; margin: 0; }

/* ML Enhancement Styles */
.ml-indicator { display: inline-block; padding: 3px 8px; border-radius: 4px; font-size: 10px; font-weight: 700; margin-left: 5px; }
.ml-learning { background: #8b5cf6; color: white; }
.ml-active { background: #22c55e; color: #020617; }
.advanced-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 8px; font-size: 10px; }
.advanced-stats > div { background: #020617; padding: 5px; border-radius: 4px; text-align: center; }

/* Radio Button Styles */
.radio-group { margin: 10px 0; }
.radio-option { display: flex; align-items: center; padding: 8px; margin: 5px 0; background: #1e293b; border-radius: 6px; cursor: pointer; border: 2px solid #334155; transition: all 0.2s; }
.radio-option:hover { border-color: #22c55e; background: #1e3a2b; }
.radio-option input[type="radio"] { margin-right: 10px; cursor: pointer; width: auto; }
.radio-option.selected { border-color: #22c55e; background: #1e3a2b; }
.radio-option label { cursor: pointer; margin: 0; opacity: 1; font-size: 13px; font-weight: 600; width: 100%; }

/* Pattern Mode UI */
.pattern-target-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-top: 10px; }
.pattern-target-grid input { text-align: center; padding: 8px; margin: 0; background: #0f172a; border: 2px solid #8b5cf6; }
.pattern-mode-active { background: #8b5cf6; padding: 8px; border-radius: 6px; text-align: center; margin: 10px 0; font-weight: 700; color: white; }
.ensemble-filter-box { background: #0f172a; border: 2px solid #f59e0b; border-radius: 6px; padding: 10px; margin-top: 10px; }
.ensemble-filter-box label { color: #f59e0b; font-weight: 700; font-size: 12px; }
.ensemble-status { text-align: center; font-size: 11px; margin-top: 5px; padding: 5px; border-radius: 4px; background: #1e293b; }
.ensemble-filter-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px; }
.filter-warning { background: #ef4444; color: white; padding: 6px; border-radius: 4px; text-align: center; font-size: 10px; font-weight: 700; margin-top: 5px; display: none; }

/* Toggle Switch Styles */
.toggle-container { display: flex; align-items: center; justify-content: space-between; padding: 10px; background: #1e293b; border-radius: 6px; margin: 10px 0; border: 2px solid #334155; }
.toggle-label { font-size: 13px; font-weight: 700; color: #e5e7eb; }
.toggle-switch { position: relative; width: 50px; height: 26px; }
.toggle-switch input { opacity: 0; width: 0; height: 0; }
.toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #334155; border-radius: 34px; transition: .4s; }
.toggle-slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 4px; bottom: 4px; background-color: white; border-radius: 50%; transition: .4s; }
.toggle-switch input:checked + .toggle-slider { background-color: #22c55e; }
.toggle-switch input:checked + .toggle-slider:before { transform: translateX(24px); }

/* Specific Ensemble Percentages */
.specific-ensemble-section { background: #0f172a; border: 2px solid #8b5cf6; border-radius: 6px; padding: 10px; margin-top: 10px; display: none; }
.specific-ensemble-section.active { display: block; }
.specific-ensemble-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-top: 8px; }
.specific-ensemble-grid input { text-align: center; padding: 8px; margin: 0; background: #1e293b; border: 2px solid #8b5cf6; }

/* Model Performance Indicators */
.model-performance { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 5px; margin-top: 8px; font-size: 10px; }
.model-performance > div { background: #1e293b; padding: 5px; border-radius: 4px; text-align: center; border: 1px solid #334155; }
.model-perf-high { border-color: #22c55e; }
.model-perf-low { border-color: #ef4444; }

/* Virtual Trade Styles */
.virtual-trade-container { background: #1e293b; border: 2px solid #8b5cf6; border-radius: 8px; padding: 10px; margin-bottom: 12px; }
.virtual-trade-header { font-size: 13px; font-weight: 700; color: #8b5cf6; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
.virtual-trade-status { background: #8b5cf6; color: white; padding: 6px 10px; border-radius: 6px; text-align: center; font-size: 11px; font-weight: 700; margin-top: 8px; display: none; }
.virtual-trade-status.active { display: block; }
.virtual-trade-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px; }
.virtual-trade-stats > div { background: #0f172a; padding: 6px; border-radius: 4px; text-align: center; }
.virtual-trade-stats span { font-size: 10px; opacity: 0.7; display: block; }
.virtual-trade-stats b { font-size: 14px; display: block; margin-top: 2px; color: #8b5cf6; }
.switch-notice { background: #22c55e; color: #020617; padding: 6px; border-radius: 4px; text-align: center; font-size: 11px; font-weight: 700; margin-top: 8px; display: none; }
.switch-notice.active { display: block; }

/* LSTM Training Status */
.lstm-status { background: #0f172a; border: 2px solid #8b5cf6; border-radius: 6px; padding: 8px; margin-top: 10px; }
.lstm-status-header { font-size: 11px; font-weight: 700; color: #8b5cf6; margin-bottom: 5px; }
.lstm-progress { background: #1e293b; border-radius: 4px; height: 20px; overflow: hidden; margin-top: 5px; }
.lstm-progress-bar { background: linear-gradient(90deg, #8b5cf6, #22c55e); height: 100%; transition: width 0.3s; }
.lstm-stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 8px; font-size: 10px; }
.lstm-stats-grid > div { background: #1e293b; padding: 5px; border-radius: 4px; text-align: center; }
</style>
</head>
<body>
<div class="app">

<h2>Deriv Digit Over 5 Pro <span class="ml-indicator ml-active">ML Enhanced v3 (PSF+LSTM)</span></h2>

<div class="status-container">
    <div id="status" class="status disconnected">Disconnected</div>
    <div id="accountType" class="account-type"></div>
</div>

<div id="balanceDisplay" class="balance-display" style="display:none;">
  <span>Balance:</span>
  <b id="balance">0.00</b>
  <span id="balanceCurrency">USD</span>
  <div id="sessionTimer" class="session-timer">Session: 00:00:00</div>
  <div id="shutdownDisplay" class="shutdown-timer">Shutdown in: --:--:--</div>
</div>

<div class="card">
  <input id="token" type="password" placeholder="Deriv API Token" required>
  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <button onclick="connect()">Login</button>
    <button id="logoutBtn" style="background: #ef4444;">Logout</button>
  </div>
</div>

<!-- Virtual Trade Feature -->
<div class="virtual-trade-container">
  <div class="virtual-trade-header">
    üéÆ Virtual Trade Mode
  </div>
  
  <div class="toggle-container" style="margin: 0;">
    <span class="toggle-label">Enable Virtual Trade First</span>
    <label class="toggle-switch">
      <input type="checkbox" id="virtualTradeToggle" onchange="toggleVirtualTrade()">
      <span class="toggle-slider"></span>
    </label>
  </div>
  
  <div id="virtualTradeSettings" style="display: none; margin-top: 10px;">
    <label>Consecutive Losses to Switch to Live</label>
    <input id="virtualLossThreshold" class="save-setting" type="number" value="3" min="1" max="20">
    
    <div class="virtual-trade-stats">
      <div>
        <span>Virtual Losses</span>
        <b id="virtualLossCount">0</b>
      </div>
      <div>
        <span>Threshold</span>
        <b id="virtualThresholdDisplay">3</b>
      </div>
    </div>
    
    <div class="virtual-trade-status" id="virtualTradeStatus">
      üéÆ Trading on VIRTUAL account
    </div>
    
    <div class="switch-notice" id="switchNotice">
      ‚ö†Ô∏è Switched to LIVE account after hitting loss threshold!
    </div>
  </div>
</div>

<div class="card">
  <h3>üìä Advanced ML Analyzer v3 (PSF + LSTM)</h3>
  <div class="analyzer-grid" id="digitDisplay"></div>
  <div class="analyzer-stats">
    <div><span>Over 5</span><b id="overCount" style="color: #22c55e;">0</b></div>
    <div><span>Total Ticks</span><b id="totalCount" style="color: #e5e7eb;">0</b></div>
    <div><span>Over %</span><b id="overPercent" style="color: #22c55e;">0%</b></div>
  </div>
  
  <!-- LSTM Training Status -->
  <div class="lstm-status">
    <div class="lstm-status-header">üß† LSTM Neural Network Status</div>
    <div style="font-size: 10px; opacity: 0.7;" id="lstmStatusText">Not Initialized</div>
    <div class="lstm-progress">
      <div class="lstm-progress-bar" id="lstmProgressBar" style="width: 0%;"></div>
    </div>
    <div class="lstm-stats-grid">
      <div><span style="opacity:0.6">Training Loss</span><b id="lstmLoss" style="color:#8b5cf6">--</b></div>
      <div><span style="opacity:0.6">LSTM Accuracy</span><b id="lstmAccuracy" style="color:#22c55e">--%</b></div>
      <div><span style="opacity:0.6">Samples Trained</span><b id="lstmSamples" style="color:#3b82f6">0</b></div>
      <div><span style="opacity:0.6">Last Retrain</span><b id="lstmLastRetrain" style="color:#f59e0b">Never</b></div>
    </div>
  </div>
  
  <div style="margin-top: 10px; padding: 12px; background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); border-radius: 8px; border: 2px solid #22c55e;">
    <div style="font-size: 14px; font-weight: 700; margin-bottom: 10px; color: #22c55e;">üîÆ ML Prediction Engine v3</div>
    
    <div id="signalTimerDisplay" class="window-timer">SYNCING CLOCK...</div>

    <div style="background: #0f172a; padding: 10px; border-radius: 6px; margin-bottom: 8px; margin-top: 8px;">
      <div style="font-size: 11px; opacity: 0.7; margin-bottom: 5px;">Next Digit Prediction:</div>
      <div style="font-size: 24px; font-weight: 700; text-align: center;" id="nextDigitPrediction">-</div>
      <div style="font-size: 11px; text-align: center; margin-top: 5px;" id="predictionConfidence">-</div>
    </div>
    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; font-size: 11px;">
      <div style="background: #1e293b; padding: 6px; border-radius: 4px; text-align: center;"><div>Freq Bias</div><b id="freqScore" style="color: #22c55e;">0%</b></div>
      <div style="background: #1e293b; padding: 6px; border-radius: 4px; text-align: center;"><div>Gap Count</div><b id="cycleScore" style="color: #3b82f6;">0</b></div>
      <div style="background: #1e293b; padding: 6px; border-radius: 4px; text-align: center;"><div>Volatility</div><b id="volatilityScore" style="color: #f59e0b;">Low</b></div>
    </div>
    
    <div class="advanced-stats">
      <div><span style="opacity:0.6">Bayesian Prob</span><b id="bayesianProb" style="color:#8b5cf6">50%</b></div>
      <div><span style="opacity:0.6">Markov Pred</span><b id="markovProb" style="color:#3b82f6">50%</b></div>
      <div><span style="opacity:0.6">PSF Forecast</span><b id="psfScore" style="color:#f59e0b">50%</b></div>
      <div><span style="opacity:0.6">LSTM Pred</span><b id="lstmPred" style="color:#8b5cf6">50%</b></div>
      <div><span style="opacity:0.6">Ensemble</span><b id="ensembleScore" style="color:#22c55e">50%</b></div>
      <div><span style="opacity:0.6">Confidence Adj</span><b id="confAdj" style="color:#f59e0b">0%</b></div>
    </div>
    
    <div class="model-performance">
      <div id="heuristicPerf"><span style="opacity:0.6">Heuristic</span><b style="color:#22c55e">--%</b></div>
      <div id="bayesianPerf"><span style="opacity:0.6">Bayesian</span><b style="color:#8b5cf6">--%</b></div>
      <div id="markovPerf"><span style="opacity:0.6">Markov</span><b style="color:#3b82f6">--%</b></div>
      <div id="psfPerf"><span style="opacity:0.6">PSF</span><b style="color:#f59e0b">--%</b></div>
    </div>
    
    <div style="margin-top: 8px; font-size: 11px; opacity: 0.7; text-align: center;" id="patternMatch">Analyzing patterns...</div>
    
    <div style="margin-top: 15px; border-top: 1px solid #334155; padding-top: 10px;">
        <div style="font-size: 12px; font-weight: 600; color: #94a3b8; display: flex; justify-content: space-between;">
            <span>SYSTEM & TRADE LOG</span>
            <span style="cursor:pointer; color:#3b82f6" onclick="document.getElementById('logContainer').innerHTML=''">Clear</span>
        </div>
        <div class="log-container" id="logContainer">
            <div class="log-entry"><span class="log-time">[System]</span> <span class="log-msg-success">ML Engine v3 Ready (PSF + LSTM).</span></div>
        </div>
    </div>
  </div>
</div>

<div class="card">
  <h3>Trade Settings</h3>
  <label>Stake ($)</label>
  <input id="stake" class="save-setting" type="number" value="1" min="0.35" step="0.01">
  <label>Duration (Ticks)</label>
  <input id="duration" class="save-setting" type="number" value="1" min="1" max="10">
  <label>Cooldown (seconds)</label>
  <input id="cooldown" class="save-setting" type="number" value="2" min="1">
  
  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
      <label>Window: Closing (Sec)</label>
      <input id="closingSec" class="save-setting" type="number" value="10" min="1" max="59">
    </div>
    <div>
      <label>Window: Opening (Sec)</label>
      <input id="openingSec" class="save-setting" type="number" value="10" min="1" max="59">
    </div>
  </div>

  <label>Confidence Selection Mode</label>
  <div class="radio-group" id="confidenceModeRadios">
      <div class="radio-option" onclick="selectConfidenceMode('range')">
          <input type="radio" name="confidenceMode" value="range" id="modeRange" checked>
          <label for="modeRange">Mode 1: Range (Min-Max)</label>
      </div>
      <div class="radio-option" onclick="selectConfidenceMode('specific')">
          <input type="radio" name="confidenceMode" value="specific" id="modeSpecific">
          <label for="modeSpecific">Mode 2: Specific Numbers (Pick 5)</label>
      </div>
      <div class="radio-option" onclick="selectConfidenceMode('sequence')">
          <input type="radio" name="confidenceMode" value="sequence" id="modeSequence">
          <label for="modeSequence">Mode 3: Sequence Pattern (3 Slots)</label>
      </div>
      <div class="radio-option" onclick="selectConfidenceMode('pattern')">
          <input type="radio" name="confidenceMode" value="pattern" id="modePattern">
          <label for="modePattern">Mode 4: Pattern Detection (Next Likely Digit)</label>
      </div>
  </div>

  <div id="rangeUI">
      <label>Confidence Range (Min - Max %)</label>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
        <input id="minConfidence" class="save-setting" type="number" value="55" min="0" max="100" placeholder="Min">
        <input id="maxConfidence" class="save-setting" type="number" value="70" min="0" max="100" placeholder="Max">
      </div>
  </div>

  <div id="specificUI" style="display:none;">
      <label>Specific Target Numbers</label>
      <div class="specific-grid">
          <input id="spec1" class="save-setting" type="number" value="10" min="0" max="100">
          <input id="spec2" class="save-setting" type="number" value="25" min="0" max="100">
          <input id="spec3" class="save-setting" type="number" value="49" min="0" max="100">
          <input id="spec4" class="save-setting" type="number" value="50" min="0" max="100">
          <input id="spec5" class="save-setting" type="number" value="65" min="0" max="100">
      </div>
  </div>

  <div id="sequenceUI" style="display:none;">
      <label>Sequence Slots Logic</label>
      
      <div class="sequence-slot">
          <div class="sequence-slot-title">Slot 1</div>
          <div class="seq-grid">
              <div><span style="font-size:9px">1st Pred >=</span><input id="s1_p1_min" class="save-setting" type="number" value="40"></div>
              <div><span style="font-size:9px">2nd Pred >=</span><input id="s1_p2_min" class="save-setting" type="number" value="50"></div>
              <div><span style="font-size:9px">2nd Pred <=</span><input id="s1_p2_max" class="save-setting" type="number" value="98"></div>
          </div>
    </div>

      <div class="sequence-slot">
          <div class="sequence-slot-title">Slot 2</div>
          <div class="seq-grid">
              <div><span style="font-size:9px">1st Pred >=</span><input id="s2_p1_min" class="save-setting" type="number" value="15"></div>
              <div><span style="font-size:9px">2nd Pred >=</span><input id="s2_p2_min" class="save-setting" type="number" value="60"></div>
              <div><span style="font-size:9px">2nd Pred <=</span><input id="s2_p2_max" class="save-setting" type="number" value="98"></div>
          </div>
      </div>

      <div class="sequence-slot">
          <div class="sequence-slot-title">Slot 3</div>
          <div class="seq-grid">
              <div><span style="font-size:9px">1st Pred >=</span><input id="s3_p1_min" class="save-setting" type="number" value="50"></div>
              <div><span style="font-size:9px">2nd Pred >=</span><input id="s3_p2_min" class="save-setting" type="number" value="50"></div>
              <div><span style="font-size:9px">2nd Pred <=</span><input id="s3_p2_max" class="save-setting" type="number" value="98"></div>
          </div>
      </div>
  </div>

  <div id="patternUI" style="display:none;">
      <div class="pattern-mode-active">üéØ Pattern Detection Mode Active</div>
      <label>Target Digits for Pattern Match (0-9)</label>
      <div class="pattern-target-grid">
          <input id="pattern1" class="save-setting" type="number" value="0" min="0" max="9" placeholder="Digit 1">
          <input id="pattern2" class="save-setting" type="number" value="1" min="0" max="9" placeholder="Digit 2">
          <input id="pattern3" class="save-setting" type="number" value="6" min="0" max="9" placeholder="Digit 3">
          <input id="pattern4" class="save-setting" type="number" value="7" min="0" max="9" placeholder="Digit 4">
          <input id="pattern5" class="save-setting" type="number" value="8" min="0" max="9" placeholder="Digit 5">
      </div>
      <div style="font-size: 11px; opacity: 0.7; margin-top: 8px; text-align: center;">
          Bot will trade when pattern's "Next Likely" digit matches any of the above targets
      </div>
      
      <div class="ensemble-filter-box">
          <label>‚ö° Next Likely % Filter (Use ONE at a time)</label>
          <div class="ensemble-filter-grid">
              <div>
                  <span style="font-size: 10px; opacity: 0.7; display: block; margin-bottom: 3px;">Trade if ‚â§ (Less/Equal)</span>
                  <input id="patternEnsembleMax" class="save-setting ensemble-filter-input" type="number" value="0" min="0" max="100" placeholder="0 = OFF">
              </div>
              <div>
                  <span style="font-size: 10px; opacity: 0.7; display: block; margin-bottom: 3px;">Trade if ‚â• (Greater/Equal)</span>
                  <input id="patternEnsembleMin" class="save-setting ensemble-filter-input" type="number" value="0" min="0" max="100" placeholder="0 = OFF">
              </div>
          </div>
          <div class="filter-warning" id="filterWarning">
              ‚ö†Ô∏è Cannot use multiple filters! Only ONE can be active
          </div>
          <div class="ensemble-status" id="ensembleFilterStatus">
              All filters disabled - Trading on pattern match only
          </div>
          <div style="font-size: 10px; opacity: 0.6; margin-top: 8px; line-height: 1.4;">
              üìå <strong>Quick Guide:</strong><br>
              <strong>‚â§ (Max):</strong> Trade when Next Likely % is LOW (0 = OFF)<br>
              <strong>‚â• (Min):</strong> Trade when Next Likely % is HIGH (0 = OFF)<br>
              <strong>‚ö†Ô∏è Only ONE filter active at a time</strong>
          </div>
      </div>
      
      <!-- Specific Ensemble Percentages Toggle -->
      <div class="toggle-container">
          <span class="toggle-label">üìä Specific Next Likely % Filter</span>
          <label class="toggle-switch">
              <input type="checkbox" id="specificEnsembleToggle" onchange="toggleSpecificEnsemble()">
              <span class="toggle-slider"></span>
          </label>
      </div>
      
      <div class="specific-ensemble-section" id="specificEnsembleSection">
          <label style="color: #8b5cf6; font-weight: 700; font-size: 12px; margin-bottom: 8px; display: block;">
              üéØ Specific Next Likely Percentages (Pick up to 5)
          </label>
          <div class="specific-ensemble-grid">
              <input id="specEns1" class="save-setting" type="number" value="25" min="0" max="100" placeholder="%1">
              <input id="specEns2" class="save-setting" type="number" value="50" min="0" max="100" placeholder="%2">
              <input id="specEns3" class="save-setting" type="number" value="65" min="0" max="100" placeholder="%3">
              <input id="specEns4" class="save-setting" type="number" value="75" min="0" max="100" placeholder="%4">
              <input id="specEns5" class="save-setting" type="number" value="85" min="0" max="100" placeholder="%5">
          </div>
          <div style="text-align: center; font-size: 11px; margin-top: 8px; padding: 6px; background: #1e293b; border-radius: 4px;" id="specificEnsembleStatus">
              Trade only when Next Likely % matches these specific values
          </div>
          <div style="font-size: 10px; opacity: 0.6; margin-top: 8px; line-height: 1.4;">
              üí° Example: If you set 25, 50, 75 - bot will ONLY trade when Next Likely % is exactly 25%, 50%, or 75%
          </div>
      </div>
  </div>

  <label>Market</label>
  <div class="radio-group" id="marketRadios">
      <div class="radio-option" onclick="selectMarket('R_10')">
          <input type="radio" name="market" value="R_10" id="marketR10" checked>
          <label for="marketR10">R_10</label>
      </div>
      <div class="radio-option" onclick="selectMarket('R_25')">
          <input type="radio" name="market" value="R_25" id="marketR25">
          <label for="marketR25">R_25</label>
      </div>
      <div class="radio-option" onclick="selectMarket('R_50')">
          <input type="radio" name="market" value="R_50" id="marketR50">
          <label for="marketR50">R_50</label>
      </div>
      <div class="radio-option" onclick="selectMarket('R_75')">
          <input type="radio" name="market" value="R_75" id="marketR75">
          <label for="marketR75">R_75</label>
      </div>
      <div class="radio-option" onclick="selectMarket('R_100')">
          <input type="radio" name="market" value="R_100" id="marketR100">
          <label for="marketR100">R_100</label>
      </div>
  </div>
</div>

<div class="card">
  <h3>Risk Management</h3>
  <label>Stop Loss ($)</label>
  <input id="stoploss" class="save-setting" type="number" value="10" min="1">
  <label>Take Profit ($)</label>
  <input id="takeprofit" class="save-setting" type="number" value="10" min="1">
  <label>Auto Trade Duration (Hours) - [0 = Unlimited]</label>
  <input id="autoDurationHrs" class="save-setting" type="number" value="1" min="0" step="0.01">
</div>

<button onclick="toggleMarketCycle()" id="cycleBtn" class="btn-cycle">Auto Market Cycle: OFF</button>
<button onclick="toggleCooldownLoop()" id="cooldownBtn" class="btn-cooldown">Cycle Cooldown Loop: OFF</button>
<div id="cycleTimerDisplay" class="cycle-timer-display">Next Loop in: --:--</div>

<div class="card" style="margin-top: 0;">
  <label>Wait Time (Minutes)</label>
  <input id="cycleWaitTime" class="save-setting" type="number" value="5" min="1">
</div>

<button onclick="toggleReverseTrade()" id="reverseBtn" class="btn-reverse">Reverse Trade: OFF</button>

<div class="buttons">
  <button onclick="manualTrade()" id="manualBtn">Manual Trade</button>
  <button onclick="toggleAuto()" id="autoBtn">Start Auto</button>
</div>

<button onclick="resetStats()" class="reset-button-permanent">üîÑ Reset All Stats</button>

<div class="card stats">
  <div><span>Trades</span><b id="trades">0</b></div>
  <div><span>Wins</span><b id="wins">0</b></div>
  <div><span>Losses</span><b id="losses">0</b></div>
  <div><span>P/L</span><b id="profit">0.00</b></div>
</div>

<div class="card">
<h3>Trade History</h3>
<div class="table-container">
<table>
<thead><tr><th>#</th><th>Result</th><th>P/L</th><th>Market</th></tr></thead>
<tbody id="history"></tbody>
</table>
</div>
</div>

</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
<script>
// ============ CORE VARIABLES ============
let ws = null;
let isConnected = false;
let isAutoRunning = false;
let currentContractId = null;
let accountBalance = 0;
let stats = { trades: 0, wins: 0, losses: 0, profit: 0 };
let digitHistory = [];
let sessionStartTime = null;
let autoStartTime = null; 
let timerIntervalId = null;
let isExplicitLogout = false;
let lastPredictionConfidence = 0; 
let previousPredictionConfidence = 0;
let lastPredictionType = '-';
let lastTradeTime = 0;
let lastRequestTime = 0; 
let currentConfidenceMode = 'range';
let currentMarketValue = 'R_10';
let isSpecificEnsembleActive = false;

let isMarketCycleActive = false;
let isCooldownLoopActive = false;
let isCycleCooldown = false;
const marketSequence = ["R_10", "R_25", "R_50", "R_75", "R_100"];
let currentMarketIndex = 0;
let isReverseTradeActive = false;
let cycleTimerId = null;
let isSignalWindowOpen = false;

// ============ VIRTUAL TRADE VARIABLES ============
let isVirtualTradeEnabled = false;
let virtualLossStreak = 0;
let hasSwatchedToLive = false;
let virtualTradeHistory = [];

// ============ ENHANCED ML VARIABLES v3 (PSF + LSTM) ============
let bayesianAlpha = 1;
let bayesianBeta = 1;
let markovTransitionMatrix = {};
let markovTransitionMatrix2ndOrder = {};
let recentWinRates = [];
let extendedHistory = [];
let patternCache = {};
let volatilityWindow = [];
let detectedPattern = null;

// PSF Variables
let psfPatterns = [];
let psfWindowSize = 10; // Auto-adjusted
let psfClusters = [];
let psfPrediction = 50;

// LSTM Variables
let lstmModel = null;
let lstmInitialized = false;
let lstmTraining = false;
let lstmLastTrainTime = null;
let lstmSequenceLength = 20; // Auto-adjusted
let lstmBatchSize = 32; // Auto-adjusted
let lstmEpochs = 50; // Auto-adjusted
let lstmPrediction = 50;
let lstmAccuracyScore = 0;
let lstmLossValue = 0;
let lstmTrainingSamples = 0;

// Model performance tracking
let modelAccuracies = {
    heuristic: 0,
    bayesian: 0,
    markov: 0,
    psf: 0,
    lstm: 0
};
let modelPredictions = {
    heuristic: [],
    bayesian: [],
    markov: [],
    psf: [],
    lstm: []
};

// Advanced pattern detection
let fuzzyPatternCache = {};
let patternDecayTimer = 0;

// Decay factor for Bayesian
const BAYESIAN_DECAY = 0.995;

// Auto-retraining intervals
let lstmRetrainInterval = null;
let psfUpdateInterval = null;

// ============ VIRTUAL TRADE FUNCTIONS ============
function toggleVirtualTrade() {
    isVirtualTradeEnabled = document.getElementById('virtualTradeToggle').checked;
    const settingsDiv = document.getElementById('virtualTradeSettings');
    const statusDiv = document.getElementById('virtualTradeStatus');
    const switchNotice = document.getElementById('switchNotice');
    
    if (isVirtualTradeEnabled) {
        settingsDiv.style.display = 'block';
        statusDiv.classList.add('active');
        virtualLossStreak = 0;
        hasSwatchedToLive = false;
        switchNotice.classList.remove('active');
        updateVirtualTradeUI();
        addLog("üéÆ Virtual Trade Mode ENABLED - Trading on virtual account first", "success");
    } else {
        settingsDiv.style.display = 'none';
        statusDiv.classList.remove('active');
        switchNotice.classList.remove('active');
        virtualLossStreak = 0;
        hasSwatchedToLive = false;
        addLog("Virtual Trade Mode DISABLED - Trading on main account", "warn");
    }
    
    saveSettings();
}

function updateVirtualTradeUI() {
    document.getElementById('virtualLossCount').textContent = virtualLossStreak;
    const threshold = parseInt(document.getElementById('virtualLossThreshold').value) || 3;
    document.getElementById('virtualThresholdDisplay').textContent = threshold;
    
    const statusDiv = document.getElementById('virtualTradeStatus');
    const switchNotice = document.getElementById('switchNotice');
    
    if (hasSwatchedToLive) {
        statusDiv.style.display = 'none';
        switchNotice.classList.add('active');
    } else {
        statusDiv.classList.add('active');
        switchNotice.classList.remove('active');
    }
}

function handleVirtualTradeResult(isWin) {
    if (!isVirtualTradeEnabled || hasSwatchedToLive) return;
    
    if (isWin) {
        virtualLossStreak = 0;
        addLog("üéÆ Virtual Trade WIN - Loss streak reset to 0", "success");
    } else {
        virtualLossStreak++;
        addLog(`üéÆ Virtual Trade LOSS - Consecutive losses: ${virtualLossStreak}`, "error");
        
        const threshold = parseInt(document.getElementById('virtualLossThreshold').value) || 3;
        
        if (virtualLossStreak >= threshold) {
            hasSwatchedToLive = true;
            addLog(`‚ö†Ô∏è SWITCHING TO LIVE ACCOUNT after ${virtualLossStreak} consecutive losses!`, "warn");
            addLog("üî¥ Now trading on LIVE account - Real money at risk!", "error");
            updateVirtualTradeUI();
        }
    }
    
    updateVirtualTradeUI();
}

function isCurrentlyVirtualMode() {
    return isVirtualTradeEnabled && !hasSwatchedToLive;
}

// ============ UTILITY FUNCTIONS ============
function addLog(msg, type = 'info') {
    const container = document.getElementById('logContainer');
    const time = new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
    const entry = document.createElement('div');
    entry.className = 'log-entry';
    entry.innerHTML = `<span class="log-time">[${time}]</span> <span class="log-msg-${type}">${msg}</span>`;
    container.appendChild(entry);
    container.scrollTop = container.scrollHeight;
}

function updateSignalWindowTimer() {
    const now = new Date();
    const sec = now.getSeconds();
    const timerEl = document.getElementById('signalTimerDisplay');
    
    const closeWindowSize = parseInt(document.getElementById('closingSec').value) || 10;
    const openWindowSize = parseInt(document.getElementById('openingSec').value) || 10;
    
    const inClosingWindow = (sec >= (60 - closeWindowSize));
    const inOpeningWindow = (sec <= openWindowSize);
    
    if (inClosingWindow || inOpeningWindow) {
        isSignalWindowOpen = true;
        if (timerEl) {
            timerEl.style.color = "#22c55e";
            timerEl.style.borderColor = "#22c55e";
            timerEl.style.background = "rgba(34, 197, 94, 0.1)";
            timerEl.innerHTML = `SCANNING SIGNAL... (${sec}s)`;
        }
    } else {
        isSignalWindowOpen = false;
        const nextWindowIn = (60 - closeWindowSize) - sec;
        if (timerEl) {
            timerEl.style.color = "#f59e0b";
            timerEl.style.borderColor = "#334155";
            timerEl.style.background = "#020617";
            timerEl.innerHTML = `WAITING FOR WINDOW: ${nextWindowIn}s`;
        }
    }
}

function selectConfidenceMode(mode) {
    currentConfidenceMode = mode;
    document.querySelectorAll('#confidenceModeRadios .radio-option').forEach(opt => {
        opt.classList.remove('selected');
    });
    const selectedOption = document.querySelector(`#confidenceModeRadios .radio-option input[value="${mode}"]`).parentElement;
    selectedOption.classList.add('selected');
    document.getElementById(`mode${mode.charAt(0).toUpperCase() + mode.slice(1)}`).checked = true;
    
    toggleConfidenceUI();
    saveSettings();
}

function selectMarket(market) {
    currentMarketValue = market;
    document.querySelectorAll('#marketRadios .radio-option').forEach(opt => {
        opt.classList.remove('selected');
    });
    const selectedOption = document.querySelector(`#marketRadios .radio-option input[value="${market}"]`).parentElement;
    selectedOption.classList.add('selected');
    document.getElementById(`market${market.replace('_', '')}`).checked = true;
    
    if (isConnected) subscribeToTicks();
    saveSettings();
}

function toggleSpecificEnsemble() {
    isSpecificEnsembleActive = document.getElementById('specificEnsembleToggle').checked;
    const section = document.getElementById('specificEnsembleSection');
    
    if (isSpecificEnsembleActive) {
        section.classList.add('active');
        document.getElementById('patternEnsembleMax').value = 0;
        document.getElementById('patternEnsembleMin').value = 0;
        addLog("Specific Next Likely % Filter ENABLED", "info");
    } else {
        section.classList.remove('active');
        addLog("Specific Next Likely % Filter DISABLED", "warn");
    }
    
    updateEnsembleFilterStatus();
    saveSettings();
}

function updateEnsembleFilterStatus() {
    const maxEnsemble = parseInt(document.getElementById('patternEnsembleMax').value) || 0;
    const minEnsemble = parseInt(document.getElementById('patternEnsembleMin').value) || 0;
    const statusEl = document.getElementById('ensembleFilterStatus');
    const warningEl = document.getElementById('filterWarning');
    
    let activeCount = 0;
    if (maxEnsemble > 0) activeCount++;
    if (minEnsemble > 0) activeCount++;
    if (isSpecificEnsembleActive) activeCount++;
    
    if (activeCount > 1) {
        warningEl.style.display = 'block';
        statusEl.textContent = '‚ö†Ô∏è CONFLICT! Multiple filters active - Only ONE allowed';
        statusEl.style.color = '#ef4444';
        statusEl.style.background = 'rgba(239, 68, 68, 0.1)';
        statusEl.style.border = '1px solid #ef4444';
        return;
    }
    
    warningEl.style.display = 'none';
    statusEl.style.background = '#1e293b';
    statusEl.style.border = 'none';
    
    if (activeCount === 0) {
        statusEl.textContent = 'üîì All filters DISABLED - Trading on pattern match only';
        statusEl.style.color = '#22c55e';
    }
    else if (maxEnsemble > 0) {
        statusEl.textContent = `üîí Active: Trade if Next Likely % ‚â§ ${maxEnsemble}% (LOW confidence)`;
        statusEl.style.color = '#f59e0b';
    }
    else if (minEnsemble > 0) {
        statusEl.textContent = `üîí Active: Trade if Next Likely % ‚â• ${minEnsemble}% (HIGH confidence)`;
        statusEl.style.color = '#3b82f6';
    }
    else if (isSpecificEnsembleActive) {
        const specs = [
            parseInt(document.getElementById('specEns1').value),
            parseInt(document.getElementById('specEns2').value),
            parseInt(document.getElementById('specEns3').value),
            parseInt(document.getElementById('specEns4').value),
            parseInt(document.getElementById('specEns5').value)
        ].filter(v => !isNaN(v) && v >= 0 && v <= 100);
        statusEl.textContent = `üéØ Active: Trade if Next Likely % = ${specs.join(', ')}%`;
        statusEl.style.color = '#8b5cf6';
    }
}

function toggleConfidenceUI() {
    const mode = currentConfidenceMode;
    document.getElementById('rangeUI').style.display = (mode === 'range') ? 'block' : 'none';
    document.getElementById('specificUI').style.display = (mode === 'specific') ? 'block' : 'none';
    document.getElementById('sequenceUI').style.display = (mode === 'sequence') ? 'block' : 'none';
    document.getElementById('patternUI').style.display = (mode === 'pattern') ? 'block' : 'none';
    
    if (mode === 'pattern') {
        updateEnsembleFilterStatus();
    }
    
    addLog(`Confidence Mode: ${mode}`, "info");
}

function saveSettings() {
    const settings = {
        confidenceMode: currentConfidenceMode,
        market: currentMarketValue,
        specificEnsembleActive: isSpecificEnsembleActive,
        virtualTradeEnabled: isVirtualTradeEnabled,
        virtualLossStreak: virtualLossStreak,
        hasSwatchedToLive: hasSwatchedToLive
    };
    document.querySelectorAll('.save-setting').forEach(el => settings[el.id] = el.value);
    localStorage.setItem('bot_settings_v10_ml', JSON.stringify(settings));
}

function loadSettings() {
    const saved = localStorage.getItem('bot_settings_v10_ml');
    if (saved) {
        const settings = JSON.parse(saved);
        for (const id in settings) {
            const el = document.getElementById(id);
            if (el) el.value = settings[id];
        }
        
        if (settings.confidenceMode) {
            currentConfidenceMode = settings.confidenceMode;
            selectConfidenceMode(currentConfidenceMode);
        }
        
        if (settings.market) {
            currentMarketValue = settings.market;
            selectMarket(currentMarketValue);
        }
        
        if (settings.specificEnsembleActive) {
            isSpecificEnsembleActive = settings.specificEnsembleActive;
            document.getElementById('specificEnsembleToggle').checked = isSpecificEnsembleActive;
            if (isSpecificEnsembleActive) {
                document.getElementById('specificEnsembleSection').classList.add('active');
            }
        }
        
        if (settings.virtualTradeEnabled !== undefined) {
            isVirtualTradeEnabled = settings.virtualTradeEnabled;
            document.getElementById('virtualTradeToggle').checked = isVirtualTradeEnabled;
            if (isVirtualTradeEnabled) {
                document.getElementById('virtualTradeSettings').style.display = 'block';
            }
        }
        
        if (settings.virtualLossStreak !== undefined) {
            virtualLossStreak = settings.virtualLossStreak;
        }
        
        if (settings.hasSwatchedToLive !== undefined) {
            hasSwatchedToLive = settings.hasSwatchedToLive;
        }
        
        updateVirtualTradeUI();
    }
    toggleConfidenceUI();
    
    const savedExtHistory = localStorage.getItem('extended_history_v10');
    if(savedExtHistory) {
        try {
            extendedHistory = JSON.parse(savedExtHistory);
            addLog(`Loaded ${extendedHistory.length} historical ticks for ML`, "success");
        } catch(e) {
            addLog("Error loading extended history", "warn");
            extendedHistory = [];
        }
    }
    
    const savedHistory = localStorage.getItem('trade_history_v10');
    if(savedHistory) document.getElementById('history').innerHTML = savedHistory;
    
    const savedStats = localStorage.getItem('trade_stats_v10');
    if(savedStats) { 
        stats = JSON.parse(savedStats); 
        updateStats(); 
    }
    
    const savedBayesian = localStorage.getItem('bayesian_params_v10');
    if(savedBayesian) {
        const params = JSON.parse(savedBayesian);
        bayesianAlpha = params.alpha || 1;
        bayesianBeta = params.beta || 1;
    }
    
    const savedMarkov = localStorage.getItem('markov_matrix_v10');
    if(savedMarkov) {
        try {
            markovTransitionMatrix = JSON.parse(savedMarkov);
            addLog("Loaded Markov transition matrix", "success");
        } catch(e) {
            markovTransitionMatrix = {};
        }
    }
    
    const savedMarkov2nd = localStorage.getItem('markov_matrix_2nd_v10');
    if(savedMarkov2nd) {
        try {
            markovTransitionMatrix2ndOrder = JSON.parse(savedMarkov2nd);
            addLog("Loaded 2nd-order Markov matrix", "success");
        } catch(e) {
            markovTransitionMatrix2ndOrder = {};
        }
    }
}

document.querySelectorAll('.save-setting').forEach(el => {
    el.addEventListener('input', saveSettings);
    el.addEventListener('change', saveSettings);
});

// ============ WEBSOCKET CONNECTION ============
function connect() {
  const token = document.getElementById('token').value.trim();
  if (!token) { addLog("Error: API Token missing.", "error"); return; }
  if (ws) ws.close();
  sessionStorage.setItem('derivToken', token);
  isExplicitLogout = false;
  updateStatus('Connecting...', 'disconnected');
  ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=1089');
  ws.onopen = () => { addLog("WebSocket Connected.", "info"); sendAPIRequest({ authorize: token }); };
  ws.onmessage = (msg) => handleMessage(JSON.parse(msg.data));
  ws.onclose = () => {
    isConnected = false;
    updateStatus('Disconnected', 'disconnected');
    document.getElementById('accountType').style.display = 'none';
    if (!isExplicitLogout) { 
        addLog("Connection lost. Reconnecting in 5s...", "warn"); 
        setTimeout(connect, 5000); 
    }
  };
  ws.onerror = (error) => {
    addLog("WebSocket error occurred", "error");
    console.error("WebSocket error:", error);
  };
}

function handleMessage(data) {
  if (data.error) { 
    addLog(`API ERROR: ${data.error.message}`, "error"); 
    console.error("API Error:", data.error);
    return; 
  }
  
  if (data.authorize) {
    isConnected = true;
    updateStatus('Connected', 'connected');
    const accTypeEl = document.getElementById('accountType');
    const isVirtual = data.authorize.is_virtual === 1 || data.authorize.loginid.includes('VRTC');
    accTypeEl.textContent = isVirtual ? 'Demo Account' : 'Live Account';
    accTypeEl.className = 'account-type ' + (isVirtual ? 'demo-badge' : 'live-badge');
    accTypeEl.style.display = 'block';
    addLog(`Authorized: ${data.authorize.email}`, "success");
    sendAPIRequest({ balance: 1, subscribe: 1 });
    subscribeToTicks();
    startSessionTimer();
    
    const persistedAuto = localStorage.getItem('isAutoRunning') === 'true';
    if(persistedAuto && !isAutoRunning) {
        resumeAutoTrade();
    }
  }
  
  if (data.balance) { 
    accountBalance = data.balance.balance; 
    updateBalance(); 
  }
  
  if (data.tick) {
    const lastDigit = parseInt(data.tick.quote.toString().slice(-1));
    addDigitToAnalyzer(lastDigit);
  }
  
  if (data.buy) {
    currentContractId = data.buy.contract_id;
    const tradeMode = isCurrentlyVirtualMode() ? "VIRTUAL" : "LIVE";
    addLog(`${tradeMode} Trade Placed (ID: ${currentContractId})`, "success");
    sendAPIRequest({ proposal_open_contract: 1, contract_id: currentContractId, subscribe: 1 });
  }
  
  if (data.proposal_open_contract) {
    const contract = data.proposal_open_contract;
    if (contract.is_settled === 1 || ['won', 'lost', 'sold'].includes(contract.status)) {
      handleTradeResult(contract);
      currentContractId = null;
      if (data.subscription) sendAPIRequest({ forget: data.subscription.id });
    }
  }
}

function resumeAutoTrade() {
    isAutoRunning = true;
    const btn = document.getElementById('autoBtn');
    const shutdownUI = document.getElementById('shutdownDisplay');
    autoStartTime = parseInt(localStorage.getItem('autoStartTime')) || Date.now();
    shutdownUI.style.display = 'block';
    btn.textContent = 'Stop Auto'; 
    btn.style.background = '#ef4444';
    addLog("Resuming Persistent Auto-Trade...", "success");
    
    // Auto-initialize LSTM when auto-trade starts
    if (!lstmInitialized) {
        initializeLSTM();
    }
}

// ============ PSF (Pattern Sequence Forecasting) FUNCTIONS ============

function calculateEuclideanDistance(arr1, arr2) {
    if (arr1.length !== arr2.length) return Infinity;
    let sum = 0;
    for (let i = 0; i < arr1.length; i++) {
        sum += Math.pow(arr1[i] - arr2[i], 2);
    }
    return Math.sqrt(sum);
}

function levenshtein(a, b) {
    const matrix = Array(a.length + 1).fill(null).map(() => Array(b.length + 1).fill(0));
    
    for (let i = 0; i <= a.length; i++) matrix[i][0] = i;
    for (let j = 0; j <= b.length; j++) matrix[0][j] = j;
    
    for (let i = 1; i <= a.length; i++) {
        for (let j = 1; j <= b.length; j++) {
            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
            matrix[i][j] = Math.min(
                matrix[i - 1][j] + 1,
                matrix[i][j - 1] + 1,
                matrix[i - 1][j - 1] + cost
            );
        }
    }
    
    return matrix[a.length][b.length];
}

function autoAdjustPSFWindowSize() {
    // Auto-adjust window size based on volatility and data size
    const volatility = calculateVolatility(extendedHistory, 100);
    
    if (volatility > 3.0) {
        psfWindowSize = 5; // Shorter window for high volatility
    } else if (volatility > 2.0) {
        psfWindowSize = 8;
    } else if (volatility > 1.5) {
        psfWindowSize = 10;
    } else {
        psfWindowSize = 15; // Longer window for stable patterns
    }
    
    // Ensure we have enough data
    if (extendedHistory.length < psfWindowSize * 5) {
        psfWindowSize = Math.max(3, Math.floor(extendedHistory.length / 5));
    }
    
    return psfWindowSize;
}

function buildPSFPatterns() {
    if (extendedHistory.length < 50) return;
    
    const windowSize = autoAdjustPSFWindowSize();
    psfPatterns = [];
    
    for (let i = 0; i < extendedHistory.length - windowSize - 1; i++) {
        const pattern = extendedHistory.slice(i, i + windowSize);
        const nextDigit = extendedHistory[i + windowSize];
        
        // Add recency weight
        const recency = Math.exp(-i / 1000); // Exponential decay
        
        psfPatterns.push({ 
            pattern, 
            nextDigit, 
            weight: recency,
            index: i 
        });
    }
    
    addLog(`PSF: Built ${psfPatterns.length} patterns (window=${windowSize})`, "info");
}

function calculatePSFPrediction() {
    if (psfPatterns.length === 0 || digitHistory.length < psfWindowSize) {
        return 50;
    }
    
    const currentPattern = digitHistory.slice(0, psfWindowSize);
    
    // Find similar patterns using both Euclidean and Levenshtein
    const similarities = psfPatterns.map(p => {
        const euclidean = calculateEuclideanDistance(currentPattern, p.pattern);
        const levenshtein_dist = levenshtein(currentPattern, p.pattern);
        
        // Combine both metrics
        const combinedDistance = (euclidean * 0.6) + (levenshtein_dist * 0.4);
        
        return {
            ...p,
            distance: combinedDistance
        };
    });
    
    // Sort by similarity and take top K
    similarities.sort((a, b) => a.distance - b.distance);
    const topK = Math.min(10, Math.max(3, Math.floor(psfPatterns.length * 0.02)));
    const topSimilar = similarities.slice(0, topK);
    
    if (topSimilar.length === 0) return 50;
    
    // Weighted average prediction
    let totalWeight = 0;
    let weightedSum = 0;
    
    topSimilar.forEach(s => {
        // Distance-based weight (closer = higher weight)
        const distanceWeight = 1 / (1 + s.distance);
        const finalWeight = distanceWeight * s.weight;
        
        const isOver5 = s.nextDigit > 5 ? 1 : 0;
        weightedSum += isOver5 * finalWeight;
        totalWeight += finalWeight;
    });
    
    const prediction = totalWeight > 0 ? (weightedSum / totalWeight) * 100 : 50;
    
    // Store prediction for accuracy tracking
    modelPredictions.psf.push({ prediction });
    
    return Math.min(98, Math.max(2, prediction));
}

function updatePSFPeriodically() {
    // Rebuild PSF patterns every 100 new digits
    if (extendedHistory.length % 100 === 0 && extendedHistory.length > 50) {
        buildPSFPatterns();
    }
}

// ============ LSTM NEURAL NETWORK FUNCTIONS ============

function autoAdjustLSTMParams() {
    // Auto-adjust LSTM parameters based on data size and volatility
    const dataSize = extendedHistory.length;
    const volatility = calculateVolatility(extendedHistory, 100);
    
    // Sequence length
    if (dataSize < 200) {
        lstmSequenceLength = 10;
    } else if (dataSize < 500) {
        lstmSequenceLength = 15;
    } else if (dataSize < 1000) {
        lstmSequenceLength = 20;
    } else {
        lstmSequenceLength = 30;
    }
    
    // Batch size
    if (dataSize < 300) {
        lstmBatchSize = 16;
    } else if (dataSize < 1000) {
        lstmBatchSize = 32;
    } else {
        lstmBatchSize = 64;
    }
    
    // Epochs based on volatility
    if (volatility > 3.0) {
        lstmEpochs = 30; // Fewer epochs for noisy data
    } else if (volatility > 2.0) {
        lstmEpochs = 40;
    } else {
        lstmEpochs = 50; // More epochs for stable data
    }
    
    addLog(`LSTM Params: seq=${lstmSequenceLength}, batch=${lstmBatchSize}, epochs=${lstmEpochs}`, "info");
}

async function initializeLSTM() {
    if (extendedHistory.length < 100) {
        addLog("LSTM: Need 100+ ticks to initialize", "warn");
        document.getElementById('lstmStatusText').textContent = `Collecting data... (${extendedHistory.length}/100)`;
        return;
    }
    
    try {
        addLog("üß† Initializing LSTM Neural Network...", "info");
        document.getElementById('lstmStatusText').textContent = "Initializing model architecture...";
        
        // Auto-adjust parameters
        autoAdjustLSTMParams();
        
        // Create LSTM model
        lstmModel = tf.sequential();
        
        // LSTM layers with dropout for regularization
        lstmModel.add(tf.layers.lstm({
            units: 64,
            returnSequences: true,
            inputShape: [lstmSequenceLength, 1]
        }));
        lstmModel.add(tf.layers.dropout({ rate: 0.2 }));
        
        lstmModel.add(tf.layers.lstm({
            units: 32,
            returnSequences: false
        }));
        lstmModel.add(tf.layers.dropout({ rate: 0.2 }));
        
        lstmModel.add(tf.layers.dense({ units: 16, activation: 'relu' }));
        lstmModel.add(tf.layers.dense({ units: 1, activation: 'sigmoid' }));
        
        lstmModel.compile({
            optimizer: tf.train.adam(0.001),
            loss: 'binaryCrossentropy',
            metrics: ['accuracy']
        });
        
        addLog("‚úÖ LSTM Model Architecture Created", "success");
        document.getElementById('lstmStatusText').textContent = "Model ready - Starting initial training...";
        
        lstmInitialized = true;
        
        // Initial training
        await trainLSTM();
        
        // Auto-retrain every 200 new digits
        if (!lstmRetrainInterval) {
            lstmRetrainInterval = setInterval(() => {
                if (isAutoRunning && extendedHistory.length % 200 === 0) {
                    trainLSTM();
                }
            }, 60000); // Check every minute
        }
        
    } catch (error) {
        addLog(`LSTM Init Error: ${error.message}`, "error");
        console.error("LSTM Error:", error);
        document.getElementById('lstmStatusText').textContent = `Error: ${error.message}`;
    }
}

function prepareTrainingData() {
    const sequences = [];
    const labels = [];
    
    // Use extended history for training
    const dataSource = extendedHistory.length > 500 ? extendedHistory : [...extendedHistory, ...digitHistory];
    
    for (let i = lstmSequenceLength; i < dataSource.length; i++) {
        const sequence = dataSource.slice(i - lstmSequenceLength, i);
        const nextDigit = dataSource[i];
        
        sequences.push(sequence.map(d => [d / 10])); // Normalize to 0-1
        labels.push([nextDigit > 5 ? 1 : 0]); // Binary classification
    }
    
    return { sequences, labels };
}

async function trainLSTM() {
    if (!lstmModel || lstmTraining) return;
    
    try {
        lstmTraining = true;
        const startTime = Date.now();
        
        addLog("üß† LSTM Training Started...", "info");
        document.getElementById('lstmStatusText').textContent = "Training in progress...";
        
        const { sequences, labels } = prepareTrainingData();
        
        if (sequences.length < 50) {
            addLog("LSTM: Not enough sequences for training", "warn");
            lstmTraining = false;
            return;
        }
        
        lstmTrainingSamples = sequences.length;
        
        // Convert to tensors
        const xs = tf.tensor3d(sequences);
        const ys = tf.tensor2d(labels);
        
        // Train with callbacks for progress
        const history = await lstmModel.fit(xs, ys, {
            epochs: lstmEpochs,
            batchSize: lstmBatchSize,
            validationSplit: 0.2,
            shuffle: true,
            callbacks: {
                onEpochEnd: (epoch, logs) => {
                    const progress = ((epoch + 1) / lstmEpochs) * 100;
                    document.getElementById('lstmProgressBar').style.width = `${progress}%`;
                    
                    if ((epoch + 1) % 10 === 0) {
                        addLog(`LSTM Epoch ${epoch + 1}/${lstmEpochs} - Loss: ${logs.loss.toFixed(4)}`, "info");
                    }
                }
            }
        });
        
        // Clean up tensors
        xs.dispose();
        ys.dispose();
        
        const finalLoss = history.history.loss[history.history.loss.length - 1];
        const finalAccuracy = history.history.acc ? history.history.acc[history.history.acc.length - 1] : 0;
        
        lstmLossValue = finalLoss;
        lstmAccuracyScore = finalAccuracy * 100;
        lstmLastTrainTime = new Date();
        
        // Update UI
        document.getElementById('lstmLoss').textContent = finalLoss.toFixed(4);
        document.getElementById('lstmAccuracy').textContent = `${(finalAccuracy * 100).toFixed(1)}%`;
        document.getElementById('lstmSamples').textContent = lstmTrainingSamples;
        document.getElementById('lstmLastRetrain').textContent = lstmLastTrainTime.toLocaleTimeString();
        
        const trainingTime = ((Date.now() - startTime) / 1000).toFixed(1);
        addLog(`‚úÖ LSTM Training Complete (${trainingTime}s) - Loss: ${finalLoss.toFixed(4)}, Acc: ${(finalAccuracy * 100).toFixed(1)}%`, "success");
        document.getElementById('lstmStatusText').textContent = `Trained on ${lstmTrainingSamples} samples - Ready for predictions`;
        document.getElementById('lstmProgressBar').style.width = '100%';
        
        // Save model accuracy
        modelAccuracies.lstm = lstmAccuracyScore;
        
        lstmTraining = false;
        
    } catch (error) {
        addLog(`LSTM Training Error: ${error.message}`, "error");
        console.error("LSTM Training Error:", error);
        document.getElementById('lstmStatusText').textContent = `Training error: ${error.message}`;
        lstmTraining = false;
    }
}

async function calculateLSTMPrediction() {
    if (!lstmModel || !lstmInitialized || digitHistory.length < lstmSequenceLength) {
        return 50;
    }
    
    try {
        const sequence = digitHistory.slice(0, lstmSequenceLength);
        const normalizedSeq = sequence.map(d => [d / 10]);
        
        const input = tf.tensor3d([normalizedSeq]);
        const prediction = lstmModel.predict(input);
        const predValue = (await prediction.data())[0];
        
        // Clean up
        input.dispose();
        prediction.dispose();
        
        const confidence = predValue * 100;
        
        // Store for accuracy tracking
        modelPredictions.lstm.push({ prediction: confidence });
        
        lstmPrediction = confidence;
        return Math.min(98, Math.max(2, confidence));
        
    } catch (error) {
        console.error("LSTM Prediction Error:", error);
        return 50;
    }
}

// ============ ENHANCED ML FUNCTIONS v3 ============

function smoothOutliers(digit, history) {
    if (history.length < 10) return digit;
    
    const mean = history.reduce((a, b) => a + b, 0) / history.length;
    const variance = history.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / history.length;
    const stdDev = Math.sqrt(variance);
    
    if (stdDev > 0 && Math.abs(digit - mean) > 3 * stdDev) {
        const smoothed = Math.round(mean);
        addLog(`Outlier detected: ${digit} ‚Üí smoothed to ${smoothed}`, "warn");
        return smoothed;
    }
    
    return digit;
}

function calculateVolatility(data, windowSize = 50) {
    if (data.length < windowSize) windowSize = data.length;
    if (windowSize < 2) return 0;
    
    const recent = data.slice(0, windowSize);
    const mean = recent.reduce((a, b) => a + b, 0) / recent.length;
    const variance = recent.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / recent.length;
    return Math.sqrt(variance);
}

function updateBayesianModel(isOver5) {
    bayesianAlpha *= BAYESIAN_DECAY;
    bayesianBeta *= BAYESIAN_DECAY;
    
    if (isOver5) {
        bayesianAlpha += 1;
    } else {
        bayesianBeta += 1;
    }
    
    if ((bayesianAlpha + bayesianBeta) % 20 < 1) {
        localStorage.setItem('bayesian_params_v10', JSON.stringify({
            alpha: bayesianAlpha,
            beta: bayesianBeta
        }));
    }
    
    const posteriorMean = bayesianAlpha / (bayesianAlpha + bayesianBeta);
    return posteriorMean * 100;
}

function updateMarkovModel(currentDigit) {
    if (digitHistory.length < 1) return;
    
    const prevDigit = digitHistory[0];
    if (!markovTransitionMatrix[prevDigit]) {
        markovTransitionMatrix[prevDigit] = Array(10).fill(0);
    }
    markovTransitionMatrix[prevDigit][currentDigit]++;
    
    if (digitHistory.length >= 2) {
        const state = `${digitHistory[1]}-${digitHistory[0]}`;
        if (!markovTransitionMatrix2ndOrder[state]) {
            markovTransitionMatrix2ndOrder[state] = Array(10).fill(0);
        }
        markovTransitionMatrix2ndOrder[state][currentDigit]++;
    }
    
    if (digitHistory.length % 50 === 0) {
        localStorage.setItem('markov_matrix_v10', JSON.stringify(markovTransitionMatrix));
        localStorage.setItem('markov_matrix_2nd_v10', JSON.stringify(markovTransitionMatrix2ndOrder));
    }
}

function calculateMarkovPrediction() {
    let prediction = 50;
    
    if (digitHistory.length >= 2) {
        const state = `${digitHistory[1]}-${digitHistory[0]}`;
        if (markovTransitionMatrix2ndOrder[state]) {
            const transitions = markovTransitionMatrix2ndOrder[state];
            const totalTransitions = transitions.reduce((a, b) => a + b, 0);
            
            if (totalTransitions > 0) {
                const smoothedTransitions = transitions.map(t => t + 1);
                const smoothedTotal = smoothedTransitions.reduce((a, b) => a + b, 0);
                const over5Transitions = smoothedTransitions.slice(6, 10).reduce((a, b) => a + b, 0);
                prediction = (over5Transitions / smoothedTotal) * 100;
                return prediction;
            }
        }
    }
    
    if (digitHistory.length >= 1 && markovTransitionMatrix[digitHistory[0]]) {
        const transitions = markovTransitionMatrix[digitHistory[0]];
        const totalTransitions = transitions.reduce((a, b) => a + b, 0);
        
        if (totalTransitions > 0) {
            const smoothedTransitions = transitions.map(t => t + 1);
            const smoothedTotal = smoothedTransitions.reduce((a, b) => a + b, 0);
            const over5Transitions = smoothedTransitions.slice(6, 10).reduce((a, b) => a + b, 0);
            prediction = (over5Transitions / smoothedTotal) * 100;
        }
    }
    
    return prediction;
}

function detectPatterns() {
    if (digitHistory.length < 10) return null;
    
    patternDecayTimer++;
    
    if (patternDecayTimer >= 100) {
        patternDecayTimer = 0;
        for (const key in patternCache) {
            if (patternCache[key].count > 0) {
                patternCache[key].count = Math.floor(patternCache[key].count * 0.5);
                if (patternCache[key].count < 1) {
                    delete patternCache[key];
                }
            }
        }
    }
    
    for (let len = 2; len <= Math.min(15, digitHistory.length); len++) {
        const pattern = digitHistory.slice(0, len);
        const patternStr = pattern.join(',');
        const cacheKey = `pattern_${len}_${patternStr}`;
        
        if (patternCache[cacheKey]) {
            patternCache[cacheKey].count++;
            patternCache[cacheKey].lastSeen = Date.now();
        } else {
            patternCache[cacheKey] = { count: 1, lastSeen: Date.now() };
        }
        
        for (let i = len; i <= digitHistory.length - len; i++) {
            const comparePattern = digitHistory.slice(i, i + len);
            const distance = levenshtein(pattern, comparePattern);
            
            const maxDistance = len <= 5 ? 1 : 2;
            
            if (distance <= maxDistance) {
                if (i + len < digitHistory.length) {
                    const nextDigit = digitHistory[i + len];
                    const confidence = Math.min(95, 50 + (len * 4) + (patternCache[cacheKey]?.count || 0) * 2);
                    
                    return {
                        pattern: patternStr,
                        nextDigit: nextDigit,
                        confidence: confidence,
                        fuzzy: distance > 0,
                        distance: distance
                    };
                }
            }
        }
    }
    
    return null;
}

function calculateAdaptiveThreshold() {
    if (recentWinRates.length < 5) return 0;
    
    const recentAvg = recentWinRates.slice(-10).reduce((a, b) => a + b, 0) / Math.min(10, recentWinRates.length);
    
    if (recentAvg < 0.40) {
        return 15;
    } else if (recentAvg < 0.45) {
        return 10;
    } else if (recentAvg > 0.65) {
        return -8;
    } else if (recentAvg > 0.60) {
        return -5;
    }
    return 0;
}

async function calculateEnsemblePrediction(heuristicConf, bayesianProb, markovProb, volatility) {
    // Calculate PSF and LSTM predictions
    const psfProb = calculatePSFPrediction();
    const lstmProb = await calculateLSTMPrediction();
    
    // Dynamic weight calculation based on model accuracies
    let weights = {
        heuristic: 0.20,
        bayesian: 0.20,
        markov: 0.20,
        psf: 0.20,
        lstm: 0.20
    };
    
    const totalAccuracy = modelAccuracies.heuristic + modelAccuracies.bayesian + 
                          modelAccuracies.markov + modelAccuracies.psf + modelAccuracies.lstm;
    
    if (totalAccuracy > 0) {
        const heuristicWeight = (modelAccuracies.heuristic / totalAccuracy) * 0.7;
        const bayesianWeight = (modelAccuracies.bayesian / totalAccuracy) * 0.7;
        const markovWeight = (modelAccuracies.markov / totalAccuracy) * 0.7;
        const psfWeight = (modelAccuracies.psf / totalAccuracy) * 0.7;
        const lstmWeight = (modelAccuracies.lstm / totalAccuracy) * 0.7;
        
        weights.heuristic = 0.15 + heuristicWeight * 0.15;
        weights.bayesian = 0.15 + bayesianWeight * 0.15;
        weights.markov = 0.15 + markovWeight * 0.15;
        weights.psf = 0.15 + psfWeight * 0.2;
        weights.lstm = 0.15 + lstmWeight * 0.25;
    }
    
    // Adjust weights based on volatility
    if (volatility > 3.0) {
        weights.bayesian += 0.10;
        weights.lstm += 0.10;
        weights.heuristic -= 0.10;
        weights.psf -= 0.05;
        weights.markov -= 0.05;
    } else if (volatility > 2.5) {
        weights.bayesian += 0.05;
        weights.lstm += 0.05;
        weights.heuristic -= 0.05;
        weights.psf -= 0.03;
        weights.markov -= 0.02;
    }
    
    const pattern = detectPatterns();
    let patternBonus = 0;
    if (pattern) {
        patternBonus = pattern.fuzzy ? 3 : 5;
        if (pattern.confidence > 70) patternBonus += 5;
    }
    
    const ensemble = (
        heuristicConf * weights.heuristic +
        bayesianProb * weights.bayesian +
        markovProb * weights.markov +
        psfProb * weights.psf +
        lstmProb * weights.lstm +
        patternBonus
    );
    
    return Math.min(98, Math.max(0, ensemble));
}

function updateModelAccuracies(actualResult) {
    const isOver5 = actualResult > 5;
    
    if (modelPredictions.heuristic.length > 0) {
        const lastHeuristic = modelPredictions.heuristic[modelPredictions.heuristic.length - 1];
        const heuristicCorrect = (lastHeuristic.prediction === 'OVER' && isOver5) || 
                                  (lastHeuristic.prediction === 'UNDER' && !isOver5);
        
        modelPredictions.heuristic.push({ correct: heuristicCorrect });
        if (modelPredictions.heuristic.length > 50) modelPredictions.heuristic.shift();
        
        const correctCount = modelPredictions.heuristic.filter(p => p.correct).length;
        modelAccuracies.heuristic = (correctCount / modelPredictions.heuristic.length) * 100;
    }
    
    if (modelPredictions.bayesian.length > 0) {
        const lastBayesian = modelPredictions.bayesian[modelPredictions.bayesian.length - 1];
        const bayesianCorrect = (lastBayesian.prediction > 50 && isOver5) || 
                                 (lastBayesian.prediction <= 50 && !isOver5);
        
        modelPredictions.bayesian.push({ correct: bayesianCorrect });
        if (modelPredictions.bayesian.length > 50) modelPredictions.bayesian.shift();
        
        const correctCount = modelPredictions.bayesian.filter(p => p.correct).length;
        modelAccuracies.bayesian = (correctCount / modelPredictions.bayesian.length) * 100;
    }
    
    if (modelPredictions.markov.length > 0) {
        const lastMarkov = modelPredictions.markov[modelPredictions.markov.length - 1];
        const markovCorrect = (lastMarkov.prediction > 50 && isOver5) || 
                               (lastMarkov.prediction <= 50 && !isOver5);
        
        modelPredictions.markov.push({ correct: markovCorrect });
        if (modelPredictions.markov.length > 50) modelPredictions.markov.shift();
        
        const correctCount = modelPredictions.markov.filter(p => p.correct).length;
        modelAccuracies.markov = (correctCount / modelPredictions.markov.length) * 100;
    }
    
    if (modelPredictions.psf.length > 0) {
        const lastPSF = modelPredictions.psf[modelPredictions.psf.length - 1];
        const psfCorrect = (lastPSF.prediction > 50 && isOver5) || 
                            (lastPSF.prediction <= 50 && !isOver5);
        
        modelPredictions.psf.push({ correct: psfCorrect });
        if (modelPredictions.psf.length > 50) modelPredictions.psf.shift();
        
        const correctCount = modelPredictions.psf.filter(p => p.correct).length;
        modelAccuracies.psf = (correctCount / modelPredictions.psf.length) * 100;
    }
    
    if (modelPredictions.lstm.length > 0) {
        const lastLSTM = modelPredictions.lstm[modelPredictions.lstm.length - 1];
        const lstmCorrect = (lastLSTM.prediction > 50 && isOver5) || 
                             (lastLSTM.prediction <= 50 && !isOver5);
        
        modelPredictions.lstm.push({ correct: lstmCorrect });
        if (modelPredictions.lstm.length > 50) modelPredictions.lstm.shift();
        
        const correctCount = modelPredictions.lstm.filter(p => p.correct).length;
        modelAccuracies.lstm = (correctCount / modelPredictions.lstm.length) * 100;
    }
    
    updateModelPerformanceUI();
}

function updateModelPerformanceUI() {
    const heuristicEl = document.getElementById('heuristicPerf');
    const bayesianEl = document.getElementById('bayesianPerf');
    const markovEl = document.getElementById('markovPerf');
    const psfEl = document.getElementById('psfPerf');
    
    if (modelAccuracies.heuristic > 0) {
        heuristicEl.innerHTML = `<span style="opacity:0.6">Heuristic</span><b style="color:#22c55e">${modelAccuracies.heuristic.toFixed(0)}%</b>`;
        heuristicEl.className = modelAccuracies.heuristic >= 55 ? 'model-perf-high' : (modelAccuracies.heuristic < 45 ? 'model-perf-low': '');
    }
    
    if (modelAccuracies.bayesian > 0) {
        bayesianEl.innerHTML = `<span style="opacity:0.6">Bayesian</span><b style="color:#8b5cf6">${modelAccuracies.bayesian.toFixed(0)}%</b>`;
        bayesianEl.className = modelAccuracies.bayesian >= 55 ? 'model-perf-high' : (modelAccuracies.bayesian < 45 ? 'model-perf-low' : '');
    }
    
    if (modelAccuracies.markov > 0) {
        markovEl.innerHTML = `<span style="opacity:0.6">Markov</span><b style="color:#3b82f6">${modelAccuracies.markov.toFixed(0)}%</b>`;
        markovEl.className = modelAccuracies.markov >= 55 ? 'model-perf-high' : (modelAccuracies.markov < 45 ? 'model-perf-low' : '');
    }
    
    if (modelAccuracies.psf > 0) {
        psfEl.innerHTML = `<span style="opacity:0.6">PSF</span><b style="color:#f59e0b">${modelAccuracies.psf.toFixed(0)}%</b>`;
        psfEl.className = modelAccuracies.psf >= 55 ? 'model-perf-high' : (modelAccuracies.psf < 45 ? 'model-perf-low' : '');
    }
}

// ============ DIGIT ANALYZER ============
function addDigitToAnalyzer(digit) {
  digit = smoothOutliers(digit, digitHistory);
  
  digitHistory.unshift(digit);
  if (digitHistory.length > 50) digitHistory.pop();
  
  extendedHistory.unshift(digit);
  if (extendedHistory.length > 5000) extendedHistory.pop();
  
  if (extendedHistory.length % 100 === 0) {
    localStorage.setItem('extended_history_v10', JSON.stringify(extendedHistory));
  }
  
  const isOver5 = digit > 5;
  updateBayesianModel(isOver5);
  updateMarkovModel(digit);
  
  if (digitHistory.length > 1) {
    updateModelAccuracies(digit);
  }
  
  volatilityWindow.unshift(digit);
  if (volatilityWindow.length > 100) volatilityWindow.pop();
  
  // Update PSF patterns periodically
  updatePSFPeriodically();
  
  // Auto-initialize LSTM when we have enough data
  if (!lstmInitialized && extendedHistory.length >= 100 && isAutoRunning) {
    initializeLSTM();
  }
  
  updateAnalyzerDisplay();
  if (isAutoRunning && !isCycleCooldown) checkAndAutoTrade();
}

function checkAndAutoTrade() {
    if (currentContractId !== null) return;
    
    if (currentConfidenceMode === 'pattern') {
        const now = Date.now();
        const cooldownMs = parseInt(document.getElementById('cooldown').value) * 1000;
        if (now - lastTradeTime < Math.max(cooldownMs, 1000)) return;
        
        if (detectedPattern && detectedPattern.nextDigit !== null && detectedPattern.nextDigit !== undefined) {
            const targetDigits = [
                parseInt(document.getElementById('pattern1').value),
                parseInt(document.getElementById('pattern2').value),
                parseInt(document.getElementById('pattern3').value),
                parseInt(document.getElementById('pattern4').value),
                parseInt(document.getElementById('pattern5').value)
            ];
            
            if (targetDigits.includes(detectedPattern.nextDigit)) {
                const maxNextLikely = parseInt(document.getElementById('patternEnsembleMax').value) || 0;
                const minNextLikely = parseInt(document.getElementById('patternEnsembleMin').value) || 0;
                const currentNextLikely = Math.round(detectedPattern.confidence);
                
                let activeFilters = 0;
                if (maxNextLikely > 0) activeFilters++;
                if (minNextLikely > 0) activeFilters++;
                if (isSpecificEnsembleActive) activeFilters++;
                
                if (activeFilters > 1) {
                    addLog(`Pattern Match! But CONFLICT: Multiple filters active (${activeFilters}). Only ONE allowed!`, "error");
                    return;
                }
                
                if (activeFilters === 0) {
                    addLog(`Pattern Match! Next Likely: ${detectedPattern.nextDigit} (${currentNextLikely}%) | All Filters: DISABLED - Trading NOW!`, "success");
                    lastTradeTime = now;
                    placeTrade();
                    return;
                }
                
                if (maxNextLikely > 0) {
                    if (currentNextLikely <= maxNextLikely) {
                        addLog(`Pattern Match! Next Likely: ${detectedPattern.nextDigit} (${currentNextLikely}%) ‚â§ ${maxNextLikely}% ‚úì - Trading NOW!`, "success");
                        lastTradeTime = now;
                        placeTrade();
                    } else {
                        addLog(`Pattern Match! Next Likely: ${detectedPattern.nextDigit} (${currentNextLikely}%) > ${maxNextLikely}% ‚úó - SKIPPED (too high)`, "warn");
                    }
                    return;
                }
                
                if (minNextLikely > 0) {
                    if (currentNextLikely >= minNextLikely) {
                        addLog(`Pattern Match! Next Likely: ${detectedPattern.nextDigit} (${currentNextLikely}%) ‚â• ${minNextLikely}% ‚úì - Trading NOW!`, "success");
                        lastTradeTime = now;
                        placeTrade();
                    } else {
                        addLog(`Pattern Match! Next Likely: ${detectedPattern.nextDigit} (${currentNextLikely}%) < ${minNextLikely}% ‚úó - SKIPPED (too low)`, "warn");
                    }
                    return;
                }
                
                if (isSpecificEnsembleActive) {
                    const specificTargets = [
                        parseInt(document.getElementById('specEns1').value),
                        parseInt(document.getElementById('specEns2').value),
                        parseInt(document.getElementById('specEns3').value),
                        parseInt(document.getElementById('specEns4').value),
                        parseInt(document.getElementById('specEns5').value)
                    ].filter(v => !isNaN(v) && v >= 0 && v <= 100);
                    
                    if (specificTargets.includes(currentNextLikely)) {
                        addLog(`Pattern Match! Next Likely: ${detectedPattern.nextDigit} (${currentNextLikely}%) = Target ‚úì - Trading NOW!`, "success");
                        lastTradeTime = now;
                        placeTrade();
                    } else {
                        addLog(`Pattern Match! Next Likely: ${detectedPattern.nextDigit} (${currentNextLikely}%) ‚â† Targets [${specificTargets.join(',')}] ‚úó - SKIPPED`, "warn");
                    }
                    return;
                }
            }
        }
        return;
    }
    
    if (!isSignalWindowOpen) return;

    const now = Date.now();
    const cooldownMs = parseInt(document.getElementById('cooldown').value) * 1000;
    if (now - lastTradeTime < Math.max(cooldownMs, 1000)) return;

    const mode = currentConfidenceMode;
    let isConfidenceMet = false;
    const currentConf = Math.round(lastPredictionConfidence);
    const prevConf = Math.round(previousPredictionConfidence);

    if (mode === 'range') {
        let minConf = parseFloat(document.getElementById('minConfidence').value);
        let maxConf = parseFloat(document.getElementById('maxConfidence').value);
        
        const adjustment = calculateAdaptiveThreshold();
        minConf += adjustment;
        
        if (currentConf >= minConf && currentConf <= maxConf) isConfidenceMet = true;
    } 
    else if (mode === 'specific') {
        const targets = [
            parseInt(document.getElementById('spec1').value),
            parseInt(document.getElementById('spec2').value),
            parseInt(document.getElementById('spec3').value),
            parseInt(document.getElementById('spec4').value),
            parseInt(document.getElementById('spec5').value)
        ];
        if (targets.includes(currentConf)) isConfidenceMet = true;
    }
    else if (mode === 'sequence') {
        const s1_p1 = parseInt(document.getElementById('s1_p1_min').value);
        const s1_p2_min = parseInt(document.getElementById('s1_p2_min').value);
        const s1_p2_max = parseInt(document.getElementById('s1_p2_max').value);
        
        const s2_p1 = parseInt(document.getElementById('s2_p1_min').value);
        const s2_p2_min = parseInt(document.getElementById('s2_p2_min').value);
        const s2_p2_max = parseInt(document.getElementById('s2_p2_max').value);

        const s3_p1 = parseInt(document.getElementById('s3_p1_min').value);
        const s3_p2_min = parseInt(document.getElementById('s3_p2_min').value);
        const s3_p2_max = parseInt(document.getElementById('s3_p2_max').value);

        const match1 = (prevConf >= s1_p1 && currentConf >= s1_p2_min && currentConf <= s1_p2_max);
        const match2 = (prevConf >= s2_p1 && currentConf >= s2_p2_min && currentConf <= s2_p2_max);
        const match3 = (prevConf >= s3_p1 && currentConf >= s3_p2_min && currentConf <= s3_p2_max);

        if (match1 || match2 || match3) isConfidenceMet = true;
    }

    if (lastPredictionType === 'OVER 5' && isConfidenceMet) {
        lastTradeTime = now;
        placeTrade();
    }
}

function updateAnalyzerDisplay() {
  const container = document.getElementById('digitDisplay');
  container.innerHTML = '';
  digitHistory.forEach(digit => {
    const box = document.createElement('div');
    box.className = 'digit-box ' + (digit > 5 ? 'digit-over' : 'digit-under');
    box.textContent = digit;
    container.appendChild(box);
  });
  
  const overCount = digitHistory.filter(d => d > 5).length;
  document.getElementById('overCount').textContent = overCount;
  document.getElementById('totalCount').textContent = digitHistory.length;
  document.getElementById('overPercent').textContent = (digitHistory.length > 0 ? ((overCount / digitHistory.length) * 100).toFixed(1) : 0) + '%';
  
  predictNextDigit();
}

async function predictNextDigit() {
  if (digitHistory.length < 20) {
    document.getElementById('patternMatch').textContent = 'Collecting data... need 20+ ticks';
    detectedPattern = null;
    return;
  }
  
  previousPredictionConfidence = lastPredictionConfidence;

  const last20 = digitHistory.slice(0, 20);
  let weightedUnderScore = 0;
  last20.forEach((digit, index) => {
      const weight = (20 - index) / 20; 
      if (digit <= 5) weightedUnderScore += weight;
  });
  const weightedFreq = (weightedUnderScore / 10.5) * 100;
  
  let overGap = 0;
  for (let d of digitHistory) {
      if (d <= 5) overGap++;
      else break;
  }
  
  const volatility = calculateVolatility(volatilityWindow, 50);
  let volatilityLabel = 'Low';
  let volatilityPenalty = 0;
  
  if (volatility > 3.0) {
      volatilityLabel = 'Extreme';
      volatilityPenalty = -20;
  } else if (volatility > 2.5) {
      volatilityLabel = 'High';
      volatilityPenalty = -15;
  } else if (volatility > 1.8) {
      volatilityLabel = 'Medium';
      volatilityPenalty = -5;
  }
  
  document.getElementById('volatilityScore').textContent = volatilityLabel;
  
  let gravityBonus = 0;
  let trendLabel = 'Stable';
  if (digitHistory.length >= 3) {
      if (digitHistory[0] > digitHistory[1] && digitHistory[1] > digitHistory[2]) {
          gravityBonus = 15;
          trendLabel = 'Rising';
      } else if (digitHistory[0] < digitHistory[1] && digitHistory[1] < digitHistory[2]) {
          gravityBonus = -10;
          trendLabel = 'Falling';
      }
  }
  
  const bayesianProb = updateBayesianModel(digitHistory[0] > 5);
  document.getElementById('bayesianProb').textContent = bayesianProb.toFixed(0) + '%';
  
  const markovProb = calculateMarkovPrediction();
  document.getElementById('markovProb').textContent = markovProb.toFixed(0) + '%';
  
  const psfProb = calculatePSFPrediction();
  document.getElementById('psfScore').textContent = psfProb.toFixed(0) + '%';
  
  const lstmProb = await calculateLSTMPrediction();
  document.getElementById('lstmPred').textContent = lstmProb.toFixed(0) + '%';
  
  let heuristicConf = 0;
  let predText = 'WAIT';
  
  if (overGap >= 3) {
      predText = 'OVER 5';
      heuristicConf = 40 + (overGap * 9) + (weightedFreq * 0.1) + gravityBonus + volatilityPenalty;
  } else if (weightedFreq > 70) {
      predText = 'OVER 5';
      heuristicConf = 45 + (weightedFreq - 70) + gravityBonus + volatilityPenalty;
  }
  
  modelPredictions.heuristic.push({ prediction: predText });
  modelPredictions.bayesian.push({ prediction: bayesianProb });
  modelPredictions.markov.push({ prediction: markovProb });
  
  const ensembleScore = await calculateEnsemblePrediction(
      Math.max(0, heuristicConf), 
      bayesianProb, 
      markovProb, 
      volatility
  );
  
  document.getElementById('ensembleScore').textContent = ensembleScore.toFixed(0) + '%';
  
  lastPredictionConfidence = Math.min(98, Math.max(0, ensembleScore));
  lastPredictionType = predText;
  
  const confAdj = calculateAdaptiveThreshold();
  document.getElementById('confAdj').textContent = (confAdj >= 0 ? '+' : '') + confAdj + '%';
  
  document.getElementById('nextDigitPrediction').textContent = predText;
  document.getElementById('nextDigitPrediction').style.color = predText === 'OVER 5' ? '#22c55e' : '#f59e0b';
  document.getElementById('predictionConfidence').textContent = `${lastPredictionConfidence.toFixed(0)}% (Ensemble v3)`;
  document.getElementById('freqScore').textContent = weightedFreq.toFixed(0) + '%';
  document.getElementById('cycleScore').textContent = overGap;
  
  const pattern = detectPatterns();
  detectedPattern = pattern;
  
  if (pattern) {
      const fuzzyText = pattern.fuzzy ? ` (fuzzy, dist=${pattern.distance})` : '';
      document.getElementById('patternMatch').textContent = `Pattern detected: [${pattern.pattern}]${fuzzyText} ‚Üí Next likely: ${pattern.nextDigit} (${pattern.confidence}%)`;
  } else {
      document.getElementById('patternMatch').textContent = `No repeating patterns found. Using ML ensemble (PSF + LSTM + Bayesian + Markov).`;
  }
}

// ============ TRADING FUNCTIONS ============
function placeTrade() {
  if (!isConnected || isCycleCooldown) return;
  
  const stakeValue = parseFloat(document.getElementById('stake').value);
  const tickValue = parseInt(document.getElementById('duration').value);
  const marketValue = currentMarketValue;
  const type = isReverseTradeActive ? 'DIGITUNDER' : 'DIGITOVER';
  
  // Virtual trade simulation
  if (isCurrentlyVirtualMode()) {
      addLog(`üéÆ VIRTUAL TRADE SIMULATED (Not placing real trade)`, "warn");
      
      setTimeout(() => {
          const simulatedWin = Math.random() > 0.5;
          const simulatedProfit = simulatedWin ? stakeValue * 0.95 : -stakeValue;
          
          handleVirtualTradeResult(simulatedWin);
          
          stats.trades++;
          if (simulatedWin) stats.wins++; else stats.losses++;
          stats.profit += simulatedProfit;
          
          recentWinRates.push(simulatedWin ? 1 : 0);
          if (recentWinRates.length > 20) recentWinRates.shift();
          
          updateStats();
          addToHistory(stats.trades, simulatedWin ? 'Win (Virtual)' : 'Loss (Virtual)', simulatedProfit, marketValue);
          
          addLog(`üéÆ VIRTUAL ${simulatedWin ? 'WIN' : 'LOSS'} | P/L: ${simulatedProfit.toFixed(2)}`, simulatedWin ? 'success' : 'error');
          
          localStorage.setItem('trade_stats_v10', JSON.stringify(stats));
          localStorage.setItem('trade_history_v10', document.getElementById('history').innerHTML);
          
          checkRiskManagement();
      }, 2000);
      
      return;
  }
  
  // Real trade
  let confidenceMsg = '';
  if (currentConfidenceMode === 'pattern' && detectedPattern) {
      const maxNextLikely = parseInt(document.getElementById('patternEnsembleMax').value) || 0;
      const minNextLikely = parseInt(document.getElementById('patternEnsembleMin').value) || 0;
      const nextLikelyPercent = Math.round(detectedPattern.confidence);
      
      if (maxNextLikely === 0 && minNextLikely === 0 && !isSpecificEnsembleActive) {
          confidenceMsg = `Pattern: [${detectedPattern.pattern}] ‚Üí ${detectedPattern.nextDigit} (${nextLikelyPercent}%) | Filters: OFF`;
      } else if (maxNextLikely > 0) {
          confidenceMsg = `Pattern: [${detectedPattern.pattern}] ‚Üí ${detectedPattern.nextDigit} | Next Likely: ${nextLikelyPercent}% ‚â§ ${maxNextLikely}%`;
      } else if (minNextLikely > 0) {
          confidenceMsg = `Pattern: [${detectedPattern.pattern}] ‚Üí ${detectedPattern.nextDigit} | Next Likely: ${nextLikelyPercent}% ‚â• ${minNextLikely}%`;
      } else if (isSpecificEnsembleActive) {
          confidenceMsg = `Pattern: [${detectedPattern.pattern}] ‚Üí ${detectedPattern.nextDigit} | Next Likely: ${nextLikelyPercent}% = Target`;
      }
  } else {
      confidenceMsg = `${lastPredictionConfidence.toFixed(0)}% confidence (PSF+LSTM Ensemble)`;
  }
  
  addLog(`üî¥ LIVE: Executing ${type} trade with ${confidenceMsg}`, "info");
  
  sendAPIRequest({
    buy: 1, 
    price: stakeValue,
    parameters: { 
        contract_type: type, 
        symbol: marketValue, 
        duration: tickValue, 
        duration_unit: 't', 
        barrier: '5', 
        amount: stakeValue,
        basis: 'stake', 
        currency: 'USD' 
    }
  });
}

function toggleAuto() {
  if (!isConnected) return;
  isAutoRunning = !isAutoRunning;
  const btn = document.getElementById('autoBtn');
  const shutdownUI = document.getElementById('shutdownDisplay');

  if (isAutoRunning) {
    autoStartTime = Date.now();
    localStorage.setItem('isAutoRunning', 'true');
    localStorage.setItem('autoStartTime', autoStartTime);
    shutdownUI.style.display = 'block';
    addLog("ML Auto-Trade v3 Enabled (PSF + LSTM).", "success");
    btn.textContent = 'Stop Auto'; 
    btn.style.background = '#ef4444';
    
    // Initialize LSTM on auto-start
    if (!lstmInitialized && extendedHistory.length >= 100) {
        initializeLSTM();
    }
    
    // Build PSF patterns
    if (extendedHistory.length >= 50) {
        buildPSFPatterns();
    }
  } else {
    autoStartTime = null;
    localStorage.removeItem('isAutoRunning');
    localStorage.removeItem('autoStartTime');
    shutdownUI.style.display = 'none';
    addLog("Auto-Trade Stopped.", "warn");
    btn.textContent = 'Start Auto'; 
    btn.style.background = '#22c55e';
  }
}

function toggleMarketCycle() {
    isMarketCycleActive = !isMarketCycleActive;
    const btn = document.getElementById('cycleBtn');
    if (isMarketCycleActive) {
        btn.classList.add('active');
        currentMarketIndex = marketSequence.indexOf(currentMarketValue);
        if(currentMarketIndex === -1) currentMarketIndex = 0;
        btn.textContent = `Auto Market Cycle: ON (${marketSequence[currentMarketIndex]})`;
        addLog(`Market Cycle Sequence Started at ${marketSequence[currentMarketIndex]}.`, "info");
    } else {
        btn.classList.remove('active');
        btn.textContent = "Auto Market Cycle: OFF";
        addLog(`Market Cycle Sequence Disabled.`, "warn");
    }
}

function toggleCooldownLoop() {
    isCooldownLoopActive = !isCooldownLoopActive;
    const btn = document.getElementById('cooldownBtn');
    if (isCooldownLoopActive) {
        btn.classList.add('active');
        btn.textContent = "Cycle Cooldown Loop: ON";
        addLog(`Cycle Cooldown Loop Enabled: Will wait after full sequence.`, "info");
    } else {
        btn.classList.remove('active');
        btn.textContent = "Cycle Cooldown Loop: OFF";
        addLog(`Cycle Cooldown Loop Disabled.`, "warn");
    }
}

function startCycleCooldown() {
    isCycleCooldown = true;
    let waitMinutes = parseInt(document.getElementById('cycleWaitTime').value);
    let secondsLeft = waitMinutes * 60;
    const timerDisplay = document.getElementById('cycleTimerDisplay');
    timerDisplay.style.display = 'block';
    addLog(`Sequence Complete. Cycle Cooldown Loop active: waiting ${waitMinutes}m...`, "warn");

    if (cycleTimerId) clearInterval(cycleTimerId);
    cycleTimerId = setInterval(() => {
        secondsLeft--;
        const mins = Math.floor(secondsLeft / 60);
        const secs = secondsLeft % 60;
        timerDisplay.textContent = `Next Loop in: ${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`;

        if (secondsLeft <= 0) {
            clearInterval(cycleTimerId);
            isCycleCooldown = false;
            timerDisplay.style.display = 'none';
            currentMarketIndex = 0;
            const nextMarket = marketSequence[currentMarketIndex];
            currentMarketValue = nextMarket;
            selectMarket(nextMarket);
            document.getElementById('cycleBtn').textContent = `Auto Market Cycle: ON (${nextMarket})`;
            addLog(`Cooldown finished. Restarting Cycle at ${nextMarket}.`, "success");
            subscribeToTicks();
        }
    }, 1000);
}

function handleTradeResult(contract) {
  const isWin = contract.status === 'won';
  const profitLoss = parseFloat(contract.profit || 0);
  
  const tradeMode = isCurrentlyVirtualMode() ? "VIRTUAL" : "LIVE";
  addLog(`${tradeMode} RESULT: ${isWin ? 'WIN' : 'LOSS'} | P/L: ${profitLoss.toFixed(2)}`, isWin ? 'success' : 'error');
  
  handleVirtualTradeResult(isWin);
  
  stats.trades++; 
  if (isWin) stats.wins++; else stats.losses++; 
  stats.profit += profitLoss;
  
  recentWinRates.push(isWin ? 1 : 0);
  if (recentWinRates.length > 20) recentWinRates.shift();
  
  updateStats();
  
  const historyLabel = isCurrentlyVirtualMode() ? `${isWin ? 'Win' : 'Loss'} (Virtual)` : (isWin ? 'Win' : 'Loss');
  addToHistory(stats.trades, historyLabel, profitLoss, contract.display_name || 'Market');
  localStorage.setItem('trade_stats_v10', JSON.stringify(stats));
  localStorage.setItem('trade_history_v10', document.getElementById('history').innerHTML);

  const tp = parseFloat(document.getElementById('takeprofit').value);
  if (isMarketCycleActive && stats.profit >= tp) {
      if (currentMarketIndex < marketSequence.length - 1) {
          currentMarketIndex++;
          const nextMarket = marketSequence[currentMarketIndex];
          addLog(`Target reached! Switching Market: ${marketSequence[currentMarketIndex-1]} -> ${nextMarket}...`, "success");
          resetStats(); 
          currentMarketValue = nextMarket;
          selectMarket(nextMarket);
          document.getElementById('cycleBtn').textContent = `Auto Market Cycle: ON (${nextMarket})`;
          subscribeToTicks();
          return; 
      } else {
          addLog("Final Market Sequence Finished Successfully.", "success");
          resetStats();
          if (isCooldownLoopActive) {
              startCycleCooldown();
          } else {
              if (isAutoRunning) toggleAuto();
              isMarketCycleActive = false;
              document.getElementById('cycleBtn').classList.remove('active');
              document.getElementById('cycleBtn').textContent = "Auto Market Cycle: OFF";
          }
      }
  }
  checkRiskManagement();
}

function toggleReverseTrade() {
    isReverseTradeActive = !isReverseTradeActive;
    const btn = document.getElementById('reverseBtn');
    if (isReverseTradeActive) {
        btn.classList.add('active');
        btn.textContent = "Reverse Trade: ON (Digit Under 5)";
        addLog("Reverse Mode Activated: Now trading Digit Under 5", "warn");
    } else {
        btn.classList.remove('active');
        btn.textContent = "Reverse Trade: OFF";
        addLog("Normal Mode Activated: Now trading Digit Over 5", "info");
    }
}

// ============ API COMMUNICATION ============
function sendAPIRequest(data) { 
    if (ws && ws.readyState === WebSocket.OPEN) { 
        const now = Date.now();
        if (now - lastRequestTime < 300) {
            setTimeout(() => sendAPIRequest(data), 300);
            return false;
        }
        lastRequestTime = now;
        ws.send(JSON.stringify(data)); 
        return true; 
    } 
    return false; 
}

function subscribeToTicks() {
  const market = currentMarketValue;
  sendAPIRequest({ forget_all: "ticks" });
  digitHistory = [];
  document.getElementById('digitDisplay').innerHTML = '';
  addLog(`Watching ${market}...`, "info");
  sendAPIRequest({ ticks: market, subscribe: 1 });
}

// ============ UI UPDATE FUNCTIONS ============
function updateStatus(text, className) { 
    const s = document.getElementById('status'); 
    s.textContent = text; 
    s.className = 'status ' + className; 
}

function updateBalance() { 
    document.getElementById('balanceDisplay').style.display = 'block'; 
    document.getElementById('balance').textContent = parseFloat(accountBalance).toFixed(2); 
}

function updateStats() {
  document.getElementById('trades').textContent = stats.trades;
  document.getElementById('wins').textContent = stats.wins;
  document.getElementById('losses').textContent = stats.losses;
  const p = document.getElementById('profit');
  p.textContent = stats.profit.toFixed(2);
  p.style.color = stats.profit > 0 ? '#22c55e' : (stats.profit < 0 ? '#ef4444' : '#e5e7eb');
}

function startSessionTimer() {
    if (timerIntervalId) clearInterval(timerIntervalId);
    sessionStartTime = Date.now(); 
    timerIntervalId = setInterval(() => {
        updateSignalWindowTimer();
        const now = Date.now();
        const s = Math.floor((now - sessionStartTime) / 1000);
        document.getElementById('sessionTimer').textContent = `Session: ${Math.floor(s/3600).toString().padStart(2,'0')}:${Math.floor((s%3600)/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`;
        
        if (isAutoRunning && autoStartTime) {
            const limitHours = parseFloat(document.getElementById('autoDurationHrs').value) || 0;
            if (limitHours <= 0) {
                document.getElementById('shutdownDisplay').textContent = `Shutdown in: Unlimited`;
                return;
            }
            const limitMs = limitHours * 3600000;
            const elapsedMs = now - autoStartTime;
            const remainingMs = limitMs - elapsedMs;
            if (remainingMs <= 0) {
                addLog("Trade Duration Elapsed. Auto-Shutdown triggered.", "warn");
                toggleAuto();
            } else {
                const remS = Math.floor(remainingMs / 1000);
                const h = Math.floor(remS / 3600).toString().padStart(2, '0');
                const m = Math.floor((remS % 3600) / 60).toString().padStart(2, '0');
                const sec = (remS % 60).toString().padStart(2, '0');
                document.getElementById('shutdownDisplay').textContent = `Shutdown in: ${h}:${m}:${sec}`;
            }
        }
    }, 1000);
}

function checkRiskManagement() {
  const sl = parseFloat(document.getElementById('stoploss').value);
  const tp = parseFloat(document.getElementById('takeprofit').value);
  
  if (stats.profit <= -sl) { 
    if (isAutoRunning) toggleAuto(); 
    addLog("Stop Loss Met. Trading stopped.", "error"); 
  }
  
  if (!isMarketCycleActive && stats.profit >= tp) {
    if (isAutoRunning) toggleAuto();
    addLog("Take Profit achieved! Trading stopped.", "success");
  }
}

function addToHistory(n, res, pl, m) {
  const row = document.getElementById('history').insertRow(0);
  const cls = res.includes('Win') ? 'win' : 'loss';
  row.innerHTML = `<td>${n}</td><td class="${cls}">${res}</td><td class="${cls}">${pl.toFixed(2)}</td><td>${m}</td>`;
}

function resetStats() { 
    stats = { trades: 0, wins: 0, losses: 0, profit: 0 }; 
    recentWinRates = [];
    
    // Reset virtual trade tracking
    virtualLossStreak = 0;
    hasSwatchedToLive = false;
    updateVirtualTradeUI();
    
    modelAccuracies = {
        heuristic: 0,
        bayesian: 0,
        markov: 0,
        psf: 0,
        lstm: 0
    };
    modelPredictions = {
        heuristic: [],
        bayesian: [],
        markov: [],
        psf: [],
        lstm: []
    };
    
    updateStats(); 
    updateModelPerformanceUI();
    document.getElementById('history').innerHTML = ''; 
    localStorage.removeItem('trade_stats_v10');
    localStorage.removeItem('trade_history_v10');
    addLog("All stats reset.", "info");
    
    saveSettings();
}

function manualTrade() { 
    if (isConnected) {
        placeTrade(); 
    } else {
        addLog("Not connected. Please login first.", "error");
    }
}

// ============ INITIALIZATION ============
window.onload = () => {
  addLog("Initializing ML Enhanced Trading Bot v3 (PSF + LSTM + Virtual Trade)...", "info");
  loadSettings();
  
  const ensembleMaxInput = document.getElementById('patternEnsembleMax');
  const ensembleMinInput = document.getElementById('patternEnsembleMin');
  const specEnsInputs = ['specEns1', 'specEns2', 'specEns3', 'specEns4', 'specEns5'];
  
  if (ensembleMaxInput) {
      ensembleMaxInput.addEventListener('input', updateEnsembleFilterStatus);
      ensembleMaxInput.addEventListener('change', updateEnsembleFilterStatus);
  }
  
  if (ensembleMinInput) {
      ensembleMinInput.addEventListener('input', updateEnsembleFilterStatus);
      ensembleMinInput.addEventListener('change', updateEnsembleFilterStatus);
  }
  
  specEnsInputs.forEach(id => {
      const input = document.getElementById(id);
      if (input) {
          input.addEventListener('input', saveSettings);
          input.addEventListener('change', saveSettings);
      }
  });
  
  // Virtual loss threshold listener
  const virtualThresholdInput = document.getElementById('virtualLossThreshold');
  if (virtualThresholdInput) {
      virtualThresholdInput.addEventListener('input', () => {
          updateVirtualTradeUI();
          saveSettings();
      });
      virtualThresholdInput.addEventListener('change', () => {
          updateVirtualTradeUI();
          saveSettings();
      });
  }
  
  updateEnsembleFilterStatus();
  
  const savedToken = sessionStorage.getItem('derivToken');
  if (savedToken) { 
      document.getElementById('token').value = savedToken; 
      setTimeout(connect, 1000); 
  }
  
  addLog("‚úÖ ML v3 Enhancements Loaded:", "success");
  addLog("- Extended history: 5000 ticks", "info");
  addLog("- Outlier detection & smoothing active", "info");
  addLog("- 2nd-order Markov chain enabled", "info");
  addLog("- Fuzzy pattern matching with Levenshtein", "info");
  addLog("- PSF (Pattern Sequence Forecasting) implemented", "info");
  addLog("- LSTM Neural Network with auto-training", "info");
  addLog("- Auto-adjusted hyperparameters (window, batch, epochs)", "info");
  addLog("- Dynamic ensemble weighting based on performance", "info");
  addLog("- Model performance tracking for all 5 models", "info");
  addLog("- Pattern decay & pruning", "info");
  addLog("- Pattern Mode uses Next Likely % for filters", "info");
  addLog("- üéÆ Virtual Trade Mode with auto-switch feature", "success");
  addLog("- Auto-retrain LSTM every 200 digits", "info");
  addLog("- Auto-rebuild PSF patterns every 100 digits", "info");
  addLog("Ready to trade with PSF + LSTM enhanced accuracy!", "success");
};

document.getElementById('logoutBtn').addEventListener('click', () => { 
    isExplicitLogout = true; 
    localStorage.removeItem('isAutoRunning');
    localStorage.removeItem('autoStartTime');
    
    // Clear LSTM retrain interval
    if (lstmRetrainInterval) {
        clearInterval(lstmRetrainInterval);
        lstmRetrainInterval = null;
    }
    
    // Dispose LSTM model to free memory
    if (lstmModel) {
        lstmModel.dispose();
        lstmModel = null;
        lstmInitialized = false;
    }
    
    if (ws) ws.close(); 
    sessionStorage.removeItem('derivToken'); 
    addLog("Logging out...", "info");
    setTimeout(() => location.reload(), 500);
});
</script>
</body>
</html>