<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Deriv Digit Match Pro - Advanced ML</title>
<style>
/* --- CORE STYLES --- */
body { background: #020617; color: #e5e7eb; font-family: system-ui, -apple-system, sans-serif; margin: 0; padding: 0; }
.app { max-width: 420px; margin: auto; padding: 15px; }
.card { background: #0f172a; padding: 12px; border-radius: 12px; margin-bottom: 12px; border: 1px solid #1e293b; }
h2, h3 { text-align: center; margin-bottom: 8px; margin-top: 8px; }
h2 { color: #22c55e; }
label { font-size: 13px; opacity: 0.8; display: block; margin-top: 8px; }
input[type="number"], input[type="password"], select, button { width: 100%; padding: 10px; margin: 5px 0 10px; border-radius: 8px; border: none; box-sizing: border-box; }
input, select { background: #1e293b; color: #e5e7eb; border: 1px solid #334155; }
input:focus, select:focus { outline: none; border-color: #22c55e; }
button { background: #22c55e; color: #020617; font-weight: 700; cursor: pointer; transition: all 0.2s; }
button:hover { background: #16a34a; transform: translateY(-1px); }
button:active { transform: translateY(0); }
button:disabled { background: #374151; cursor: not-allowed; opacity: 0.5; }
.buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 12px; }
.status-container { display: flex; gap: 5px; margin-bottom: 10px; }
.status { flex: 2; text-align: center; padding: 8px; border-radius: 8px; font-weight: 600; }
.account-type { flex: 1.5; text-align: center; padding: 8px; border-radius: 8px; font-weight: 700; font-size: 11px; display: none; text-transform: uppercase; align-self: center; }
.demo-badge { background: #f59e0b; color: #020617; }
.live-badge { background: #22c55e; color: #020617; }
.connected { background: #16a34a; color: white; }
.disconnected { background: #dc2626; color: white; }
.stats { display: grid; grid-template-columns: repeat(4, 1fr); text-align: center; gap: 10px; }
.stats > div { display: flex; flex-direction: column; gap: 5px; }
.stats span { font-size: 12px; opacity: 0.7; }
.stats b { font-size: 16px; color: #22c55e; }
.table-container { overflow-x: auto; max-height: 300px; overflow-y: auto; }
table { width: 100%; font-size: 13px; border-collapse: collapse; }
thead { position: sticky; top: 0; background: #1e293b; }
th { padding: 8px; text-align: left; font-weight: 600; border-bottom: 2px solid #334155; }
td { padding: 8px; border-bottom: 1px solid #1e293b; }
tbody tr:hover { background: #1e293b; }
.win { color: #22c55e; }
.loss { color: #ef4444; }
.balance-display { text-align: center; padding: 10px; background: #0f172a; border-radius: 8px; margin-bottom: 10px; border: 1px solid #1e293b; }
.balance-display span { opacity: 0.7; font-size: 14px; }
.balance-display b { color: #22c55e; font-size: 18px; margin: 0 5px; }
.session-timer { margin-top: 8px; font-size: 12px; color: #f59e0b; font-weight: 600; }
.reset-button-permanent { background: #f59e0b !important; width: 100%; margin-bottom: 12px; font-size: 15px; display: block; }
.reset-button-permanent:hover { background: #d97706 !important; }
.analyzer-grid { display: grid; grid-template-columns: repeat(10, 1fr); gap: 5px; margin: 10px 0; }
.digit-box { aspect-ratio: 1; display: flex; align-items: center; justify-content: center; border-radius: 6px; font-weight: 700; font-size: 14px; border: 2px solid transparent; }
.digit-match { background: #8b5cf6; color: white; border-color: #22c55e; }
.digit-other { background: #1e293b; color: #94a3b8; }
.analyzer-stats { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; text-align: center; margin-top: 10px; }
.analyzer-stats > div { background: #1e293b; padding: 8px; border-radius: 6px; }
.analyzer-stats span { font-size: 11px; opacity: 0.7; display: block; }
.analyzer-stats b { font-size: 18px; display: block; margin-top: 3px; }
.log-container { background: #020617; border: 1px solid #1e293b; border-radius: 6px; height: 120px; overflow-y: auto; padding: 8px; font-family: 'Courier New', monospace; font-size: 11px; margin-top: 10px; }
.log-entry { margin-bottom: 4px; border-bottom: 1px solid #1e293b; padding-bottom: 2px; }
.log-time { color: #94a3b8; margin-right: 5px; }
.log-msg-info { color: #3b82f6; }
.log-msg-success { color: #22c55e; }
.log-msg-error { color: #ef4444; }
.log-msg-warn { color: #f59e0b; }
.btn-cycle { background: #3b82f6; color: white; margin-bottom: 5px; font-size: 14px; }
.btn-cycle.active { background: #8b5cf6; border: 2px solid #fff; }
.btn-cooldown { background: #475569; color: white; margin-bottom: 5px; font-size: 14px; }
.btn-cooldown.active { background: #f59e0b; color: #020617; border: 2px solid #020617; }
.cycle-timer-display { color: #f59e0b; font-size: 13px; font-weight: bold; text-align: center; margin-bottom: 10px; display: none; padding: 8px; border: 2px dashed #f59e0b; border-radius: 8px; background: rgba(245, 158, 11, 0.1); }

/* Radio Button Styles */
.radio-group { margin: 10px 0; }
.radio-option { display: flex; align-items: center; padding: 8px; margin: 5px 0; background: #1e293b; border-radius: 6px; cursor: pointer; border: 2px solid #334155; transition: all 0.2s; }
.radio-option:hover { border-color: #22c55e; background: #1e3a2b; }
.radio-option input[type="radio"] { margin-right: 10px; cursor: pointer; width: auto; }
.radio-option.selected { border-color: #22c55e; background: #1e3a2b; }
.radio-option label { cursor: pointer; margin: 0; opacity: 1; font-size: 13px; font-weight: 600; width: 100%; }

/* Prediction & Metrics */
.prediction-box { background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); border: 2px solid #8b5cf6; border-radius: 8px; padding: 15px; margin: 10px 0; text-align: center; }
.prediction-status { font-size: 14px; font-weight: 700; color: #94a3b8; margin-bottom: 10px; }
.prediction-digit { font-size: 48px; font-weight: 900; margin: 15px 0; }
.prediction-waiting { color: #f59e0b; }
.prediction-ready { color: #22c55e; animation: pulse 1.5s infinite; }
@keyframes pulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.8; transform: scale(1.05); }
}
.prediction-info { font-size: 11px; opacity: 0.7; margin-top: 10px; line-height: 1.5; }

.accuracy-metrics { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-top: 12px; }
.accuracy-card { background: #020617; padding: 10px; border-radius: 6px; border: 1px solid #334155; text-align: center; }
.accuracy-card .label { font-size: 10px; color: #94a3b8; margin-bottom: 5px; }
.accuracy-card .value { font-size: 18px; font-weight: 700; color: #8b5cf6; }
.confidence-bar { width: 100%; height: 8px; background: #1e293b; border-radius: 4px; overflow: hidden; margin-top: 10px; }
.confidence-fill { height: 100%; background: linear-gradient(90deg, #ef4444, #f59e0b, #22c55e); transition: width 0.3s; }
.pattern-indicator { margin-top: 10px; padding: 8px; background: #1e293b; border-radius: 6px; font-size: 11px; }
.pattern-strong { border-left: 4px solid #22c55e; }
.pattern-medium { border-left: 4px solid #f59e0b; }
.pattern-weak { border-left: 4px solid #ef4444; }

/* Model Order Selector */
.model-order-selector { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin: 10px 0; }
.order-option { padding: 8px; border-radius: 6px; border: 2px solid #334155; background: #1e293b; cursor: pointer; text-align: center; transition: all 0.2s; }
.order-option:hover { border-color: #8b5cf6; }
.order-option.active { border-color: #22c55e; background: #1e3a2b; }
.order-option .order-label { font-size: 10px; color: #94a3b8; }
.order-option .order-name { font-size: 13px; font-weight: 700; color: #e5e7eb; margin-top: 3px; }

/* Progress Bar for Data Gathering */
.data-progress { margin-top: 10px; }
.data-progress-bar { width: 100%; height: 6px; background: #1e293b; border-radius: 3px; overflow: hidden; }
.data-progress-fill { height: 100%; background: linear-gradient(90deg, #ef4444, #f59e0b, #22c55e); transition: width 0.3s; }
.data-progress-text { font-size: 11px; color: #94a3b8; margin-top: 5px; text-align: center; }

/* Toggle Switch Style */
.switch-container { display: flex; justify-content: space-between; align-items: center; background: #1e293b; padding: 10px; border-radius: 8px; border: 1px solid #ef4444; margin-bottom: 10px; }
.switch-label { color: #ef4444; font-weight: bold; font-size: 14px; }
.toggle-checkbox { width: 20px !important; height: 20px !important; margin: 0 !important; cursor: pointer; }

/* Virtual Trade Styles */
.virtual-trade-container { background: #1e293b; padding: 10px; border-radius: 8px; border: 2px solid #8b5cf6; margin-bottom: 10px; }
.virtual-trade-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
.virtual-trade-label { color: #8b5cf6; font-weight: bold; font-size: 14px; }
.virtual-mode-badge { background: #8b5cf6; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 700; display: none; }
.virtual-mode-badge.active { display: inline-block; animation: blink 1.5s infinite; }
@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}
.virtual-stats { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-top: 10px; }
.virtual-stat-box { background: #0f172a; padding: 8px; border-radius: 6px; text-align: center; border: 1px solid #334155; }
.virtual-stat-box span { font-size: 10px; color: #94a3b8; display: block; }
.virtual-stat-box b { font-size: 16px; color: #8b5cf6; display: block; margin-top: 3px; }
</style>
</head>
<body>
<div class="app">

<h2>Deriv Digit Match Pro - ML</h2>

<div class="status-container">
    <div id="status" class="status disconnected">Disconnected</div>
    <div id="accountType" class="account-type"></div>
</div>

<div id="balanceDisplay" class="balance-display" style="display:none;">
  <span>Balance:</span>
  <b id="balance">0.00</b>
  <span id="balanceCurrency">USD</span>
  <div id="sessionTimer" class="session-timer">Session: 00:00:00</div>
</div>

<div class="card">
  <input id="token" type="password" placeholder="Deriv API Token" required>
  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <button id="loginBtn">Login</button>
    <button id="logoutBtn" style="background: #ef4444;">Logout</button>
  </div>
</div>

<div class="card">
  <h3>ðŸ§  Advanced ML Digit Analyzer</h3>
  
  <div style="margin-bottom: 10px;">
    <label style="margin-bottom: 5px;">Markov Chain Order (Pattern Depth)</label>
    <div class="model-order-selector">
      <div class="order-option active" data-order="1">
        <div class="order-label">Fast</div>
        <div class="order-name">Order 1</div>
      </div>
      <div class="order-option" data-order="2">
        <div class="order-label">Balanced</div>
        <div class="order-name">Order 2</div>
      </div>
      <div class="order-option" data-order="3">
        <div class="order-label">Deep</div>
        <div class="order-name">Order 3</div>
      </div>
    </div>
    <div style="font-size: 10px; opacity: 0.7; text-align: center; margin-top: 5px;">
      Higher orders = better pattern detection, requires more data
    </div>
  </div>
  
  <div class="analyzer-grid" id="digitDisplay"></div>
  <div class="analyzer-stats">
    <div><span>Last Digit</span><b id="matchCount" style="color: #8b5cf6;">-</b></div>
    <div><span>Total Ticks</span><b id="totalCount" style="color: #e5e7eb;">0</b></div>
    <div><span>Model Order</span><b id="currentOrder" style="color: #22c55e;">1</b></div>
  </div>
  
  <div class="prediction-box">
    <div class="prediction-status">ðŸŽ¯ Multi-Order Markov Prediction</div>
    <div class="prediction-digit" id="predictionDisplay">
      <span class="prediction-waiting">WAITING...</span>
    </div>
    <div class="confidence-bar">
      <div class="confidence-fill" id="confidenceBar" style="width: 0%"></div>
    </div>
    <div class="prediction-info" id="predictionInfo">Analyzing tick patterns...</div>
    
    <!-- Data Gathering Progress Bar -->
    <div class="data-progress" id="dataProgress" style="display: none;">
      <div class="data-progress-bar">
        <div class="data-progress-fill" id="dataProgressFill" style="width: 0%"></div>
      </div>
      <div class="data-progress-text" id="dataProgressText">Gathering data: 0/15 samples</div>
    </div>
    
    <div class="accuracy-metrics">
      <div class="accuracy-card">
        <div class="label">Probability</div>
        <div class="value" id="probabilityValue">0%</div>
      </div>
      <div class="accuracy-card">
        <div class="label">Data Points</div>
        <div class="value" id="patternScore">0</div>
      </div>
      <div class="accuracy-card">
        <div class="label">Frequency</div>
        <div class="value" id="frequencyValue">0%</div>
      </div>
    </div>
    
    <div id="patternIndicator" class="pattern-indicator pattern-weak">
      <strong>Pattern Strength:</strong> <span id="patternStrength">Learning...</span>
    </div>
  </div>

  <div style="margin-top: 15px; border-top: 1px solid #334155; padding-top: 10px;">
    <div style="font-size: 12px; font-weight: 600; color: #94a3b8; display: flex; justify-content: space-between;">
      <span>SYSTEM & TRADE LOG</span>
      <span id="clearLog" style="cursor:pointer; color:#3b82f6">Clear</span>
    </div>
    <div class="log-container" id="logContainer">
      <div class="log-entry"><span class="log-time">[System]</span> <span class="log-msg-success">ML Engine Ready.</span></div>
    </div>
  </div>
</div>

<div class="card">
  <h3>Trade Settings</h3>
  
  <!-- Virtual Trade Section -->
  <div class="virtual-trade-container">
    <div class="virtual-trade-header">
      <div style="display:flex; flex-direction:column;">
        <span class="virtual-trade-label">ðŸŽ® Virtual Trade Mode</span>
        <span style="font-size:9px; opacity:0.6;">Practice until consecutive losses hit, then go LIVE</span>
      </div>
      <div style="display:flex; align-items:center; gap: 8px;">
        <span class="virtual-mode-badge" id="virtualModeBadge">VIRTUAL MODE</span>
        <div style="display:flex; align-items:center;">
          <span style="font-size:10px; margin-right:5px; opacity:0.7;">OFF/ON</span>
          <input type="checkbox" id="virtualTradeToggle" class="toggle-checkbox save-setting">
        </div>
      </div>
    </div>
    
    <label style="margin-top: 5px;">Consecutive Losses to Switch to Live</label>
    <input id="virtualLossThreshold" class="save-setting" type="number" value="3" min="1" max="20" step="1">
    
    <div class="virtual-stats">
      <div class="virtual-stat-box">
        <span>Consecutive Losses</span>
        <b id="virtualConsecLosses">0</b>
      </div>
      <div class="virtual-stat-box">
        <span>Virtual Trades</span>
        <b id="virtualTotalTrades">0</b>
      </div>
      <div class="virtual-stat-box">
        <span>Virtual P/L</span>
        <b id="virtualProfit">0.00</b>
      </div>
    </div>
  </div>
  
  <label>Stake ($)</label>
  <input id="stake" class="save-setting" type="number" value="1" min="0.35" step="0.01">
  <label>Duration (Ticks)</label>
  <input id="duration" class="save-setting" type="number" value="1" min="1" max="10">
  <label>Cooldown (seconds)</label>
  <input id="cooldown" class="save-setting" type="number" value="2" min="1">
  
  <label>Minimum Confidence Threshold (%)</label>
  <input id="minConfidence" class="save-setting" type="number" value="15" min="0" max="100" step="5">

  <label>Manual Digit Override (0 = Auto Mode)</label>
  <input id="manualDigit" class="save-setting" type="number" value="0" min="0" max="9" step="1">

  <div style="margin-top: 15px; border-top: 1px solid #334155; padding-top: 15px;">
    <div class="switch-container">
      <div style="display:flex; flex-direction:column;">
        <span class="switch-label">âš¡ Exclusive Prediction Mapper</span>
        <span style="font-size:9px; opacity:0.6;">ONLY trades if Prediction matches Condition.</span>
      </div>
      <div style="display:flex; align-items:center;">
        <span style="font-size:10px; margin-right:5px; opacity:0.7;">OFF/ON</span>
        <input type="checkbox" id="mapperToggle" class="toggle-checkbox save-setting">
      </div>
    </div>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
      <div>
        <label style="font-size: 11px; color: #94a3b8; margin-top:0;">IF AI PREDICTS:</label>
        <input id="mapperTrigger" class="save-setting" type="number" placeholder="Trigger" min="0" max="9" style="border: 1px solid #ef4444; text-align: center;">
      </div>
      <div>
        <label style="font-size: 11px; color: #94a3b8; margin-top:0;">THEN TRADE:</label>
        <input id="mapperTarget" class="save-setting" type="number" placeholder="Target" min="0" max="9" style="border: 1px solid #22c55e; text-align: center;">
      </div>
    </div>
    <div style="font-size: 10px; opacity: 0.8; color: #fca5a5; margin-top: 5px; text-align: center;">
       Logic: If ON, bot ignores ALL predictions except Trigger.
    </div>
  </div>

  <label style="margin-top: 15px;">Market</label>
  <div class="radio-group" id="marketRadios">
      <div class="radio-option" data-market="R_10">
          <input type="radio" name="market" value="R_10" id="marketR10" checked>
          <label for="marketR10">R_10</label>
      </div>
      <div class="radio-option" data-market="R_25">
          <input type="radio" name="market" value="R_25" id="marketR25">
          <label for="marketR25">R_25</label>
      </div>
      <div class="radio-option" data-market="R_50">
          <input type="radio" name="market" value="R_50" id="marketR50">
          <label for="marketR50">R_50</label>
      </div>
      <div class="radio-option" data-market="R_75">
          <input type="radio" name="market" value="R_75" id="marketR75">
          <label for="marketR75">R_75</label>
      </div>
      <div class="radio-option" data-market="R_100">
          <input type="radio" name="market" value="R_100" id="marketR100">
          <label for="marketR100">R_100</label>
      </div>
  </div>
</div>

<div class="card">
  <h3>Risk Management</h3>
  <label>Stop Loss ($)</label>
  <input id="stoploss" class="save-setting" type="number" value="10" min="1">
  <label>Take Profit ($)</label>
  <input id="takeprofit" class="save-setting" type="number" value="10" min="1">
</div>

<button id="cycleBtn" class="btn-cycle">Auto Market Cycle: OFF</button>
<button id="cooldownBtn" class="btn-cooldown">Cycle Cooldown Loop: OFF</button>
<div id="cycleTimerDisplay" class="cycle-timer-display">Next Loop in: --:--</div>

<div class="card" style="margin-top: 0;">
  <label>Wait Time (Minutes)</label>
  <input id="cycleWaitTime" class="save-setting" type="number" value="5" min="1">
</div>

<div class="buttons">
  <button id="manualBtn">Manual Trade</button>
  <button id="autoBtn">Start Auto</button>
</div>

<button id="resetBtn" class="reset-button-permanent">ðŸ”„ Reset All Stats</button>

<div class="card stats">
  <div><span>Trades</span><b id="trades">0</b></div>
  <div><span>Wins</span><b id="wins">0</b></div>
  <div><span>Losses</span><b id="losses">0</b></div>
  <div><span>P/L</span><b id="profit">0.00</b></div>
</div>

<div class="card">
<h3>Trade History</h3>
<div class="table-container">
<table>
<thead><tr><th>#</th><th>Mode</th><th>Result</th><th>P/L</th><th>Market</th></tr></thead>
<tbody id="history"></tbody>
</table>
</div>
</div>

</div>

<script>
(function() {
  'use strict';
  
  // ============ SHARED CONFIG ============
  const Config = {
    currentMarketValue: 'R_10',
    marketSequence: ["R_10", "R_25", "R_50", "R_75", "R_100"],
    accountBalance: 0
  };

  // ============ APP MODULES ============
  const App = {
    modules: {},
    init() {
      this.modules.UI.init();
      this.modules.Connection.init();
      this.modules.Analyzer.init();
      this.modules.VirtualTrade.init();
      this.modules.Trader.init();
      
      this.modules.UI.loadSettings();
      
      const savedToken = sessionStorage.getItem('derivToken');
      if (savedToken) { 
        document.getElementById('token').value = savedToken; 
        setTimeout(() => this.modules.Connection.connect(), 1000); 
      }
      
      this.modules.UI.addLog("System: ML Engine Initialized.", "success");
    }
  };

  // ============ CONNECTION MODULE ============
  App.modules.Connection = (function() {
    let ws = null;
    let isConnected = false;
    let isExplicitLogout = false;
    let lastRequestTime = 0;
    
    function connect() {
      const token = document.getElementById('token').value.trim();
      if (!token) { 
        App.modules.UI.addLog("Error: API Token missing.", "error"); 
        return; 
      }
      if (ws) ws.close();
      sessionStorage.setItem('derivToken', token);
      isExplicitLogout = false;
      App.modules.UI.updateStatus('Connecting...', 'disconnected');
      
      ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=1089');
      
      ws.onopen = () => { 
        App.modules.UI.addLog("WebSocket Connected.", "info"); 
        sendAPIRequest({ authorize: token }); 
      };
      
      ws.onmessage = (msg) => handleMessage(JSON.parse(msg.data));
      
      ws.onclose = () => {
        isConnected = false;
        App.modules.UI.updateStatus('Disconnected', 'disconnected');
        document.getElementById('accountType').style.display = 'none';
        if (!isExplicitLogout) { 
          App.modules.UI.addLog("Connection lost. Reconnecting in 5s...", "warn"); 
          setTimeout(connect, 5000); 
        }
      };
      
      ws.onerror = (error) => { console.error("WebSocket error:", error); };
    }
    
    function handleMessage(data) {
      if (data.error) { 
        App.modules.UI.addLog(`API ERROR: ${data.error.message}`, "error"); 
        return; 
      }
      
      if (data.authorize) {
        isConnected = true;
        App.modules.UI.updateStatus('Connected', 'connected');
        const accTypeEl = document.getElementById('accountType');
        const isVirtual = data.authorize.is_virtual === 1 || data.authorize.loginid.includes('VRTC');
        accTypeEl.textContent = isVirtual ? 'Demo Account' : 'Live Account';
        accTypeEl.className = 'account-type ' + (isVirtual ? 'demo-badge' : 'live-badge');
        accTypeEl.style.display = 'block';
        App.modules.UI.addLog(`Authorized: ${data.authorize.email}`, "success");
        sendAPIRequest({ balance: 1, subscribe: 1 });
        subscribeToTicks();
        App.modules.UI.startSessionTimer();
        
        const persistedAuto = localStorage.getItem('isAutoRunning') === 'true';
        if(persistedAuto && !App.modules.Trader.getAutoRunning()) {
          App.modules.Trader.resumeAutoTrade();
        }
      }
      
      if (data.balance) { 
        Config.accountBalance = data.balance.balance; 
        App.modules.UI.updateBalance(); 
      }
      
      if (data.tick) {
        const lastDigit = parseInt(data.tick.quote.toString().slice(-1));
        App.modules.Analyzer.processTick(lastDigit);
      }
      
      if (data.buy) {
        App.modules.Trader.setContractId(data.buy.contract_id);
        App.modules.UI.addLog(`Trade Placed (ID: ${data.buy.contract_id})`, "success");
        sendAPIRequest({ proposal_open_contract: 1, contract_id: data.buy.contract_id, subscribe: 1 });
      }
      
      if (data.proposal_open_contract) {
        const contract = data.proposal_open_contract;
        if (contract.is_settled === 1 || ['won', 'lost', 'sold'].includes(contract.status)) {
          App.modules.Trader.handleTradeResult(contract);
          App.modules.Trader.setContractId(null);
          if (data.subscription) sendAPIRequest({ forget: data.subscription.id });
        }
      }
    }
    
    function sendAPIRequest(data) { 
      if (ws && ws.readyState === WebSocket.OPEN) { 
        const now = Date.now();
        if (now - lastRequestTime < 100) { 
          setTimeout(() => sendAPIRequest(data), 100);
          return false;
        }
        lastRequestTime = now;
        ws.send(JSON.stringify(data)); 
        return true; 
      } 
      return false; 
    }
    
    function subscribeToTicks() {
      const market = Config.currentMarketValue;
      sendAPIRequest({ forget_all: "ticks" });
      App.modules.Analyzer.resetForNewMarket();
      document.getElementById('digitDisplay').innerHTML = '';
      App.modules.UI.addLog(`Watching ${market}...`, "info");
      sendAPIRequest({ ticks: market, subscribe: 1 });
    }
    
    return {
      init() {
        document.getElementById('loginBtn').addEventListener('click', connect);
        document.getElementById('logoutBtn').addEventListener('click', () => { 
          isExplicitLogout = true; 
          localStorage.removeItem('isAutoRunning');
          if (ws) ws.close(); 
          sessionStorage.removeItem('derivToken'); 
          App.modules.UI.addLog("Logging out...", "info");
          setTimeout(() => location.reload(), 500);
        });
      },
      connect,
      subscribeToTicks,
      sendAPIRequest,
      isConnected: () => isConnected
    };
  })();

  // ============ ADVANCED ANALYZER MODULE (HIGHER-ORDER MARKOV CHAINS) ============
  App.modules.Analyzer = (function() {
    let digitHistory = [];
    let currentOrder = 1; // 1, 2, or 3
    
    // Order 1: Standard transition matrix
    let transitionMatrix1 = Array(10).fill(0).map(() => Array(10).fill(0));
    let totalTransitions1 = Array(10).fill(0);
    
    // Order 2: 2-digit sequence tracking
    let transitionMatrix2 = {}; // Key: "d1,d2" -> Value: Array(10) for next digit counts
    let totalTransitions2 = {}; // Key: "d1,d2" -> Total count
    
    // Order 3: 3-digit sequence tracking
    let transitionMatrix3 = {}; // Key: "d1,d2,d3" -> Value: Array(10) for next digit counts
    let totalTransitions3 = {}; // Key: "d1,d2,d3" -> Total count
    
    let predictedDigit = null;
    let predictionConfidence = 0;
    let lastDigit = null;
    
    // Laplace smoothing parameter
    const SMOOTHING_ALPHA = 0.1;
    
    function processTick(digit) {
      lastDigit = digit;
      
      // 1. Update History
      digitHistory.unshift(digit);
      if (digitHistory.length > 1000) digitHistory.pop();
      
      // 2. Update all order models
      updateAllModels(digit);
      
      // 3. Calculate prediction based on current order
      const duration = parseInt(document.getElementById('duration').value);
      const steps = duration;
      const internalPred = calculatePrediction(digit, steps);
      
      // 4. Process virtual trade
      App.modules.VirtualTrade.processTickResult(digit);
      
      // 5. Trade check
      if (App.modules.Trader.getAutoRunning() && !App.modules.Trader.getCycleCooldown()) {
        App.modules.Trader.checkAndAutoTrade(internalPred); 
      }
      
      // 6. Update UI
      updateDisplay();
      updatePredictionUI(internalPred, digit);
    }
    
    function updateAllModels(digit) {
      const len = digitHistory.length;
      
      // Update Order 1
      if (len > 1) {
        const prev1 = digitHistory[1];
        transitionMatrix1[prev1][digit]++;
        totalTransitions1[prev1]++;
      }
      
      // Update Order 2
      if (len > 2) {
        const prev1 = digitHistory[1];
        const prev2 = digitHistory[2];
        const key2 = `${prev2},${prev1}`;
        
        if (!transitionMatrix2[key2]) {
          transitionMatrix2[key2] = Array(10).fill(0);
          totalTransitions2[key2] = 0;
        }
        transitionMatrix2[key2][digit]++;
        totalTransitions2[key2]++;
      }
      
      // Update Order 3
      if (len > 3) {
        const prev1 = digitHistory[1];
        const prev2 = digitHistory[2];
        const prev3 = digitHistory[3];
        const key3 = `${prev3},${prev2},${prev1}`;
        
        if (!transitionMatrix3[key3]) {
          transitionMatrix3[key3] = Array(10).fill(0);
          totalTransitions3[key3] = 0;
        }
        transitionMatrix3[key3][digit]++;
        totalTransitions3[key3]++;
      }
    }
    
    function calculatePrediction(lastDigit, steps = 1) {
      if (currentOrder === 1) {
        return predictOrder1(lastDigit, steps);
      } else if (currentOrder === 2) {
        return predictOrder2(steps);
      } else {
        return predictOrder3(steps);
      }
    }
    
    function predictOrder1(lastDigit, steps) {
      const total = totalTransitions1[lastDigit];
      if (total < 15) return { digit: null, confidence: 0, current: total, required: 15 };
      
      // Build probability matrix with Laplace smoothing
      const probMatrix = Array(10).fill().map(() => Array(10).fill(0));
      for (let i = 0; i < 10; i++) {
        const tot = totalTransitions1[i] || 0;
        for (let j = 0; j < 10; j++) {
          if (tot > 0) {
            probMatrix[i][j] = (transitionMatrix1[i][j] + SMOOTHING_ALPHA) / (tot + 10 * SMOOTHING_ALPHA);
          } else {
            probMatrix[i][j] = 0.1;
          }
        }
      }
      
      // Multi-step prediction
      let currentProb = Array(10).fill(0);
      for (let j = 0; j < 10; j++) {
        currentProb[j] = probMatrix[lastDigit][j];
      }
      
      for (let s = 1; s < steps; s++) {
        let newProb = Array(10).fill(0);
        for (let i = 0; i < 10; i++) {
          for (let j = 0; j < 10; j++) {
            newProb[j] += currentProb[i] * probMatrix[i][j];
          }
        }
        currentProb = newProb;
      }
      
      let bestDigit = 0;
      let maxProb = currentProb[0];
      for (let i = 1; i < 10; i++) {
        if (currentProb[i] > maxProb) {
          maxProb = currentProb[i];
          bestDigit = i;
        }
      }
      
      return { digit: bestDigit, confidence: maxProb * 100, current: total, required: 15 };
    }
    
    function predictOrder2(steps) {
      const len = digitHistory.length;
      if (len < 2) return { digit: null, confidence: 0, current: 0, required: 10 };
      
      const prev1 = digitHistory[0];
      const prev2 = digitHistory[1];
      const key = `${prev2},${prev1}`;
      
      const total = totalTransitions2[key] || 0;
      if (total < 10) {
        // Fallback to Order 1
        return predictOrder1(prev1, steps);
      }
      
      // Get probabilities with smoothing
      const counts = transitionMatrix2[key];
      let probs = Array(10).fill(0);
      for (let i = 0; i < 10; i++) {
        probs[i] = (counts[i] + SMOOTHING_ALPHA) / (total + 10 * SMOOTHING_ALPHA);
      }
      
      // For multi-step, we need to simulate state transitions
      if (steps === 1) {
        let bestDigit = 0;
        let maxProb = probs[0];
        for (let i = 1; i < 10; i++) {
          if (probs[i] > maxProb) {
            maxProb = probs[i];
            bestDigit = i;
          }
        }
        return { digit: bestDigit, confidence: maxProb * 100, current: total, required: 10 };
      } else {
        // For steps > 1, blend with order-1 predictions
        const order1Pred = predictOrder1(prev1, steps);
        const blendFactor = 0.7; // 70% order-2, 30% order-1
        
        let bestDigit = 0;
        let maxProb = probs[0] * blendFactor + (order1Pred.digit === 0 ? order1Pred.confidence / 100 * (1 - blendFactor) : 0);
        
        for (let i = 1; i < 10; i++) {
          const combinedProb = probs[i] * blendFactor + (order1Pred.digit === i ? order1Pred.confidence / 100 * (1 - blendFactor) : 0);
          if (combinedProb > maxProb) {
            maxProb = combinedProb;
            bestDigit = i;
          }
        }
        
        return { digit: bestDigit, confidence: maxProb * 100, current: total, required: 10 };
      }
    }
    
    function predictOrder3(steps) {
      const len = digitHistory.length;
      if (len < 3) return { digit: null, confidence: 0, current: 0, required: 8 };
      
      const prev1 = digitHistory[0];
      const prev2 = digitHistory[1];
      const prev3 = digitHistory[2];
      const key = `${prev3},${prev2},${prev1}`;
      
      const total = totalTransitions3[key] || 0;
      if (total < 8) {
        // Fallback to Order 2
        return predictOrder2(steps);
      }
      
      // Get probabilities with smoothing
      const counts = transitionMatrix3[key];
      let probs = Array(10).fill(0);
      for (let i = 0; i < 10; i++) {
        probs[i] = (counts[i] + SMOOTHING_ALPHA) / (total + 10 * SMOOTHING_ALPHA);
      }
      
      if (steps === 1) {
        let bestDigit = 0;
        let maxProb = probs[0];
        for (let i = 1; i < 10; i++) {
          if (probs[i] > maxProb) {
            maxProb = probs[i];
            bestDigit = i;
          }
        }
        return { digit: bestDigit, confidence: maxProb * 100, current: total, required: 8 };
      } else {
        // Blend with lower orders for multi-step
        const order2Pred = predictOrder2(steps);
        const blendFactor = 0.6; // 60% order-3, 40% order-2
        
        let bestDigit = 0;
        let maxProb = probs[0] * blendFactor + (order2Pred.digit === 0 ? order2Pred.confidence / 100 * (1 - blendFactor) : 0);
        
        for (let i = 1; i < 10; i++) {
          const combinedProb = probs[i] * blendFactor + (order2Pred.digit === i ? order2Pred.confidence / 100 * (1 - blendFactor) : 0);
          if (combinedProb > maxProb) {
            maxProb = combinedProb;
            bestDigit = i;
          }
        }
        
        return { digit: bestDigit, confidence: maxProb * 100, current: total, required: 8 };
      }
    }
    
    function updatePredictionUI(pred, lastDigit) {
      predictedDigit = pred.digit;
      predictionConfidence = pred.confidence;
      
      const duration = parseInt(document.getElementById('duration').value);
      
      // Update progress bar for data gathering
      const progressBar = document.getElementById('dataProgress');
      const progressFill = document.getElementById('dataProgressFill');
      const progressText = document.getElementById('dataProgressText');
      
      if (pred.digit === null) {
        // Show progress bar
        progressBar.style.display = 'block';
        const current = pred.current || 0;
        const required = pred.required || 15;
        const percentage = Math.min(100, (current / required) * 100);
        
        progressFill.style.width = percentage + '%';
        progressText.textContent = `Gathering data: ${current}/${required} samples`;
        
        document.getElementById('predictionInfo').textContent = `Building pattern database... Please wait.`;
        App.modules.UI.updatePredictionDisplay(null, 0);
        return;
      } else {
        // Hide progress bar when ready
        progressBar.style.display = 'none';
      }

      const orderName = currentOrder === 1 ? "Order-1" : currentOrder === 2 ? "Order-2" : "Order-3";
      const info = `${orderName} Model: Predicted digit in ${duration} tick${duration > 1 ? 's' : ''} = ${pred.digit} (${pred.confidence.toFixed(1)}% probability)`;
      document.getElementById('predictionInfo').textContent = info;
      
      const strengthEl = document.getElementById('patternStrength');
      const indicatorEl = document.getElementById('patternIndicator');
      
      if (pred.confidence > 25) {
        strengthEl.textContent = "Very Strong";
        indicatorEl.className = "pattern-indicator pattern-strong";
      } else if (pred.confidence > 18) {
        strengthEl.textContent = "Strong";
        indicatorEl.className = "pattern-indicator pattern-strong";
      } else if (pred.confidence > 14) {
        strengthEl.textContent = "Moderate";
        indicatorEl.className = "pattern-indicator pattern-medium";
      } else {
        strengthEl.textContent = "Weak";
        indicatorEl.className = "pattern-indicator pattern-weak";
      }
      
      document.getElementById('probabilityValue').textContent = pred.confidence.toFixed(1) + '%';
      
      // Data points available
      let dataPoints = pred.current || 0;
      document.getElementById('patternScore').textContent = dataPoints;
      
      const freq = digitHistory.filter(d => d === pred.digit).length;
      const freqPct = digitHistory.length > 0 ? (freq / digitHistory.length * 100) : 0;
      document.getElementById('frequencyValue').textContent = freqPct.toFixed(1) + '%';
      
      App.modules.UI.updatePredictionDisplay(pred.digit, pred.confidence);
    }
    
    function updateDisplay() {
      const container = document.getElementById('digitDisplay');
      container.innerHTML = '';
      digitHistory.slice(0, 50).forEach((digit, i) => {
        const box = document.createElement('div');
        box.className = `digit-box ${i===0 ? 'digit-match' : 'digit-other'}`;
        box.textContent = digit;
        container.appendChild(box);
      });
      
      const last = digitHistory[0];
      if(last !== undefined) {
          document.getElementById('matchCount').textContent = last;
          document.getElementById('totalCount').textContent = digitHistory.length;
      }
    }
    
    function setOrder(order) {
      currentOrder = order;
      document.getElementById('currentOrder').textContent = order;
      App.modules.UI.addLog(`Switched to Order-${order} Markov Model`, "info");
      
      // Update UI
      document.querySelectorAll('.order-option').forEach(el => {
        el.classList.toggle('active', parseInt(el.dataset.order) === order);
      });
    }
    
    return {
      init() {
        // Order selector
        document.querySelectorAll('.order-option').forEach(el => {
          el.addEventListener('click', () => {
            const order = parseInt(el.dataset.order);
            setOrder(order);
          });
        });
      },
      processTick,
      resetForNewMarket: () => {
        digitHistory = [];
        transitionMatrix1 = Array(10).fill(0).map(() => Array(10).fill(0));
        totalTransitions1 = Array(10).fill(0);
        transitionMatrix2 = {};
        totalTransitions2 = {};
        transitionMatrix3 = {};
        totalTransitions3 = {};
        predictedDigit = null;
        predictionConfidence = 0;
        lastDigit = null;
        App.modules.UI.addLog("Memory wiped for new market", "warn");
      },
      getPrediction: () => {
        return { digit: predictedDigit, confidence: predictionConfidence };
      },
      getLastDigit: () => lastDigit,
      getData: () => ({ 
        transitionMatrix1, 
        totalTransitions1,
        transitionMatrix2,
        totalTransitions2,
        transitionMatrix3,
        totalTransitions3,
        currentOrder
      }),
      setData: (data) => {
        if(data.transitionMatrix1) transitionMatrix1 = data.transitionMatrix1;
        if(data.totalTransitions1) totalTransitions1 = data.totalTransitions1;
        if(data.transitionMatrix2) transitionMatrix2 = data.transitionMatrix2;
        if(data.totalTransitions2) totalTransitions2 = data.totalTransitions2;
        if(data.transitionMatrix3) transitionMatrix3 = data.transitionMatrix3;
        if(data.totalTransitions3) totalTransitions3 = data.totalTransitions3;
        if(data.currentOrder) {
          currentOrder = data.currentOrder;
          document.getElementById('currentOrder').textContent = currentOrder;
          document.querySelectorAll('.order-option').forEach(el => {
            el.classList.toggle('active', parseInt(el.dataset.order) === currentOrder);
          });
        }
      }
    };
  })();

  // ============ VIRTUAL TRADE MODULE ============
  App.modules.VirtualTrade = (function() {
    let isVirtualMode = false;
    let virtualStats = {
      totalTrades: 0,
      consecLosses: 0,
      profit: 0
    };
    let pendingVirtualTrade = null;
    
    function init() {
      document.getElementById('virtualTradeToggle').addEventListener('change', (e) => {
        const isEnabled = e.target.checked;
        if (isEnabled) {
          resetVirtualStats();
          App.modules.UI.addLog("Virtual Trade Mode ENABLED", "info");
          document.getElementById('virtualModeBadge').classList.add('active');
        } else {
          App.modules.UI.addLog("Virtual Trade Mode DISABLED", "warn");
          document.getElementById('virtualModeBadge').classList.remove('active');
        }
        App.modules.UI.saveSettings();
      });
      
      const saved = localStorage.getItem('virtual_stats_dm_pro');
      if (saved) {
        virtualStats = JSON.parse(saved);
        updateVirtualUI();
      }
    }
    
    function isEnabled() {
      return document.getElementById('virtualTradeToggle').checked;
    }
    
    function shouldSwitchToLive() {
      const threshold = parseInt(document.getElementById('virtualLossThreshold').value);
      return virtualStats.consecLosses >= threshold;
    }
    
    function queueVirtualTrade(targetDigit, confidence) {
      if (!isVirtualMode) {
        isVirtualMode = true;
      }
      
      pendingVirtualTrade = {
        targetDigit: targetDigit,
        confidence: confidence,
        timestamp: Date.now()
      };
      
      App.modules.UI.addLog(`[VIRTUAL] Trade queued: Digit ${targetDigit} (Prob: ${confidence.toFixed(1)}%)`, "info");
    }
    
    function processTickResult(actualDigit) {
      if (!pendingVirtualTrade) return;
      
      const trade = pendingVirtualTrade;
      pendingVirtualTrade = null;
      
      virtualStats.totalTrades++;
      
      const isWin = (actualDigit === trade.targetDigit);
      const stake = parseFloat(document.getElementById('stake').value);
      const payout = isWin ? stake * 0.95 : -stake;
      
      virtualStats.profit += payout;
      
      if (isWin) {
        virtualStats.consecLosses = 0;
        App.modules.UI.addLog(`[VIRTUAL] WIN: Digit ${trade.targetDigit} matched ${actualDigit} ($${payout.toFixed(2)})`, "success");
      } else {
        virtualStats.consecLosses++;
        App.modules.UI.addLog(`[VIRTUAL] LOSS: Expected ${trade.targetDigit}, got ${actualDigit} ($${payout.toFixed(2)}) | Consecutive: ${virtualStats.consecLosses}`, "error");
      }
      
      App.modules.UI.addToHistory(virtualStats.totalTrades, isWin ? 'Win' : 'Loss', payout, Config.currentMarketValue, true);
      
      updateVirtualUI();
      saveVirtualStats();
      
      if (shouldSwitchToLive()) {
        switchToLiveMode();
      }
      
      return { isWin, payout };
    }
    
    function switchToLiveMode() {
      App.modules.UI.addLog(`ðŸ”´ SWITCHING TO LIVE MODE - ${virtualStats.consecLosses} consecutive losses reached!`, "warn");
      document.getElementById('virtualTradeToggle').checked = false;
      document.getElementById('virtualModeBadge').classList.remove('active');
      isVirtualMode = false;
      
      virtualStats.consecLosses = 0;
      updateVirtualUI();
      saveVirtualStats();
    }
    
    function updateVirtualUI() {
      document.getElementById('virtualConsecLosses').textContent = virtualStats.consecLosses;
      document.getElementById('virtualTotalTrades').textContent = virtualStats.totalTrades;
      const profitEl = document.getElementById('virtualProfit');
      profitEl.textContent = virtualStats.profit.toFixed(2);
      profitEl.style.color = virtualStats.profit > 0 ? '#22c55e' : (virtualStats.profit < 0 ? '#ef4444' : '#8b5cf6');
    }
    
    function saveVirtualStats() {
      localStorage.setItem('virtual_stats_dm_pro', JSON.stringify(virtualStats));
    }
    
    function resetVirtualStats() {
      virtualStats = {
        totalTrades: 0,
        consecLosses: 0,
        profit: 0
      };
      isVirtualMode = false;
      pendingVirtualTrade = null;
      updateVirtualUI();
      saveVirtualStats();
    }
    
    return {
      init,
      isEnabled,
      queueVirtualTrade,
      processTickResult,
      resetVirtualStats,
      getStats: () => virtualStats
    };
  })();

  // ============ TRADER MODULE ============
  App.modules.Trader = (function() {
    let isAutoRunning = false;
    let currentContractId = null;
    let stats = { trades: 0, wins: 0, losses: 0, profit: 0 };
    let lastTradeTime = 0;
    
    let isMarketCycleActive = false;
    let isCooldownLoopActive = false;
    let isCycleCooldown = false;
    let currentMarketIndex = 0;
    let cycleTimerId = null;
    
    function placeTrade(targetDigit, conf, isVirtual = false) {
      if (!App.modules.Connection.isConnected() && !isVirtual) {
        App.modules.UI.addLog("Error: Not connected to Deriv", "error");
        return;
      }
      
      const stake = parseFloat(document.getElementById('stake').value);
      const duration = parseInt(document.getElementById('duration').value);
      const market = Config.currentMarketValue;
      
      if (isNaN(stake) || stake < 0.35) {
        App.modules.UI.addLog("Error: Invalid stake amount", "error");
        return;
      }
      
      if (isNaN(targetDigit) || targetDigit < 0 || targetDigit > 9) {
        App.modules.UI.addLog("Error: Invalid target digit", "error");
        return;
      }
      
      if (isVirtual) {
        App.modules.UI.addLog(`[VIRTUAL] Buying Digit ${targetDigit} (AI Prob: ${conf.toFixed(1)}%)`, "info");
        App.modules.VirtualTrade.queueVirtualTrade(targetDigit, conf);
        return;
      }
      
      App.modules.UI.addLog(`[LIVE] Buying Digit ${targetDigit} (AI Prob: ${conf.toFixed(1)}%)`, "info");
      
      App.modules.Connection.sendAPIRequest({
        buy: 1,
        price: stake,
        parameters: { 
          contract_type: 'DIGITMATCH', 
          symbol: market, 
          duration: duration, 
          duration_unit: 't', 
          barrier: targetDigit.toString(),
          amount: stake, 
          basis: 'stake', 
          currency: 'USD' 
        }
      });
    }
    
    function checkAndAutoTrade(prediction) {
      if (currentContractId !== null) return;
      if (prediction.digit === null || prediction.digit === undefined) return; 
      
      const now = Date.now();
      const cooldownSec = parseFloat(document.getElementById('cooldown').value);
      
      const isVirtualEnabled = App.modules.VirtualTrade.isEnabled();
      
      // Exclusive Prediction Mapper Logic
      const isMapperOn = document.getElementById('mapperToggle').checked;
      const mapTrigger = document.getElementById('mapperTrigger').value;
      const mapTarget = document.getElementById('mapperTarget').value;
      
      let finalTarget = prediction.digit;
      let finalConfidence = prediction.confidence;
      
      if (isMapperOn && mapTrigger !== "" && mapTarget !== "") {
          const trigger = parseInt(mapTrigger);
          const target = parseInt(mapTarget);
          
          if (isNaN(trigger) || isNaN(target) || trigger < 0 || trigger > 9 || target < 0 || target > 9) {
            return;
          }
          
          if (prediction.digit === trigger) {
              finalTarget = target;
              App.modules.UI.addLog(`âš¡ Map Active: AI said ${trigger}, Trading ${target}`, "warn");
          } else {
              return; 
          }
      } else {
        const manualDigit = parseInt(document.getElementById('manualDigit').value);
        if (!isNaN(manualDigit) && manualDigit !== 0 && prediction.digit !== manualDigit) {
          return;
        }
      }
      
      if (isNaN(finalTarget) || finalTarget < 0 || finalTarget > 9) {
        App.modules.UI.addLog("Error: Invalid final target digit", "error");
        return;
      }
      
      const userMinConf = parseFloat(document.getElementById('minConfidence').value);
      if (finalConfidence < userMinConf) return;
      
      if (now - lastTradeTime < (cooldownSec * 1000)) return;
      
      lastTradeTime = now;
      
      if (isVirtualEnabled) {
        placeTrade(finalTarget, finalConfidence, true);
      } else {
        placeTrade(finalTarget, finalConfidence, false);
      }
    }
    
    function handleTradeResult(contract) {
      const isWin = contract.status === 'won';
      const pl = parseFloat(contract.profit || 0);
      
      stats.trades++;
      if(isWin) stats.wins++; else stats.losses++;
      stats.profit += pl;
      
      App.modules.UI.addLog(`[LIVE] Result: ${isWin?'WIN':'LOSS'} ($${pl.toFixed(2)})`, isWin?'success':'error');
      App.modules.UI.updateStats(stats);
      App.modules.UI.addToHistory(stats.trades, isWin?'Win':'Loss', pl, Config.currentMarketValue, false);
      
      localStorage.setItem('trade_stats_dm_pro', JSON.stringify(stats));
      localStorage.setItem('trade_history_dm_pro', document.getElementById('history').innerHTML);
      
      checkTargets();
    }
    
    function checkTargets() {
      const tp = parseFloat(document.getElementById('takeprofit').value);
      const sl = parseFloat(document.getElementById('stoploss').value);
      
      if (stats.profit <= -sl) {
        toggleAuto(false);
        App.modules.UI.addLog("Stop Loss Hit.", "error");
        return;
      }
      
      if (stats.profit >= tp) {
        if (isMarketCycleActive) {
           advanceCycle();
        } else {
           toggleAuto(false);
           App.modules.UI.addLog("Take Profit Hit.", "success");
        }
      }
    }
    
    function advanceCycle() {
      if (currentMarketIndex < Config.marketSequence.length - 1) {
        currentMarketIndex++;
        const next = Config.marketSequence[currentMarketIndex];
        App.modules.UI.addLog(`Cycle Target Reached. Switching to ${next}`, "success");
        
        stats = { trades: 0, wins: 0, losses: 0, profit: 0 };
        App.modules.UI.updateStats(stats);
        
        App.modules.UI.selectMarket(next);
      } else {
        App.modules.UI.addLog("Full Market Cycle Complete.", "success");
        stats = { trades: 0, wins: 0, losses: 0, profit: 0 };
        App.modules.UI.updateStats(stats);
        
        if (isCooldownLoopActive) {
          startCycleCooldown();
        } else {
          toggleAuto(false);
          isMarketCycleActive = false;
          document.getElementById('cycleBtn').classList.remove('active');
          document.getElementById('cycleBtn').textContent = "Auto Market Cycle: OFF";
        }
      }
    }
    
    function startCycleCooldown() {
      isCycleCooldown = true;
      let min = parseInt(document.getElementById('cycleWaitTime').value);
      let sec = min * 60;
      const disp = document.getElementById('cycleTimerDisplay');
      disp.style.display = 'block';
      
      App.modules.UI.addLog(`Cycle cooldown active: waiting ${min}m...`, "warn");
      
      if (cycleTimerId) clearInterval(cycleTimerId);
      cycleTimerId = setInterval(() => {
        sec--;
        const m = Math.floor(sec/60);
        const s = sec%60;
        disp.textContent = `Next Loop in: ${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
        
        if (sec <= 0) {
          clearInterval(cycleTimerId);
          isCycleCooldown = false;
          currentMarketIndex = 0;
          disp.style.display = 'none';
          const nextMarket = Config.marketSequence[0];
          Config.currentMarketValue = nextMarket;
          App.modules.UI.selectMarket(nextMarket);
          document.getElementById('cycleBtn').textContent = `Auto Market Cycle: ON (${nextMarket})`;
          App.modules.UI.addLog(`Cooldown finished. Restarting cycle at ${nextMarket}.`, "success");
        }
      }, 1000);
    }
    
    function toggleAuto(forceState) {
      if (typeof forceState === 'boolean') isAutoRunning = forceState;
      else isAutoRunning = !isAutoRunning;
      
      const btn = document.getElementById('autoBtn');
      if (isAutoRunning) {
        localStorage.setItem('isAutoRunning', 'true');
        btn.textContent = "Stop Auto";
        btn.style.background = "#ef4444";
        
        const mode = App.modules.VirtualTrade.isEnabled() ? "VIRTUAL" : "LIVE";
        App.modules.UI.addLog(`Auto-Trade Enabled in ${mode} mode.`, "success");
      } else {
        localStorage.removeItem('isAutoRunning');
        btn.textContent = "Start Auto";
        btn.style.background = "#22c55e";
        App.modules.UI.addLog("Auto-Trade Stopped.", "warn");
      }
    }
    
    function toggleMarketCycle() {
      isMarketCycleActive = !isMarketCycleActive;
      const btn = document.getElementById('cycleBtn');
      if (isMarketCycleActive) {
        btn.classList.add('active');
        currentMarketIndex = Config.marketSequence.indexOf(Config.currentMarketValue);
        if(currentMarketIndex === -1) currentMarketIndex = 0;
        btn.textContent = `Auto Market Cycle: ON (${Config.marketSequence[currentMarketIndex]})`;
        App.modules.UI.addLog(`Market Cycle Started at ${Config.marketSequence[currentMarketIndex]}.`, "info");
      } else {
        btn.classList.remove('active');
        btn.textContent = "Auto Market Cycle: OFF";
        App.modules.UI.addLog(`Market Cycle Disabled.`, "warn");
      }
    }
    
    function toggleCooldownLoop() {
      isCooldownLoopActive = !isCooldownLoopActive;
      const btn = document.getElementById('cooldownBtn');
      if (isCooldownLoopActive) {
        btn.classList.add('active');
        btn.textContent = "Cycle Cooldown Loop: ON";
        App.modules.UI.addLog(`Cooldown Loop Enabled.`, "info");
      } else {
        btn.classList.remove('active');
        btn.textContent = "Cycle Cooldown Loop: OFF";
        App.modules.UI.addLog(`Cooldown Loop Disabled.`, "warn");
      }
    }
    
    function resetStats() {
      stats = { trades: 0, wins: 0, losses: 0, profit: 0 };
      App.modules.UI.updateStats(stats);
      document.getElementById('history').innerHTML = '';
      localStorage.removeItem('trade_stats_dm_pro');
      localStorage.removeItem('trade_history_dm_pro');
      
      App.modules.VirtualTrade.resetVirtualStats();
      
      App.modules.UI.addLog("All stats reset.", "info");
    }
    
    return {
      init() {
        document.getElementById('autoBtn').addEventListener('click', () => toggleAuto());
        document.getElementById('manualBtn').addEventListener('click', () => {
            const pred = App.modules.Analyzer.getPrediction();
            if(pred.digit !== null && pred.digit !== undefined) {
              const isVirtual = App.modules.VirtualTrade.isEnabled();
              placeTrade(pred.digit, pred.confidence, isVirtual);
            } else {
              App.modules.UI.addLog("No prediction available yet", "warn");
            }
        });
        document.getElementById('cycleBtn').addEventListener('click', toggleMarketCycle);
        document.getElementById('cooldownBtn').addEventListener('click', toggleCooldownLoop);
        document.getElementById('resetBtn').addEventListener('click', resetStats);
        
        const s = localStorage.getItem('trade_stats_dm_pro');
        if(s) { stats = JSON.parse(s); App.modules.UI.updateStats(stats); }
      },
      checkAndAutoTrade,
      setContractId: (id) => currentContractId = id,
      handleTradeResult,
      getAutoRunning: () => isAutoRunning,
      getCycleCooldown: () => isCycleCooldown,
      resumeAutoTrade: () => toggleAuto(true)
    };
  })();

  // ============ UI MODULE ============
  App.modules.UI = (function() {
    let sessionStartTime = null;
    let timerIntervalId = null;
    
    function init() {
      document.querySelectorAll('#marketRadios .radio-option').forEach(opt => {
        opt.addEventListener('click', (e) => {
          const m = e.currentTarget.dataset.market;
          selectMarket(m);
        });
      });
      
      document.querySelectorAll('.save-setting').forEach(el => {
        el.addEventListener('change', saveSettings);
        el.addEventListener('input', saveSettings);
      });
      
      document.getElementById('clearLog').addEventListener('click', () => {
         document.getElementById('logContainer').innerHTML = '';
      });
    }
    
    function addLog(msg, type = 'info') {
      const container = document.getElementById('logContainer');
      const time = new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `<span class="log-time">[${time}]</span> <span class="log-msg-${type}">${msg}</span>`;
      container.appendChild(entry);
      container.scrollTop = container.scrollHeight;
    }
    
    function updateStatus(text, className) { 
      const s = document.getElementById('status'); 
      s.textContent = text; 
      s.className = 'status ' + className; 
    }
    
    function updateBalance() { 
      document.getElementById('balanceDisplay').style.display = 'block'; 
      document.getElementById('balance').textContent = parseFloat(Config.accountBalance).toFixed(2); 
    }
    
    function updateStats(stats) {
      document.getElementById('trades').textContent = stats.trades;
      document.getElementById('wins').textContent = stats.wins;
      document.getElementById('losses').textContent = stats.losses;
      const p = document.getElementById('profit');
      p.textContent = stats.profit.toFixed(2);
      p.style.color = stats.profit > 0 ? '#22c55e' : (stats.profit < 0 ? '#ef4444' : '#e5e7eb');
    }
    
    function startSessionTimer() {
      if (timerIntervalId) clearInterval(timerIntervalId);
      sessionStartTime = Date.now(); 
      timerIntervalId = setInterval(() => {
        const now = Date.now();
        const s = Math.floor((now - sessionStartTime) / 1000);
        document.getElementById('sessionTimer').textContent = `Session: ${Math.floor(s/3600).toString().padStart(2,'0')}:${Math.floor((s%3600)/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`;
      }, 1000);
    }
    
    function addToHistory(n, res, pl, m, isVirtual = false) {
      const row = document.getElementById('history').insertRow(0);
      const cls = res === 'Win' ? 'win' : 'loss';
      const mode = isVirtual ? 'Virtual' : 'Live';
      row.innerHTML = `<td>${n}</td><td style="color: ${isVirtual ? '#8b5cf6' : '#22c55e'}">${mode}</td><td class="${cls}">${res}</td><td class="${cls}">${pl.toFixed(2)}</td><td>${m}</td>`;
    }
    
    function updatePredictionDisplay(digit, conf) {
      const box = document.getElementById('predictionDisplay');
      const bar = document.getElementById('confidenceBar');
      
      const visualPercent = Math.min(100, (conf / 25) * 100);
      bar.style.width = visualPercent + '%';
      
      if (digit !== null && digit !== undefined) {
        const color = conf > 18 ? '#22c55e' : (conf > 14 ? '#f59e0b' : '#94a3b8');
        box.innerHTML = `<span class="prediction-ready" style="color:${color}">DIGIT ${digit}</span>`;
      } else {
        box.innerHTML = `<span class="prediction-waiting">WAITING...</span>`;
      }
    }
    
    function saveSettings() {
      const set = {
        analyzer: App.modules.Analyzer.getData(),
        market: Config.currentMarketValue,
        mapperToggle: document.getElementById('mapperToggle').checked,
        virtualTradeToggle: document.getElementById('virtualTradeToggle').checked
      };
      document.querySelectorAll('.save-setting').forEach(el => {
        if(el.type !== 'checkbox') set[el.id] = el.value;
      });
      localStorage.setItem('settings_dm_pro', JSON.stringify(set));
    }
    
    function loadSettings() {
      const s = localStorage.getItem('settings_dm_pro');
      if(s) {
        const set = JSON.parse(s);
        for(let k in set) {
          const el = document.getElementById(k);
          if(el && el.type !== 'checkbox') el.value = set[k];
        }
        
        if(set.mapperToggle) document.getElementById('mapperToggle').checked = set.mapperToggle;
        if(set.virtualTradeToggle) {
          document.getElementById('virtualTradeToggle').checked = set.virtualTradeToggle;
          if(set.virtualTradeToggle) {
            document.getElementById('virtualModeBadge').classList.add('active');
          }
        }
        
        if(set.analyzer) App.modules.Analyzer.setData(set.analyzer);
        if(set.market) {
          Config.currentMarketValue = set.market;
          selectMarket(set.market);
        }
      }
      
      const h = localStorage.getItem('trade_history_dm_pro');
      if(h) document.getElementById('history').innerHTML = h;
    }
    
    function selectMarket(m) {
      Config.currentMarketValue = m;
      document.querySelectorAll('.radio-option').forEach(el => {
        el.classList.toggle('selected', el.dataset.market === m);
      });
      const radioEl = document.getElementById('market'+m.replace('_',''));
      if(radioEl) radioEl.checked = true;
      
      if (App.modules.Connection.isConnected()) {
        App.modules.Connection.subscribeToTicks();
      }
      saveSettings();
    }
    
    return {
      init,
      addLog,
      updateStatus,
      updateBalance,
      updateStats,
      startSessionTimer,
      addToHistory,
      updatePredictionDisplay,
      saveSettings,
      loadSettings,
      selectMarket
    };
  })();

  // ============ INITIALIZE APP ============
  window.addEventListener('DOMContentLoaded', () => {
    App.init();
  });

})();
</script>
</body>
</html>