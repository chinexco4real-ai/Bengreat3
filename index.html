<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Deriv Digit Match Pro - AI Enhanced v2.0</title>
<style>
/* --- CORE STYLES --- */
body { background: #020617; color: #e5e7eb; font-family: system-ui, -apple-system, sans-serif; margin: 0; padding: 0; }
.app { max-width: 420px; margin: auto; padding: 15px; }
.card { background: #0f172a; padding: 12px; border-radius: 12px; margin-bottom: 12px; border: 1px solid #1e293b; }
h2, h3 { text-align: center; margin-bottom: 8px; margin-top: 8px; }
h2 { color: #22c55e; }
label { font-size: 13px; opacity: 0.8; display: block; margin-top: 8px; }
input[type="number"], input[type="password"], select, button { width: 100%; padding: 10px; margin: 5px 0 10px; border-radius: 8px; border: none; box-sizing: border-box; }
input, select { background: #1e293b; color: #e5e7eb; border: 1px solid #334155; }
input:focus, select:focus { outline: none; border-color: #22c55e; }
button { background: #22c55e; color: #020617; font-weight: 700; cursor: pointer; transition: all 0.2s; }
button:hover { background: #16a34a; transform: translateY(-1px); }
button:active { transform: translateY(0); }
button:disabled { background: #374151; cursor: not-allowed; opacity: 0.5; }
.buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 12px; }
.status-container { display: flex; gap: 5px; margin-bottom: 10px; }
.status { flex: 2; text-align: center; padding: 8px; border-radius: 8px; font-weight: 600; }
.account-type { flex: 1.5; text-align: center; padding: 8px; border-radius: 8px; font-weight: 700; font-size: 11px; display: none; text-transform: uppercase; align-self: center; }
.demo-badge { background: #f59e0b; color: #020617; }
.live-badge { background: #22c55e; color: #020617; }
.connected { background: #16a34a; color: white; }
.disconnected { background: #dc2626; color: white; }
.stats { display: grid; grid-template-columns: repeat(4, 1fr); text-align: center; gap: 10px; }
.stats > div { display: flex; flex-direction: column; gap: 5px; }
.stats span { font-size: 12px; opacity: 0.7; }
.stats b { font-size: 16px; color: #22c55e; }
.table-container { overflow-x: auto; max-height: 300px; overflow-y: auto; }
table { width: 100%; font-size: 13px; border-collapse: collapse; }
thead { position: sticky; top: 0; background: #1e293b; }
th { padding: 8px; text-align: left; font-weight: 600; border-bottom: 2px solid #334155; }
td { padding: 8px; border-bottom: 1px solid #1e293b; }
tbody tr:hover { background: #1e293b; }
.win { color: #22c55e; }
.loss { color: #ef4444; }
.balance-display { text-align: center; padding: 10px; background: #0f172a; border-radius: 8px; margin-bottom: 10px; border: 1px solid #1e293b; }
.balance-display span { opacity: 0.7; font-size: 14px; }
.balance-display b { color: #22c55e; font-size: 18px; margin: 0 5px; }
.session-timer { margin-top: 8px; font-size: 12px; color: #f59e0b; font-weight: 600; }
.reset-button-permanent { background: #f59e0b !important; width: 100%; margin-bottom: 12px; font-size: 15px; display: block; }
.reset-button-permanent:hover { background: #d97706 !important; }
.analyzer-grid { display: grid; grid-template-columns: repeat(10, 1fr); gap: 5px; margin: 10px 0; }
.digit-box { aspect-ratio: 1; display: flex; align-items: center; justify-content: center; border-radius: 6px; font-weight: 700; font-size: 14px; border: 2px solid transparent; }
.digit-match { background: #8b5cf6; color: white; border-color: #22c55e; }
.digit-other { background: #1e293b; color: #94a3b8; }
.analyzer-stats { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; text-align: center; margin-top: 10px; }
.analyzer-stats > div { background: #1e293b; padding: 8px; border-radius: 6px; }
.analyzer-stats span { font-size: 11px; opacity: 0.7; display: block; }
.analyzer-stats b { font-size: 18px; display: block; margin-top: 3px; }
.log-container { background: #020617; border: 1px solid #1e293b; border-radius: 6px; height: 120px; overflow-y: auto; padding: 8px; font-family: 'Courier New', monospace; font-size: 11px; margin-top: 10px; }
.log-entry { margin-bottom: 4px; border-bottom: 1px solid #1e293b; padding-bottom: 2px; }
.log-time { color: #94a3b8; margin-right: 5px; }
.log-msg-info { color: #3b82f6; }
.log-msg-success { color: #22c55e; }
.log-msg-error { color: #ef4444; }
.log-msg-warn { color: #f59e0b; }
.btn-cycle { background: #3b82f6; color: white; margin-bottom: 5px; font-size: 14px; }
.btn-cycle.active { background: #8b5cf6; border: 2px solid #fff; }
.btn-cooldown { background: #475569; color: white; margin-bottom: 5px; font-size: 14px; }
.btn-cooldown.active { background: #f59e0b; color: #020617; border: 2px solid #020617; }
.cycle-timer-display { color: #f59e0b; font-size: 13px; font-weight: bold; text-align: center; margin-bottom: 10px; display: none; padding: 8px; border: 2px dashed #f59e0b; border-radius: 8px; background: rgba(245, 158, 11, 0.1); }

/* Radio Button Styles */
.radio-group { margin: 10px 0; }
.radio-option { display: flex; align-items: center; padding: 8px; margin: 5px 0; background: #1e293b; border-radius: 6px; cursor: pointer; border: 2px solid #334155; transition: all 0.2s; }
.radio-option:hover { border-color: #22c55e; background: #1e3a2b; }
.radio-option input[type="radio"] { margin-right: 10px; cursor: pointer; width: auto; }
.radio-option.selected { border-color: #22c55e; background: #1e3a2b; }
.radio-option label { cursor: pointer; margin: 0; opacity: 1; font-size: 13px; font-weight: 600; width: 100%; }

/* Prediction & Metrics */
.prediction-box { background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); border: 2px solid #8b5cf6; border-radius: 8px; padding: 15px; margin: 10px 0; text-align: center; }
.prediction-status { font-size: 14px; font-weight: 700; color: #94a3b8; margin-bottom: 10px; }
.prediction-digit { font-size: 48px; font-weight: 900; margin: 15px 0; }
.prediction-waiting { color: #f59e0b; }
.prediction-ready { color: #22c55e; animation: pulse 1.5s infinite; }
@keyframes pulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.8; transform: scale(1.05); }
}
.prediction-info { font-size: 11px; opacity: 0.7; margin-top: 10px; line-height: 1.5; }

.accuracy-metrics { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-top: 12px; }
.accuracy-card { background: #020617; padding: 10px; border-radius: 6px; border: 1px solid #334155; text-align: center; }
.accuracy-card .label { font-size: 10px; color: #94a3b8; margin-bottom: 5px; }
.accuracy-card .value { font-size: 18px; font-weight: 700; color: #8b5cf6; }
.confidence-bar { width: 100%; height: 8px; background: #1e293b; border-radius: 4px; overflow: hidden; margin-top: 10px; }
.confidence-fill { height: 100%; background: linear-gradient(90deg, #ef4444, #f59e0b, #22c55e); transition: width 0.3s; }
.pattern-indicator { margin-top: 10px; padding: 8px; background: #1e293b; border-radius: 6px; font-size: 11px; }
.pattern-strong { border-left: 4px solid #22c55e; }
.pattern-medium { border-left: 4px solid #f59e0b; }
.pattern-weak { border-left: 4px solid #ef4444; }

/* Toggle Switch Style */
.switch-container { display: flex; justify-content: space-between; align-items: center; background: #1e293b; padding: 10px; border-radius: 8px; border: 1px solid #ef4444; margin-bottom: 10px; }
.switch-label { color: #ef4444; font-weight: bold; font-size: 14px; }
.toggle-checkbox { width: 20px !important; height: 20px !important; margin: 0 !important; cursor: pointer; }

/* Virtual Trade Styles */
.virtual-trade-container { background: #1e293b; padding: 10px; border-radius: 8px; border: 2px solid #8b5cf6; margin-bottom: 10px; }
.virtual-trade-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
.virtual-trade-label { color: #8b5cf6; font-weight: bold; font-size: 14px; }
.virtual-mode-badge { background: #8b5cf6; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 700; display: none; }
.virtual-mode-badge.active { display: inline-block; animation: blink 1.5s infinite; }
@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}
.virtual-stats { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-top: 10px; }
.virtual-stat-box { background: #0f172a; padding: 8px; border-radius: 6px; text-align: center; border: 1px solid #334155; }
.virtual-stat-box span { font-size: 10px; color: #94a3b8; display: block; }
.virtual-stat-box b { font-size: 16px; color: #8b5cf6; display: block; margin-top: 3px; }

/* AI Model Selector */
.ai-model-selector { background: #1e293b; padding: 10px; border-radius: 8px; border: 2px solid #3b82f6; margin-bottom: 10px; }
.ai-model-label { color: #3b82f6; font-weight: bold; font-size: 14px; margin-bottom: 8px; }
.model-option { display: flex; align-items: center; padding: 6px; margin: 4px 0; background: #0f172a; border-radius: 4px; cursor: pointer; border: 2px solid #334155; transition: all 0.2s; }
.model-option:hover { border-color: #3b82f6; }
.model-option.selected { border-color: #3b82f6; background: #1e3a4b; }
.model-option input[type="radio"] { margin-right: 8px; cursor: pointer; width: auto; }
.model-option label { cursor: pointer; margin: 0; font-size: 12px; width: 100%; }
.model-description { font-size: 9px; opacity: 0.6; margin-top: 2px; }
.ai-training-status { font-size: 10px; color: #f59e0b; margin-top: 8px; text-align: center; }

/* Contract Type Selector */
.contract-type-selector { background: #1e293b; padding: 10px; border-radius: 8px; border: 2px solid #f59e0b; margin-bottom: 10px; }
.contract-type-label { color: #f59e0b; font-weight: bold; font-size: 14px; margin-bottom: 8px; }
.contract-option { display: flex; align-items: center; padding: 6px; margin: 4px 0; background: #0f172a; border-radius: 4px; cursor: pointer; border: 2px solid #334155; transition: all 0.2s; }
.contract-option:hover { border-color: #f59e0b; }
.contract-option.selected { border-color: #f59e0b; background: #3a2e1b; }
.contract-option input[type="radio"] { margin-right: 8px; cursor: pointer; width: auto; }
.contract-option label { cursor: pointer; margin: 0; font-size: 12px; width: 100%; }
.contract-description { font-size: 9px; opacity: 0.6; margin-top: 2px; }

/* Model Performance Tracker */
.performance-tracker { background: #1e293b; padding: 10px; border-radius: 8px; border: 1px solid #334155; margin-top: 10px; }
.performance-title { font-size: 12px; font-weight: 700; color: #94a3b8; margin-bottom: 8px; text-align: center; }
.performance-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
.performance-item { background: #0f172a; padding: 6px; border-radius: 4px; text-align: center; }
.performance-item .name { font-size: 9px; color: #94a3b8; display: block; }
.performance-item .accuracy { font-size: 14px; font-weight: 700; display: block; margin-top: 2px; }
</style>
</head>
<body>
<div class="app">

<h2>Deriv Digit Match Pro v2.0</h2>
<div style="text-align: center; font-size: 10px; opacity: 0.6; margin-top: -8px; margin-bottom: 12px;">
  Enhanced AI ‚Ä¢ Weighted Markov ‚Ä¢ Adaptive Features
</div>

<div class="status-container">
    <div id="status" class="status disconnected">Disconnected</div>
    <div id="accountType" class="account-type"></div>
</div>

<div id="balanceDisplay" class="balance-display" style="display:none;">
  <span>Balance:</span>
  <b id="balance">0.00</b>
  <span id="balanceCurrency">USD</span>
  <div id="sessionTimer" class="session-timer">Session: 00:00:00</div>
</div>

<div class="card">
  <input id="token" type="password" placeholder="Deriv API Token" required>
  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <button id="loginBtn">Login</button>
    <button id="logoutBtn" style="background: #ef4444;">Logout</button>
  </div>
</div>

<div class="card">
  <h3>üìä Contract Type Selection</h3>
  <div class="contract-type-selector">
    <div class="contract-type-label">Select Contract Type:</div>
    <div class="contract-option selected" data-contract="DIGITMATCH">
      <input type="radio" name="contractType" value="DIGITMATCH" id="contractDigitMatch" checked>
      <div style="flex: 1;">
        <label for="contractDigitMatch">Digit Match</label>
        <div class="contract-description">Predict exact last digit - Uses AI prediction</div>
      </div>
    </div>
    <div class="contract-option" data-contract="DIGITOVER">
      <input type="radio" name="contractType" value="DIGITOVER" id="contractDigitOver">
      <div style="flex: 1;">
        <label for="contractDigitOver">Digit Over 5</label>
        <div class="contract-description">Last digit will be over 5 (6,7,8,9)</div>
      </div>
    </div>
    <div class="contract-option" data-contract="DIGITUNDER">
      <input type="radio" name="contractType" value="DIGITUNDER" id="contractDigitUnder">
      <div style="flex: 1;">
        <label for="contractDigitUnder">Digit Under 5</label>
        <div class="contract-description">Last digit will be under 5 (0,1,2,3,4)</div>
      </div>
    </div>
  </div>
</div>

<div class="card">
  <h3>ü§ñ AI Prediction Model</h3>
  <div class="ai-model-selector">
    <div class="ai-model-label">Select Prediction Engine:</div>
    <div class="model-option" data-model="weighted">
      <input type="radio" name="aiModel" value="weighted" id="modelWeighted">
      <div style="flex: 1;">
        <label for="modelWeighted">‚≠ê Weighted Markov (RECOMMENDED)</label>
        <div class="model-description">Exponential decay weighting - Best for recent patterns</div>
      </div>
    </div>
    <div class="model-option selected" data-model="adaptive">
      <input type="radio" name="aiModel" value="adaptive" id="modelAdaptive" checked>
      <div style="flex: 1;">
        <label for="modelAdaptive">üî• Adaptive Ensemble (BEST)</label>
        <div class="model-description">Self-adjusting multi-model with feature engineering</div>
      </div>
    </div>
    <div class="model-option" data-model="markov2">
      <input type="radio" name="aiModel" value="markov2" id="modelMarkov2">
      <div style="flex: 1;">
        <label for="modelMarkov2">Advanced Markov (2nd Order)</label>
        <div class="model-description">Two-digit sequence patterns</div>
      </div>
    </div>
    <div class="model-option" data-model="markov3">
      <input type="radio" name="aiModel" value="markov3" id="modelMarkov3">
      <div style="flex: 1;">
        <label for="modelMarkov3">Deep Markov (3rd Order)</label>
        <div class="model-description">Three-digit sequence patterns with smoothing</div>
      </div>
    </div>
    <div class="model-option" data-model="bayesian">
      <input type="radio" name="aiModel" value="bayesian" id="modelBayesian">
      <div style="flex: 1;">
        <label for="modelBayesian">Bayesian Predictor</label>
        <div class="model-description">Prior probability updates with evidence</div>
      </div>
    </div>
    <div class="ai-training-status" id="aiTrainingStatus">Model Ready</div>
  </div>
  
  <!-- Model Performance Tracker -->
  <div class="performance-tracker">
    <div class="performance-title">üìà Model Performance (Last 50 Predictions)</div>
    <div class="performance-grid">
      <div class="performance-item">
        <span class="name">Weighted Markov</span>
        <span class="accuracy" id="perfWeighted" style="color: #3b82f6;">--%</span>
      </div>
      <div class="performance-item">
        <span class="name">Adaptive Ensemble</span>
        <span class="accuracy" id="perfAdaptive" style="color: #8b5cf6;">--%</span>
      </div>
      <div class="performance-item">
        <span class="name">Markov-2</span>
        <span class="accuracy" id="perfMarkov2" style="color: #22c55e;">--%</span>
      </div>
      <div class="performance-item">
        <span class="name">Markov-3</span>
        <span class="accuracy" id="perfMarkov3" style="color: #f59e0b;">--%</span>
      </div>
    </div>
  </div>
</div>

<div class="card">
  <h3>üìä Enhanced Digit Match Analyzer</h3>
  <div class="analyzer-grid" id="digitDisplay"></div>
  <div class="analyzer-stats">
    <div><span>Predicted</span><b id="matchCount" style="color: #8b5cf6;">-</b></div>
    <div><span>Total Ticks</span><b id="totalCount" style="color: #e5e7eb;">0</b></div>
    <div><span>Frequency</span><b id="matchPercent" style="color: #8b5cf6;">0%</b></div>
  </div>
  
  <div class="prediction-box">
    <div class="prediction-status">üéØ AI Next Likely Digit Prediction</div>
    <div class="prediction-digit" id="predictionDisplay">
      <span class="prediction-waiting">WAITING...</span>
    </div>
    <div class="confidence-bar">
      <div class="confidence-fill" id="confidenceBar" style="width: 0%"></div>
    </div>
    <div class="prediction-info" id="predictionInfo">Analyzing tick patterns...</div>
    
    <div class="accuracy-metrics">
      <div class="accuracy-card">
        <div class="label">Probability</div>
        <div class="value" id="probabilityValue">0%</div>
      </div>
      <div class="accuracy-card">
        <div class="label">Entropy</div>
        <div class="value" id="entropyValue">0.0</div>
      </div>
      <div class="accuracy-card">
        <div class="label">Volatility</div>
        <div class="value" id="volatilityValue">0.0</div>
      </div>
    </div>
    
    <div id="patternIndicator" class="pattern-indicator pattern-weak">
      <strong>Pattern Strength:</strong> <span id="patternStrength">Learning...</span>
    </div>
  </div>

  <div style="margin-top: 15px; border-top: 1px solid #334155; padding-top: 10px;">
    <div style="font-size: 12px; font-weight: 600; color: #94a3b8; display: flex; justify-content: space-between;">
      <span>SYSTEM & TRADE LOG</span>
      <span id="clearLog" style="cursor:pointer; color:#3b82f6">Clear</span>
    </div>
    <div class="log-container" id="logContainer">
      <div class="log-entry"><span class="log-time">[System]</span> <span class="log-msg-success">AI Engine v2.0 Ready.</span></div>
    </div>
  </div>
</div>

<div class="card">
  <h3>Trade Settings</h3>
  
  <!-- Virtual Trade Section -->
  <div class="virtual-trade-container">
    <div class="virtual-trade-header">
      <div style="display:flex; flex-direction:column;">
        <span class="virtual-trade-label">üéÆ Virtual Trade Mode</span>
        <span style="font-size:9px; opacity:0.6;">Practice until consecutive losses hit, then go LIVE</span>
      </div>
      <div style="display:flex; align-items:center; gap: 8px;">
        <span class="virtual-mode-badge" id="virtualModeBadge">VIRTUAL MODE</span>
        <div style="display:flex; align-items:center;">
          <span style="font-size:10px; margin-right:5px; opacity:0.7;">OFF/ON</span>
          <input type="checkbox" id="virtualTradeToggle" class="toggle-checkbox save-setting">
        </div>
      </div>
    </div>
    
    <label style="margin-top: 5px;">Consecutive Losses to Switch to Live</label>
    <input id="virtualLossThreshold" class="save-setting" type="number" value="3" min="1" max="20" step="1">
    
    <div class="virtual-stats">
      <div class="virtual-stat-box">
        <span>Consecutive Losses</span>
        <b id="virtualConsecLosses">0</b>
      </div>
      <div class="virtual-stat-box">
        <span>Virtual Trades</span>
        <b id="virtualTotalTrades">0</b>
      </div>
      <div class="virtual-stat-box">
        <span>Virtual P/L</span>
        <b id="virtualProfit">0.00</b>
      </div>
    </div>
  </div>
  
  <label>Stake ($)</label>
  <input id="stake" class="save-setting" type="number" value="1" min="0.35" step="0.01">
  <label>Duration (Ticks)</label>
  <input id="duration" class="save-setting" type="number" value="1" min="1" max="10">
  <label>Cooldown (seconds)</label>
  <input id="cooldown" class="save-setting" type="number" value="2" min="1">
  
  <label>Minimum Confidence Threshold (%)</label>
  <input id="minConfidence" class="save-setting" type="number" value="12" min="0" max="100" step="1">
  
  <label>üéØ Adaptive Confidence (Auto-Adjust Based on Performance)</label>
  <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
    <input type="checkbox" id="adaptiveConfidence" class="save-setting toggle-checkbox" checked>
    <span style="font-size: 11px; opacity: 0.7;">Enable dynamic threshold adjustment</span>
  </div>

  <label>Manual Digit Override (0 = Auto Mode)</label>
  <input id="manualDigit" class="save-setting" type="number" value="0" min="0" max="9" step="1">

  <div style="margin-top: 15px; border-top: 1px solid #334155; padding-top: 15px;" id="mapperSection">
    <div class="switch-container">
      <div style="display:flex; flex-direction:column;">
        <span class="switch-label">‚ö° Exclusive Prediction Mapper</span>
        <span style="font-size:9px; opacity:0.6;">ONLY trades if Prediction matches Condition.</span>
      </div>
      <div style="display:flex; align-items:center;">
        <span style="font-size:10px; margin-right:5px; opacity:0.7;">OFF/ON</span>
        <input type="checkbox" id="mapperToggle" class="toggle-checkbox save-setting">
      </div>
    </div>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
      <div>
        <label style="font-size: 11px; color: #94a3b8; margin-top:0;">IF AI PREDICTS:</label>
        <input id="mapperTrigger" class="save-setting" type="number" placeholder="Trigger" min="0" max="9" style="border: 1px solid #ef4444; text-align: center;">
      </div>
      <div>
        <label style="font-size: 11px; color: #94a3b8; margin-top:0;">THEN TRADE:</label>
        <input id="mapperTarget" class="save-setting" type="number" placeholder="Target" min="0" max="9" style="border: 1px solid #22c55e; text-align: center;">
      </div>
    </div>
    <div style="font-size: 10px; opacity: 0.8; color: #fca5a5; margin-top: 5px; text-align: center;">
       Logic: If ON, bot ignores ALL predictions except Trigger.
    </div>
  </div>

  <label style="margin-top: 15px;">Market</label>
  <div class="radio-group" id="marketRadios">
      <div class="radio-option selected" data-market="R_10">
          <input type="radio" name="market" value="R_10" id="marketR10" checked>
          <label for="marketR10">R_10</label>
      </div>
      <div class="radio-option" data-market="R_25">
          <input type="radio" name="market" value="R_25" id="marketR25">
          <label for="marketR25">R_25</label>
      </div>
      <div class="radio-option" data-market="R_50">
          <input type="radio" name="market" value="R_50" id="marketR50">
          <label for="marketR50">R_50</label>
      </div>
      <div class="radio-option" data-market="R_75">
          <input type="radio" name="market" value="R_75" id="marketR75">
          <label for="marketR75">R_75</label>
      </div>
      <div class="radio-option" data-market="R_100">
          <input type="radio" name="market" value="R_100" id="marketR100">
          <label for="marketR100">R_100</label>
      </div>
  </div>
</div>

<div class="card">
  <h3>Risk Management</h3>
  <label>Stop Loss ($)</label>
  <input id="stoploss" class="save-setting" type="number" value="10" min="1">
  <label>Take Profit ($)</label>
  <input id="takeprofit" class="save-setting" type="number" value="10" min="1">
</div>

<button id="cycleBtn" class="btn-cycle">Auto Market Cycle: OFF</button>
<button id="cooldownBtn" class="btn-cooldown">Cycle Cooldown Loop: OFF</button>
<div id="cycleTimerDisplay" class="cycle-timer-display">Next Loop in: --:--</div>

<div class="card" style="margin-top: 0;">
  <label>Wait Time (Minutes)</label>
  <input id="cycleWaitTime" class="save-setting" type="number" value="5" min="1">
</div>

<div class="buttons">
  <button id="manualBtn">Manual Trade</button>
  <button id="autoBtn">Start Auto</button>
</div>

<button id="resetBtn" class="reset-button-permanent">üîÑ Reset All Stats</button>

<div class="card stats">
  <div><span>Trades</span><b id="trades">0</b></div>
  <div><span>Wins</span><b id="wins">0</b></div>
  <div><span>Losses</span><b id="losses">0</b></div>
  <div><span>P/L</span><b id="profit">0.00</b></div>
</div>

<div class="card">
<h3>Trade History</h3>
<div class="table-container">
<table>
<thead><tr><th>#</th><th>Mode</th><th>Result</th><th>P/L</th><th>Market</th></tr></thead>
<tbody id="history"></tbody>
</table>
</div>
</div>

</div>

<script>
(function() {
  'use strict';
  
  // ============ SHARED CONFIG ============
  const Config = {
    currentMarketValue: 'R_10',
    marketSequence: ["R_10", "R_25", "R_50", "R_75", "R_100"],
    accountBalance: 0,
    selectedAIModel: 'adaptive',
    selectedContractType: 'DIGITMATCH',
    maxHistoryRows: 500
  };

  // ============ APP MODULES ============
  const App = {
    modules: {},
    init() {
      this.modules.UI.init();
      this.modules.Connection.init();
      this.modules.AIEngine.init();
      this.modules.Analyzer.init();
      this.modules.VirtualTrade.init();
      this.modules.Trader.init();
      this.modules.PerformanceTracker.init();
      
      this.modules.UI.loadSettings();
      
      const savedToken = sessionStorage.getItem('derivToken');
      if (savedToken) { 
        document.getElementById('token').value = savedToken; 
        setTimeout(() => this.modules.Connection.connect(), 1000); 
      }
      
      this.modules.UI.addLog("System: AI Engine v2.0 Initialized.", "success");
    }
  };

  // ============ PERFORMANCE TRACKER MODULE ============
  App.modules.PerformanceTracker = (function() {
    let modelStats = {
      weighted: { predictions: 0, correct: 0, samples: [] },
      adaptive: { predictions: 0, correct: 0, samples: [] },
      markov2: { predictions: 0, correct: 0, samples: [] },
      markov3: { predictions: 0, correct: 0, samples: [] },
      bayesian: { predictions: 0, correct: 0, samples: [] }
    };
    
    const maxSamples = 50;
    
    function init() {
      // Load saved stats
      const saved = localStorage.getItem('model_performance_stats');
      if (saved) {
        try {
          modelStats = JSON.parse(saved);
          updateUI();
        } catch(e) {}
      }
    }
    
    function trackPrediction(modelName, predictedDigit, actualDigit) {
      if (!modelStats[modelName]) return;
      
      const isCorrect = predictedDigit === actualDigit;
      modelStats[modelName].predictions++;
      if (isCorrect) modelStats[modelName].correct++;
      
      // Keep last N samples for rolling accuracy
      modelStats[modelName].samples.push(isCorrect ? 1 : 0);
      if (modelStats[modelName].samples.length > maxSamples) {
        modelStats[modelName].samples.shift();
      }
      
      saveStats();
      updateUI();
    }
    
    function getAccuracy(modelName) {
      const stats = modelStats[modelName];
      if (!stats || stats.samples.length === 0) return 0;
      
      const correct = stats.samples.reduce((a, b) => a + b, 0);
      return (correct / stats.samples.length) * 100;
    }
    
    function getBestModel() {
      let bestModel = 'adaptive';
      let bestAccuracy = 0;
      
      for (let model in modelStats) {
        const stats = modelStats[model];
        if (stats.samples.length >= 20) {
          const accuracy = getAccuracy(model);
          if (accuracy > bestAccuracy) {
            bestAccuracy = accuracy;
            bestModel = model;
          }
        }
      }
      
      return { model: bestModel, accuracy: bestAccuracy };
    }
    
    function updateUI() {
      const weighted = getAccuracy('weighted');
      const adaptive = getAccuracy('adaptive');
      const markov2 = getAccuracy('markov2');
      const markov3 = getAccuracy('markov3');
      
      document.getElementById('perfWeighted').textContent = 
        weighted > 0 ? weighted.toFixed(1) + '%' : '--%';
      document.getElementById('perfAdaptive').textContent = 
        adaptive > 0 ? adaptive.toFixed(1) + '%' : '--%';
      document.getElementById('perfMarkov2').textContent = 
        markov2 > 0 ? markov2.toFixed(1) + '%' : '--%';
      document.getElementById('perfMarkov3').textContent = 
        markov3 > 0 ? markov3.toFixed(1) + '%' : '--%';
      
      // Color code based on performance
      const colorize = (el, acc) => {
        if (acc >= 15) el.style.color = '#22c55e';
        else if (acc >= 12) el.style.color = '#f59e0b';
        else if (acc > 0) el.style.color = '#ef4444';
        else el.style.color = '#94a3b8';
      };
      
      colorize(document.getElementById('perfWeighted'), weighted);
      colorize(document.getElementById('perfAdaptive'), adaptive);
      colorize(document.getElementById('perfMarkov2'), markov2);
      colorize(document.getElementById('perfMarkov3'), markov3);
    }
    
    function saveStats() {
      localStorage.setItem('model_performance_stats', JSON.stringify(modelStats));
    }
    
    function reset() {
      modelStats = {
        weighted: { predictions: 0, correct: 0, samples: [] },
        adaptive: { predictions: 0, correct: 0, samples: [] },
        markov2: { predictions: 0, correct: 0, samples: [] },
        markov3: { predictions: 0, correct: 0, samples: [] },
        bayesian: { predictions: 0, correct: 0, samples: [] }
      };
      saveStats();
      updateUI();
    }
    
    return {
      init,
      trackPrediction,
      getAccuracy,
      getBestModel,
      reset
    };
  })();

  // ============ ENHANCED AI ENGINE MODULE ============
  App.modules.AIEngine = (function() {
    // Higher-order Markov chains storage
    let markov2Matrix = {};
    let markov3Matrix = {};
    
    // Feature engineering
    let tickTimestamps = [];
    let volatilityBuffer = [];
    
    // Bayesian priors
    let priorProbabilities = Array(10).fill(0.1);
    
    function init() {
      document.querySelectorAll('.model-option').forEach(opt => {
        opt.addEventListener('click', (e) => {
          const model = e.currentTarget.dataset.model;
          selectModel(model);
        });
      });
      
      const savedModel = localStorage.getItem('selectedAIModel');
      if (savedModel) {
        selectModel(savedModel);
      }
    }
    
    function selectModel(model) {
      Config.selectedAIModel = model;
      document.querySelectorAll('.model-option').forEach(el => {
        el.classList.toggle('selected', el.dataset.model === model);
      });
      const radioEl = document.getElementById('model' + model.charAt(0).toUpperCase() + model.slice(1));
      if (radioEl) radioEl.checked = true;
      
      localStorage.setItem('selectedAIModel', model);
      
      const statusEl = document.getElementById('aiTrainingStatus');
      statusEl.textContent = `${getModelName(model)} Active`;
      
      App.modules.UI.addLog(`AI Model: ${getModelName(model)} selected`, "info");
    }
    
    function getModelName(model) {
      const names = {
        weighted: 'Weighted Markov',
        adaptive: 'Adaptive Ensemble',
        markov2: 'Advanced Markov (2nd Order)',
        markov3: 'Deep Markov (3rd Order)',
        bayesian: 'Bayesian Predictor'
      };
      return names[model] || 'Unknown Model';
    }
    
    // ========== ADVANCED FEATURE ENGINEERING ==========
    function calculateEntropy(sequence) {
      if (sequence.length === 0) return 0;
      const freq = {};
      sequence.forEach(d => freq[d] = (freq[d] || 0) + 1);
      let entropy = 0;
      for (let count of Object.values(freq)) {
        const p = count / sequence.length;
        if (p > 0) entropy -= p * Math.log2(p);
      }
      return entropy;
    }
    
    function calculateSkewness(data) {
      if (data.length < 3) return 0;
      const n = data.length;
      const mean = data.reduce((a, b) => a + b, 0) / n;
      const variance = data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / n;
      if (variance === 0) return 0;
      const stdDev = Math.sqrt(variance);
      const skewness = data.reduce((sum, val) => sum + Math.pow((val - mean) / stdDev, 3), 0) / n;
      return skewness;
    }
    
    function calculateVolatility(history, window = 10) {
      if (history.length < window) return 0;
      const recent = history.slice(0, window);
      const mean = recent.reduce((a, b) => a + b, 0) / window;
      const variance = recent.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / window;
      return Math.sqrt(variance);
    }
    
    function calculateEvenOddRatio(history) {
      if (history.length === 0) return 0.5;
      const evenCount = history.filter(d => d % 2 === 0).length;
      return evenCount / history.length;
    }
    
    function countConsecutiveRepeats(history) {
      if (history.length < 2) return 0;
      let count = 0;
      for (let i = 0; i < history.length - 1; i++) {
        if (history[i] === history[i + 1]) count++;
      }
      return count;
    }
    
    function extractAdvancedFeatures(history) {
      const features = {
        entropy: calculateEntropy(history.slice(0, 50)),
        volatility: calculateVolatility(history, 10),
        skewness: calculateSkewness(history.slice(0, 30)),
        evenOddRatio: calculateEvenOddRatio(history.slice(0, 100)),
        consecutiveRepeats: countConsecutiveRepeats(history.slice(0, 20)),
        hourOfDay: new Date().getHours(),
        minuteOfHour: new Date().getMinutes()
      };
      return features;
    }
    
    // ========== ADAPTIVE WINDOW SIZING ==========
    function getAdaptiveWindowSize(volatility, recentAccuracy) {
      if (volatility > 3.0) {
        return 20; // Shorter window for high volatility
      } else if (recentAccuracy < 0.12) {
        return 50; // Longer window when accuracy is poor
      } else {
        return 30; // Default
      }
    }
    
    // ========== WEIGHTED MARKOV PREDICTION ==========
    function predictWeightedMarkov(history, transitionMatrix, totalTransitions) {
      if (history.length < 10) return { digit: null, confidence: 0 };
      
      // Apply exponential decay weights
      const weights = history.slice(0, 10).map((_, i) => Math.exp(-0.15 * i));
      const weightedPredictions = {};
      
      for (let i = 0; i < Math.min(10, history.length - 1); i++) {
        const prevDigit = history[i];
        const weight = weights[i];
        const total = totalTransitions[prevDigit];
        
        if (total > 0) {
          for (let nextDigit = 0; nextDigit < 10; nextDigit++) {
            const transProb = transitionMatrix[prevDigit][nextDigit] / total;
            weightedPredictions[nextDigit] = 
              (weightedPredictions[nextDigit] || 0) + (transProb * weight);
          }
        }
      }
      
      const totalWeight = Object.values(weightedPredictions).reduce((a, b) => a + b, 0);
      if (totalWeight === 0) return { digit: null, confidence: 0 };
      
      let bestDigit = 0;
      let maxProb = 0;
      
      for (let d = 0; d < 10; d++) {
        const prob = (weightedPredictions[d] || 0) / totalWeight;
        if (prob > maxProb) {
          maxProb = prob;
          bestDigit = d;
        }
      }
      
      return { digit: bestDigit, confidence: maxProb * 100 };
    }
    
    // ========== MARKOV 2ND ORDER ==========
    function updateMarkov2(history) {
      if (history.length < 3) return;
      
      const prev2 = history[2];
      const prev1 = history[1];
      const current = history[0];
      
      const key = `${prev2}-${prev1}`;
      if (!markov2Matrix[key]) {
        markov2Matrix[key] = {};
      }
      markov2Matrix[key][current] = (markov2Matrix[key][current] || 0) + 1;
    }
    
    function predictMarkov2(history) {
      if (history.length < 2) return { digit: null, confidence: 0 };
      
      const prev2 = history[1];
      const prev1 = history[0];
      const key = `${prev2}-${prev1}`;
      
      const counts = markov2Matrix[key];
      if (!counts) return { digit: null, confidence: 0 };
      
      const total = Object.values(counts).reduce((a, b) => a + b, 0);
      if (total < 8) return { digit: null, confidence: 0 };
      
      let maxDigit = -1;
      let maxCount = -1;
      
      for (let d = 0; d < 10; d++) {
        const count = counts[d] || 0;
        if (count > maxCount) {
          maxCount = count;
          maxDigit = d;
        }
      }
      
      const probability = (maxCount / total) * 100;
      return { digit: maxDigit, confidence: probability };
    }
    
    // ========== MARKOV 3RD ORDER ==========
    function updateMarkov3(history) {
      if (history.length < 4) return;
      
      const prev3 = history[3];
      const prev2 = history[2];
      const prev1 = history[1];
      const current = history[0];
      
      const key = `${prev3}-${prev2}-${prev1}`;
      if (!markov3Matrix[key]) {
        markov3Matrix[key] = {};
      }
      markov3Matrix[key][current] = (markov3Matrix[key][current] || 0) + 1;
    }
    
    function predictMarkov3(history) {
      if (history.length < 3) return { digit: null, confidence: 0 };
      
      const prev3 = history[2];
      const prev2 = history[1];
      const prev1 = history[0];
      const key = `${prev3}-${prev2}-${prev1}`;
      
      const counts = markov3Matrix[key];
      if (!counts) return { digit: null, confidence: 0 };
      
      const total = Object.values(counts).reduce((a, b) => a + b, 0);
      if (total < 6) return { digit: null, confidence: 0 };
      
      // Laplace smoothing
      const alpha = 0.5;
      let maxDigit = -1;
      let maxProb = -1;
      
      for (let d = 0; d < 10; d++) {
        const rawCount = counts[d] || 0;
        const smoothedCount = rawCount + alpha;
        const smoothedTotal = total + (alpha * 10);
        const prob = smoothedCount / smoothedTotal;
        
        if (prob > maxProb) {
          maxProb = prob;
          maxDigit = d;
        }
      }
      
      return { digit: maxDigit, confidence: maxProb * 100 };
    }
    
    // ========== BAYESIAN PREDICTION ==========
    function updateBayesianPriors(actualDigit) {
      // Update priors based on observed frequency
      priorProbabilities[actualDigit] = 
        (priorProbabilities[actualDigit] * 0.95) + 0.05;
      
      // Normalize
      const total = priorProbabilities.reduce((a, b) => a + b, 0);
      priorProbabilities = priorProbabilities.map(p => p / total);
    }
    
    function predictBayesian(history, transitionMatrix, totalTransitions) {
      if (history.length < 5) return { digit: null, confidence: 0 };
      
      const lastDigit = history[0];
      const total = totalTransitions[lastDigit];
      if (total < 10) return { digit: null, confidence: 0 };
      
      // Calculate likelihood from transition matrix
      const likelihood = [];
      for (let d = 0; d < 10; d++) {
        likelihood[d] = transitionMatrix[lastDigit][d] / total;
      }
      
      // Bayesian update: posterior = prior * likelihood
      const posterior = [];
      let posteriorSum = 0;
      
      for (let d = 0; d < 10; d++) {
        posterior[d] = priorProbabilities[d] * likelihood[d];
        posteriorSum += posterior[d];
      }
      
      // Normalize
      if (posteriorSum === 0) return { digit: null, confidence: 0 };
      
      let bestDigit = 0;
      let maxProb = 0;
      
      for (let d = 0; d < 10; d++) {
        const prob = posterior[d] / posteriorSum;
        if (prob > maxProb) {
          maxProb = prob;
          bestDigit = d;
        }
      }
      
      return { digit: bestDigit, confidence: maxProb * 100 };
    }
    
    // ========== ADAPTIVE ENSEMBLE ==========
    function predictAdaptiveEnsemble(history, transitionMatrix, totalTransitions) {
      const predictions = [];
      const weights = [];
      
      // Get predictions from each model with performance-based weighting
      const weightedPred = predictWeightedMarkov(history, transitionMatrix, totalTransitions);
      if (weightedPred.digit !== null) {
        const perfWeight = 1 + (App.modules.PerformanceTracker.getAccuracy('weighted') / 100);
        predictions.push(weightedPred);
        weights.push(0.3 * perfWeight);
      }
      
      const markov2Pred = predictMarkov2(history);
      if (markov2Pred.digit !== null) {
        const perfWeight = 1 + (App.modules.PerformanceTracker.getAccuracy('markov2') / 100);
        predictions.push(markov2Pred);
        weights.push(0.35 * perfWeight);
      }
      
      const markov3Pred = predictMarkov3(history);
      if (markov3Pred.digit !== null) {
        const perfWeight = 1 + (App.modules.PerformanceTracker.getAccuracy('markov3') / 100);
        predictions.push(markov3Pred);
        weights.push(0.35 * perfWeight);
      }
      
      if (predictions.length === 0) {
        return { digit: null, confidence: 0 };
      }
      
      // Weighted voting with confidence
      const votes = {};
      const confidences = {};
      
      predictions.forEach((pred, idx) => {
        const digit = pred.digit;
        const weight = weights[idx];
        const weightedConf = pred.confidence * weight;
        
        votes[digit] = (votes[digit] || 0) + weight;
        confidences[digit] = (confidences[digit] || 0) + weightedConf;
      });
      
      let bestDigit = -1;
      let bestVote = -1;
      
      for (let d = 0; d < 10; d++) {
        const vote = votes[d] || 0;
        if (vote > bestVote) {
          bestVote = vote;
          bestDigit = d;
        }
      }
      
      const totalWeight = weights.reduce((a, b) => a + b, 0);
      const avgConfidence = confidences[bestDigit] / totalWeight;
      
      // Agreement boost
      const agreement = predictions.filter(p => p.digit === bestDigit).length;
      const agreementBoost = 1 + (agreement - 1) * 0.18;
      
      // Feature-based adjustment
      const features = extractAdvancedFeatures(history);
      let featureBoost = 1.0;
      
      // High entropy = more random, reduce confidence
      if (features.entropy > 3.0) featureBoost *= 0.9;
      
      // High volatility = less predictable
      if (features.volatility > 2.5) featureBoost *= 0.92;
      
      // Low consecutive repeats = more random
      if (features.consecutiveRepeats < 2) featureBoost *= 0.95;
      
      const finalConfidence = Math.min(avgConfidence * agreementBoost * featureBoost, 98);
      
      return { digit: bestDigit, confidence: finalConfidence };
    }
    
    // ========== MASTER PREDICTION ==========
    function getPrediction(history, transitionMatrix, totalTransitions) {
      const model = Config.selectedAIModel;
      
      switch(model) {
        case 'weighted':
          return predictWeightedMarkov(history, transitionMatrix, totalTransitions);
        
        case 'markov2':
          const pred2 = predictMarkov2(history);
          return pred2.digit !== null ? pred2 : 
                 predictWeightedMarkov(history, transitionMatrix, totalTransitions);
        
        case 'markov3':
          const pred3 = predictMarkov3(history);
          return pred3.digit !== null ? pred3 : 
                 predictWeightedMarkov(history, transitionMatrix, totalTransitions);
        
        case 'bayesian':
          return predictBayesian(history, transitionMatrix, totalTransitions);
        
        case 'adaptive':
        default:
          return predictAdaptiveEnsemble(history, transitionMatrix, totalTransitions);
      }
    }
    
    function updateModels(history) {
      updateMarkov2(history);
      updateMarkov3(history);
      
      if (history.length > 0) {
        updateBayesianPriors(history[0]);
        
        const volatility = calculateVolatility(history, 10);
        volatilityBuffer.push(volatility);
        if (volatilityBuffer.length > 100) volatilityBuffer.shift();
      }
      
      tickTimestamps.push(Date.now());
      if (tickTimestamps.length > 100) tickTimestamps.shift();
    }
    
    function reset() {
      markov2Matrix = {};
      markov3Matrix = {};
      tickTimestamps = [];
      volatilityBuffer = [];
      priorProbabilities = Array(10).fill(0.1);
      App.modules.UI.addLog("AI models reset for new market", "warn");
    }
    
    function getData() {
      return {
        markov2Matrix,
        markov3Matrix,
        volatilityBuffer,
        tickTimestamps,
        priorProbabilities
      };
    }
    
    function setData(data) {
      if (data.markov2Matrix) markov2Matrix = data.markov2Matrix;
      if (data.markov3Matrix) markov3Matrix = data.markov3Matrix;
      if (data.volatilityBuffer) volatilityBuffer = data.volatilityBuffer;
      if (data.tickTimestamps) tickTimestamps = data.tickTimestamps;
      if (data.priorProbabilities) priorProbabilities = data.priorProbabilities;
    }
    
    return {
      init,
      updateModels,
      getPrediction,
      reset,
      getData,
      setData,
      calculateVolatility,
      extractAdvancedFeatures
    };
  })();

  // ============ CONNECTION MODULE ============
  App.modules.Connection = (function() {
    let ws = null;
    let isConnected = false;
    let isExplicitLogout = false;
    let lastRequestTime = 0;
    
    function connect() {
      const token = document.getElementById('token').value.trim();
      if (!token) { 
        App.modules.UI.addLog("Error: API Token missing.", "error"); 
        return; 
      }
      if (ws) ws.close();
      sessionStorage.setItem('derivToken', token);
      isExplicitLogout = false;
      App.modules.UI.updateStatus('Connecting...', 'disconnected');
      
      ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=116948');
      
      ws.onopen = () => { 
        App.modules.UI.addLog("WebSocket Connected.", "info"); 
        sendAPIRequest({ authorize: token }); 
      };
      
      ws.onmessage = (msg) => handleMessage(JSON.parse(msg.data));
      
      ws.onclose = () => {
        isConnected = false;
        App.modules.UI.updateStatus('Disconnected', 'disconnected');
        document.getElementById('accountType').style.display = 'none';
        if (!isExplicitLogout) { 
          App.modules.UI.addLog("Connection lost. Reconnecting in 5s...", "warn"); 
          setTimeout(connect, 5000); 
        }
      };
      
      ws.onerror = (error) => { console.error("WebSocket error:", error); };
    }
    
    function handleMessage(data) {
      if (data.error) { 
        App.modules.UI.addLog(`API ERROR: ${data.error.message}`, "error"); 
        return; 
      }
      
      if (data.authorize) {
        isConnected = true;
        App.modules.UI.updateStatus('Connected', 'connected');
        const accTypeEl = document.getElementById('accountType');
        const isVirtual = data.authorize.is_virtual === 1 || data.authorize.loginid.includes('VRTC');
        accTypeEl.textContent = isVirtual ? 'Demo Account' : 'Live Account';
        accTypeEl.className = 'account-type ' + (isVirtual ? 'demo-badge' : 'live-badge');
        accTypeEl.style.display = 'block';
        App.modules.UI.addLog(`Authorized: ${data.authorize.email}`, "success");
        sendAPIRequest({ balance: 1, subscribe: 1 });
        subscribeToTicks();
        App.modules.UI.startSessionTimer();
        
        const persistedAuto = localStorage.getItem('isAutoRunning') === 'true';
        if(persistedAuto && !App.modules.Trader.getAutoRunning()) {
          App.modules.Trader.resumeAutoTrade();
        }
      }
      
      if (data.balance) { 
        Config.accountBalance = data.balance.balance; 
        App.modules.UI.updateBalance(); 
      }
      
      if (data.tick) {
        const lastDigit = parseInt(data.tick.quote.toString().slice(-1));
        App.modules.Analyzer.processTick(lastDigit);
      }
      
      if (data.buy) {
        App.modules.Trader.setContractId(data.buy.contract_id);
        App.modules.UI.addLog(`Trade Placed (ID: ${data.buy.contract_id})`, "success");
        sendAPIRequest({ proposal_open_contract: 1, contract_id: data.buy.contract_id, subscribe: 1 });
      }
      
      if (data.proposal_open_contract) {
        const contract = data.proposal_open_contract;
        if (contract.is_settled === 1 || ['won', 'lost', 'sold'].includes(contract.status)) {
          App.modules.Trader.handleTradeResult(contract);
          App.modules.Trader.setContractId(null);
          if (data.subscription) sendAPIRequest({ forget: data.subscription.id });
        }
      }
    }
    
    function sendAPIRequest(data) { 
      if (ws && ws.readyState === WebSocket.OPEN) { 
        const now = Date.now();
        if (now - lastRequestTime < 100) { 
          setTimeout(() => sendAPIRequest(data), 100);
          return false;
        }
        lastRequestTime = now;
        ws.send(JSON.stringify(data)); 
        return true; 
      } 
      return false; 
    }
    
    function subscribeToTicks() {
      const market = Config.currentMarketValue;
      sendAPIRequest({ forget_all: "ticks" });
      App.modules.Analyzer.resetForNewMarket();
      document.getElementById('digitDisplay').innerHTML = '';
      App.modules.UI.addLog(`Watching ${market}...`, "info");
      sendAPIRequest({ ticks: market, subscribe: 1 });
    }
    
    return {
      init() {
        document.getElementById('loginBtn').addEventListener('click', connect);
        document.getElementById('logoutBtn').addEventListener('click', () => { 
          isExplicitLogout = true; 
          localStorage.removeItem('isAutoRunning');
          if (ws) ws.close(); 
          sessionStorage.removeItem('derivToken'); 
          App.modules.UI.addLog("Logging out...", "info");
          setTimeout(() => location.reload(), 500);
        });
      },
      connect,
      subscribeToTicks,
      sendAPIRequest,
      isConnected: () => isConnected
    };
  })();

  // ============ ANALYZER MODULE ============
  App.modules.Analyzer = (function() {
    let digitHistory = [];
    let transitionMatrix = Array(10).fill(0).map(() => Array(10).fill(0));
    let totalTransitions = Array(10).fill(0);
    
    let predictedDigit = null;
    let predictionConfidence = 0;
    let lastDigit = null;
    let pendingPrediction = null;
    
    function processTick(digit) {
      // Validate pending prediction from previous tick
      if (pendingPrediction !== null) {
        App.modules.VirtualTrade.processPendingPrediction(digit, pendingPrediction);
        
        // Track prediction accuracy for all models
        const models = ['weighted', 'adaptive', 'markov2', 'markov3', 'bayesian'];
        models.forEach(model => {
          const savedModel = Config.selectedAIModel;
          Config.selectedAIModel = model;
          const pred = calculateInternalPrediction(lastDigit);
          if (pred.digit !== null) {
            App.modules.PerformanceTracker.trackPrediction(model, pred.digit, digit);
          }
          Config.selectedAIModel = savedModel;
        });
      }
      
      lastDigit = digit;
      
      // Update history and transition matrix
      digitHistory.unshift(digit);
      if (digitHistory.length > 1000) digitHistory.pop();
      
      if (digitHistory.length > 1) {
        const prevDigit = digitHistory[1];
        transitionMatrix[prevDigit][digit]++;
        totalTransitions[prevDigit]++;
      }
      
      // Update AI models
      App.modules.AIEngine.updateModels(digitHistory);
      
      // Calculate prediction for NEXT tick
      const nextPrediction = calculateInternalPrediction(digit);
      pendingPrediction = nextPrediction;
      
      // Check for auto-trade opportunity
      if (App.modules.Trader.getAutoRunning() && !App.modules.Trader.getCycleCooldown()) {
         App.modules.Trader.checkAndAutoTrade(nextPrediction); 
      }
      
      // Update UI
      updateDisplay();
      updatePredictionUI(nextPrediction, digit);
    }
    
    function calculateInternalPrediction(lastDigit) {
      const aiPrediction = App.modules.AIEngine.getPrediction(
        digitHistory, 
        transitionMatrix, 
        totalTransitions
      );
      
      return aiPrediction;
    }
    
    function updatePredictionUI(pred, lastDigit) {
      predictedDigit = pred.digit;
      predictionConfidence = pred.confidence;
      
      const total = totalTransitions[lastDigit];
      
      if (pred.digit === null) {
        const minSamples = 10;
        document.getElementById('predictionInfo').textContent = 
          `Gathering data for digit ${lastDigit}... (${total}/${minSamples})`;
        App.modules.UI.updatePredictionDisplay(null, 0);
        return;
      }

      const modelName = getModelDisplayName();
      const info = `${modelName}: After ${lastDigit}, predicts ${pred.digit} NEXT with ${pred.confidence.toFixed(1)}% probability.`;
      document.getElementById('predictionInfo').textContent = info;
      
      const strengthEl = document.getElementById('patternStrength');
      const indicatorEl = document.getElementById('patternIndicator');
      
      if (pred.confidence > 18) {
        strengthEl.textContent = "Strong Trend Detected";
        indicatorEl.className = "pattern-indicator pattern-strong";
      } else if (pred.confidence > 13) {
        strengthEl.textContent = "Moderate Trend";
        indicatorEl.className = "pattern-indicator pattern-medium";
      } else {
        strengthEl.textContent = "Random / Weak Signal";
        indicatorEl.className = "pattern-indicator pattern-weak";
      }
      
      document.getElementById('probabilityValue').textContent = pred.confidence.toFixed(1) + '%';
      
      // Display advanced features
      const features = App.modules.AIEngine.extractAdvancedFeatures(digitHistory);
      document.getElementById('entropyValue').textContent = features.entropy.toFixed(2);
      document.getElementById('volatilityValue').textContent = features.volatility.toFixed(2);
      
      App.modules.UI.updatePredictionDisplay(pred.digit, pred.confidence);
    }
    
    function getModelDisplayName() {
      const model = Config.selectedAIModel;
      const names = {
        weighted: 'Weighted-Markov',
        adaptive: 'Adaptive-AI',
        markov2: 'Markov-2',
        markov3: 'Markov-3',
        bayesian: 'Bayesian'
      };
      return names[model] || 'AI';
    }
    
    function updateDisplay() {
      const container = document.getElementById('digitDisplay');
      container.innerHTML = '';
      digitHistory.slice(0, 50).forEach((digit, i) => {
        const box = document.createElement('div');
        box.className = `digit-box ${i===0 ? 'digit-match' : 'digit-other'}`;
        box.textContent = digit;
        container.appendChild(box);
      });
      
      const last = digitHistory[0];
      if(last !== undefined) {
          const total = digitHistory.length;
          const count = digitHistory.filter(d => d === last).length;
          document.getElementById('matchCount').textContent = last;
          document.getElementById('totalCount').textContent = total;
          document.getElementById('matchPercent').textContent = ((count/total)*100).toFixed(1) + "%";
      }
    }
    
    return {
      init() {},
      processTick,
      resetForNewMarket: () => {
        digitHistory = [];
        transitionMatrix = Array(10).fill(0).map(() => Array(10).fill(0));
        totalTransitions = Array(10).fill(0);
        predictedDigit = null;
        predictionConfidence = 0;
        lastDigit = null;
        pendingPrediction = null;
        App.modules.AIEngine.reset();
        App.modules.UI.addLog("Memory wiped for new market", "warn");
      },
      getPrediction: () => {
        return { digit: predictedDigit, confidence: predictionConfidence };
      },
      getLastDigit: () => lastDigit,
      getData: () => ({ 
        transitionMatrix, 
        totalTransitions,
        aiData: App.modules.AIEngine.getData()
      }),
      setData: (data) => {
        if(data.transitionMatrix) transitionMatrix = data.transitionMatrix;
        if(data.totalTransitions) totalTransitions = data.totalTransitions;
        if(data.aiData) App.modules.AIEngine.setData(data.aiData);
      }
    };
  })();

  // ============ VIRTUAL TRADE MODULE ============
  App.modules.VirtualTrade = (function() {
    let isVirtualMode = false;
    let virtualStats = {
      totalTrades: 0,
      consecLosses: 0,
      profit: 0
    };
    let pendingVirtualTrade = null;
    
    function init() {
      document.getElementById('virtualTradeToggle').addEventListener('change', (e) => {
        const isEnabled = e.target.checked;
        if (isEnabled) {
          resetVirtualStats();
          App.modules.UI.addLog("Virtual Trade Mode ENABLED", "info");
          document.getElementById('virtualModeBadge').classList.add('active');
        } else {
          App.modules.UI.addLog("Virtual Trade Mode DISABLED", "warn");
          document.getElementById('virtualModeBadge').classList.remove('active');
        }
        App.modules.UI.saveSettings();
      });
      
      const saved = localStorage.getItem('virtual_stats_dm_pro');
      if (saved) {
        virtualStats = JSON.parse(saved);
        updateVirtualUI();
      }
    }
    
    function isEnabled() {
      return document.getElementById('virtualTradeToggle').checked;
    }
    
    function shouldSwitchToLive() {
      const threshold = parseInt(document.getElementById('virtualLossThreshold').value);
      return virtualStats.consecLosses >= threshold;
    }
    
    function queueVirtualTrade(contractType, targetDigit, confidence) {
      if (!isVirtualMode) {
        isVirtualMode = true;
      }
      
      pendingVirtualTrade = {
        contractType: contractType,
        targetDigit: targetDigit,
        confidence: confidence,
        timestamp: Date.now()
      };
      
      const typeDesc = contractType === 'DIGITMATCH' ? `Digit ${targetDigit}` : 
                       contractType === 'DIGITOVER' ? 'Over 5' : 'Under 5';
      App.modules.UI.addLog(`[VIRTUAL] Trade queued for NEXT tick: ${typeDesc} (Prob: ${confidence.toFixed(1)}%)`, "info");
    }
    
    function processPendingPrediction(actualDigit, prediction) {
      if (!pendingVirtualTrade) return;
      
      const trade = pendingVirtualTrade;
      pendingVirtualTrade = null;
      
      virtualStats.totalTrades++;
      
      let isWin = false;
      if (trade.contractType === 'DIGITMATCH') {
        isWin = (actualDigit === trade.targetDigit);
      } else if (trade.contractType === 'DIGITOVER') {
        isWin = (actualDigit > 5);
      } else if (trade.contractType === 'DIGITUNDER') {
        isWin = (actualDigit < 5);
      }
      
      const stake = parseFloat(document.getElementById('stake').value);
      const payout = isWin ? stake * 0.95 : -stake;
      
      virtualStats.profit += payout;
      
      const typeDesc = trade.contractType === 'DIGITMATCH' ? `Digit ${trade.targetDigit}` : 
                       trade.contractType === 'DIGITOVER' ? 'Over 5' : 'Under 5';
      
      if (isWin) {
        virtualStats.consecLosses = 0;
        App.modules.UI.addLog(`[VIRTUAL] WIN: Predicted ${typeDesc}, got ${actualDigit} ($${payout.toFixed(2)})`, "success");
      } else {
        virtualStats.consecLosses++;
        App.modules.UI.addLog(`[VIRTUAL] LOSS: Predicted ${typeDesc}, got ${actualDigit} ($${payout.toFixed(2)}) | Consecutive: ${virtualStats.consecLosses}`, "error");
      }
      
      App.modules.UI.addToHistory(virtualStats.totalTrades, isWin ? 'Win' : 'Loss', payout, Config.currentMarketValue, true);
      
      updateVirtualUI();
      saveVirtualStats();
      
      if (shouldSwitchToLive()) {
        switchToLiveMode();
      }
      
      return { isWin, payout };
    }
    
    function switchToLiveMode() {
      App.modules.UI.addLog(`üî¥ SWITCHING TO LIVE MODE - ${virtualStats.consecLosses} consecutive losses reached!`, "warn");
      document.getElementById('virtualTradeToggle').checked = false;
      document.getElementById('virtualModeBadge').classList.remove('active');
      isVirtualMode = false;
      
      virtualStats.consecLosses = 0;
      updateVirtualUI();
      saveVirtualStats();
    }
    
    function updateVirtualUI() {
      document.getElementById('virtualConsecLosses').textContent = virtualStats.consecLosses;
      document.getElementById('virtualTotalTrades').textContent = virtualStats.totalTrades;
      const profitEl = document.getElementById('virtualProfit');
      profitEl.textContent = virtualStats.profit.toFixed(2);
      profitEl.style.color = virtualStats.profit > 0 ? '#22c55e' : (virtualStats.profit < 0 ? '#ef4444' : '#8b5cf6');
    }
    
    function saveVirtualStats() {
      localStorage.setItem('virtual_stats_dm_pro', JSON.stringify(virtualStats));
    }
    
    function resetVirtualStats() {
      virtualStats = {
        totalTrades: 0,
        consecLosses: 0,
        profit: 0
      };
      isVirtualMode = false;
      pendingVirtualTrade = null;
      updateVirtualUI();
      saveVirtualStats();
    }
    
    return {
      init,
      isEnabled,
      queueVirtualTrade,
      processPendingPrediction,
      resetVirtualStats,
      getStats: () => virtualStats
    };
  })();

  // ============ TRADER MODULE ============
  App.modules.Trader = (function() {
    let isAutoRunning = false;
    let currentContractId = null;
    let stats = { trades: 0, wins: 0, losses: 0, profit: 0 };
    let lastTradeTime = 0;
    let recentPerformance = [];
    
    let isMarketCycleActive = false;
    let isCooldownLoopActive = false;
    let isCycleCooldown = false;
    let currentMarketIndex = 0;
    let cycleTimerId = null;
    
    function placeTrade(contractType, targetDigit, conf, isVirtual = false) {
      if (!App.modules.Connection.isConnected() && !isVirtual) {
        App.modules.UI.addLog("Error: Not connected to Deriv", "error");
        return;
      }
      
      const stake = parseFloat(document.getElementById('stake').value);
      const duration = parseInt(document.getElementById('duration').value);
      const market = Config.currentMarketValue;
      
      if (isNaN(stake) || stake < 0.35) {
        App.modules.UI.addLog("Error: Invalid stake amount", "error");
        return;
      }
      
      if (contractType === 'DIGITMATCH') {
        if (isNaN(targetDigit) || targetDigit < 0 || targetDigit > 9) {
          App.modules.UI.addLog("Error: Invalid target digit", "error");
          return;
        }
      }
      
      if (isVirtual) {
        const typeDesc = contractType === 'DIGITMATCH' ? `Digit ${targetDigit}` : 
                         contractType === 'DIGITOVER' ? 'Over 5' : 'Under 5';
        App.modules.UI.addLog(`[VIRTUAL] Queuing ${typeDesc} for NEXT tick (AI Prob: ${conf.toFixed(1)}%)`, "info");
        App.modules.VirtualTrade.queueVirtualTrade(contractType, targetDigit, conf);
        return;
      }
      
      const typeDesc = contractType === 'DIGITMATCH' ? `Digit ${targetDigit}` : 
                       contractType === 'DIGITOVER' ? 'Over 5' : 'Under 5';
      App.modules.UI.addLog(`[LIVE] Buying ${typeDesc} for NEXT tick (AI Prob: ${conf.toFixed(1)}%)`, "info");
      
      const params = {
        contract_type: contractType,
        symbol: market,
        duration: duration,
        duration_unit: 't',
        amount: stake,
        basis: 'stake',
        currency: 'USD'
      };
      
      if (contractType === 'DIGITMATCH') {
        params.barrier = targetDigit.toString();
      } else if (contractType === 'DIGITOVER') {
        params.barrier = '5';
      } else if (contractType === 'DIGITUNDER') {
        params.barrier = '5';
      }
      
      App.modules.Connection.sendAPIRequest({
        buy: 1,
        price: stake,
        parameters: params
      });
    }
    
    function getAdaptiveConfidenceThreshold() {
      if (!document.getElementById('adaptiveConfidence').checked) {
        return parseFloat(document.getElementById('minConfidence').value);
      }
      
      const baseThreshold = parseFloat(document.getElementById('minConfidence').value);
      
      if (recentPerformance.length < 10) {
        return baseThreshold;
      }
      
      const wins = recentPerformance.filter(r => r.win).length;
      const total = recentPerformance.length;
      const winRate = wins / total;
      
      if (winRate < 0.35) {
        return baseThreshold + 8; // Be more conservative
      } else if (winRate > 0.55) {
        return Math.max(10, baseThreshold - 4); // Can be more aggressive
      }
      return baseThreshold;
    }
    
    function checkAndAutoTrade(prediction) {
      if (currentContractId !== null) return;
      
      const now = Date.now();
      const cooldownSec = parseFloat(document.getElementById('cooldown').value);
      
      const isVirtualEnabled = App.modules.VirtualTrade.isEnabled();
      const contractType = Config.selectedContractType;
      
      if (contractType === 'DIGITMATCH') {
        if (prediction.digit === null || prediction.digit === undefined) return;
        
        const isMapperOn = document.getElementById('mapperToggle').checked;
        const mapTrigger = document.getElementById('mapperTrigger').value;
        const mapTarget = document.getElementById('mapperTarget').value;
        
        let finalTarget = prediction.digit;
        let finalConfidence = prediction.confidence;
        
        if (isMapperOn && mapTrigger !== "" && mapTarget !== "") {
          const trigger = parseInt(mapTrigger);
          const target = parseInt(mapTarget);
          
          if (isNaN(trigger) || isNaN(target) || trigger < 0 || trigger > 9 || target < 0 || target > 9) {
            return;
          }
          
          if (prediction.digit === trigger) {
            finalTarget = target;
            App.modules.UI.addLog(`‚ö° Map Active: AI predicts ${trigger} NEXT, Trading ${target}`, "warn");
          } else {
            return;
          }
        } else {
          const manualDigit = parseInt(document.getElementById('manualDigit').value);
          if (!isNaN(manualDigit) && manualDigit !== 0 && prediction.digit !== manualDigit) {
            return;
          }
        }
        
        if (isNaN(finalTarget) || finalTarget < 0 || finalTarget > 9) {
          App.modules.UI.addLog("Error: Invalid final target digit", "error");
          return;
        }
        
        const userMinConf = getAdaptiveConfidenceThreshold();
        if (finalConfidence < userMinConf) return;
        
        if (now - lastTradeTime < (cooldownSec * 1000)) return;
        
        lastTradeTime = now;
        
        if (isVirtualEnabled) {
          placeTrade('DIGITMATCH', finalTarget, finalConfidence, true);
        } else {
          placeTrade('DIGITMATCH', finalTarget, finalConfidence, false);
        }
        
      } else if (contractType === 'DIGITOVER' || contractType === 'DIGITUNDER') {
        if (prediction.digit === null || prediction.digit === undefined) return;
        
        const userMinConf = getAdaptiveConfidenceThreshold();
        if (prediction.confidence < userMinConf) return;
        
        const manualDigit = parseInt(document.getElementById('manualDigit').value);
        if (!isNaN(manualDigit) && manualDigit !== 0 && prediction.digit !== manualDigit) {
          return;
        }
        
        if (now - lastTradeTime < (cooldownSec * 1000)) return;
        
        lastTradeTime = now;
        
        if (isVirtualEnabled) {
          placeTrade(contractType, null, prediction.confidence, true);
        } else {
          placeTrade(contractType, null, prediction.confidence, false);
        }
      }
    }
    
    function handleTradeResult(contract) {
      const isWin = contract.status === 'won';
      const pl = parseFloat(contract.profit || 0);
      
      stats.trades++;
      if(isWin) stats.wins++; else stats.losses++;
      stats.profit += pl;
      
      // Track recent performance for adaptive confidence
      recentPerformance.push({ win: isWin, profit: pl, timestamp: Date.now() });
      if (recentPerformance.length > 50) recentPerformance.shift();
      
      App.modules.UI.addLog(`[LIVE] Result: ${isWin?'WIN':'LOSS'} ($${pl.toFixed(2)})`, isWin?'success':'error');
      App.modules.UI.updateStats(stats);
      App.modules.UI.addToHistory(stats.trades, isWin?'Win':'Loss', pl, Config.currentMarketValue, false);
      
      localStorage.setItem('trade_stats_dm_pro', JSON.stringify(stats));
      localStorage.setItem('trade_history_dm_pro', document.getElementById('history').innerHTML);
      
      checkTargets();
    }
    
    function checkTargets() {
      const tp = parseFloat(document.getElementById('takeprofit').value);
      const sl = parseFloat(document.getElementById('stoploss').value);
      
      if (stats.profit <= -sl) {
        toggleAuto(false);
        App.modules.UI.addLog("Stop Loss Hit.", "error");
        return;
      }
      
      if (stats.profit >= tp) {
        if (isMarketCycleActive) {
           advanceCycle();
        } else {
           toggleAuto(false);
           App.modules.UI.addLog("Take Profit Hit.", "success");
        }
      }
    }
    
    function advanceCycle() {
      if (currentMarketIndex < Config.marketSequence.length - 1) {
        currentMarketIndex++;
        const next = Config.marketSequence[currentMarketIndex];
        App.modules.UI.addLog(`Cycle Target Reached. Switching to ${next}`, "success");
        
        stats = { trades: 0, wins: 0, losses: 0, profit: 0 };
        App.modules.UI.updateStats(stats);
        
        App.modules.UI.selectMarket(next);
      } else {
        App.modules.UI.addLog("Full Market Cycle Complete.", "success");
        stats = { trades: 0, wins: 0, losses: 0, profit: 0 };
        App.modules.UI.updateStats(stats);
        
        if (isCooldownLoopActive) {
          startCycleCooldown();
        } else {
          toggleAuto(false);
          isMarketCycleActive = false;
          document.getElementById('cycleBtn').classList.remove('active');
          document.getElementById('cycleBtn').textContent = "Auto Market Cycle: OFF";
        }
      }
    }
    
    function startCycleCooldown() {
      isCycleCooldown = true;
      let min = parseInt(document.getElementById('cycleWaitTime').value);
      let sec = min * 60;
      const disp = document.getElementById('cycleTimerDisplay');
      disp.style.display = 'block';
      
      App.modules.UI.addLog(`Cycle cooldown active: waiting ${min}m...`, "warn");
      
      if (cycleTimerId) clearInterval(cycleTimerId);
      cycleTimerId = setInterval(() => {
        sec--;
        const m = Math.floor(sec/60);
        const s = sec%60;
        disp.textContent = `Next Loop in: ${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
        
        if (sec <= 0) {
          clearInterval(cycleTimerId);
          isCycleCooldown = false;
          currentMarketIndex = 0;
          disp.style.display = 'none';
          const nextMarket = Config.marketSequence[0];
          Config.currentMarketValue = nextMarket;
          App.modules.UI.selectMarket(nextMarket);
          document.getElementById('cycleBtn').textContent = `Auto Market Cycle: ON (${nextMarket})`;
          App.modules.UI.addLog(`Cooldown finished. Restarting cycle at ${nextMarket}.`, "success");
        }
      }, 1000);
    }
    
    function toggleAuto(forceState) {
      if (typeof forceState === 'boolean') isAutoRunning = forceState;
      else isAutoRunning = !isAutoRunning;
      
      const btn = document.getElementById('autoBtn');
      if (isAutoRunning) {
        localStorage.setItem('isAutoRunning', 'true');
        btn.textContent = "Stop Auto";
        btn.style.background = "#ef4444";
        
        const mode = App.modules.VirtualTrade.isEnabled() ? "VIRTUAL" : "LIVE";
        const model = Config.selectedAIModel.toUpperCase();
        const contractType = Config.selectedContractType === 'DIGITMATCH' ? 'DIGIT MATCH' :
                            Config.selectedContractType === 'DIGITOVER' ? 'DIGIT OVER 5' : 'DIGIT UNDER 5';
        App.modules.UI.addLog(`Auto-Trade Enabled in ${mode} mode using ${model} for ${contractType}.`, "success");
      } else {
        localStorage.removeItem('isAutoRunning');
        btn.textContent = "Start Auto";
        btn.style.background = "#22c55e";
        App.modules.UI.addLog("Auto-Trade Stopped.", "warn");
      }
    }
    
    function toggleMarketCycle() {
      isMarketCycleActive = !isMarketCycleActive;
      const btn = document.getElementById('cycleBtn');
      if (isMarketCycleActive) {
        btn.classList.add('active');
        currentMarketIndex = Config.marketSequence.indexOf(Config.currentMarketValue);
        if(currentMarketIndex === -1) currentMarketIndex = 0;
        btn.textContent = `Auto Market Cycle: ON (${Config.marketSequence[currentMarketIndex]})`;
        App.modules.UI.addLog(`Market Cycle Started at ${Config.marketSequence[currentMarketIndex]}.`, "info");
      } else {
        btn.classList.remove('active');
        btn.textContent = "Auto Market Cycle: OFF";
        App.modules.UI.addLog(`Market Cycle Disabled.`, "warn");
      }
    }
    
    function toggleCooldownLoop() {
      isCooldownLoopActive = !isCooldownLoopActive;
      const btn = document.getElementById('cooldownBtn');
      if (isCooldownLoopActive) {
        btn.classList.add('active');
        btn.textContent = "Cycle Cooldown Loop: ON";
        App.modules.UI.addLog(`Cooldown Loop Enabled.`, "info");
      } else {
        btn.classList.remove('active');
        btn.textContent = "Cycle Cooldown Loop: OFF";
        App.modules.UI.addLog(`Cooldown Loop Disabled.`, "warn");
      }
    }
    
    function resetStats() {
      stats = { trades: 0, wins: 0, losses: 0, profit: 0 };
      recentPerformance = [];
      App.modules.UI.updateStats(stats);
      document.getElementById('history').innerHTML = '';
      localStorage.removeItem('trade_stats_dm_pro');
      localStorage.removeItem('trade_history_dm_pro');
      
      App.modules.VirtualTrade.resetVirtualStats();
      App.modules.PerformanceTracker.reset();
      
      App.modules.UI.addLog("All stats reset.", "info");
    }
    
    return {
      init() {
        document.getElementById('autoBtn').addEventListener('click', () => toggleAuto());
        document.getElementById('manualBtn').addEventListener('click', () => {
            const pred = App.modules.Analyzer.getPrediction();
            const contractType = Config.selectedContractType;
            const isVirtual = App.modules.VirtualTrade.isEnabled();
            
            if (contractType === 'DIGITMATCH') {
              if(pred.digit !== null && pred.digit !== undefined) {
                placeTrade('DIGITMATCH', pred.digit, pred.confidence, isVirtual);
              } else {
                App.modules.UI.addLog("No prediction available yet", "warn");
              }
            } else if (contractType === 'DIGITOVER') {
              if(pred.digit !== null && pred.digit !== undefined) {
                placeTrade('DIGITOVER', null, pred.confidence, isVirtual);
              } else {
                App.modules.UI.addLog("No prediction available yet", "warn");
              }
            } else if (contractType === 'DIGITUNDER') {
              if(pred.digit !== null && pred.digit !== undefined) {
                placeTrade('DIGITUNDER', null, pred.confidence, isVirtual);
              } else {
                App.modules.UI.addLog("No prediction available yet", "warn");
              }
            }
        });
        document.getElementById('cycleBtn').addEventListener('click', toggleMarketCycle);
        document.getElementById('cooldownBtn').addEventListener('click', toggleCooldownLoop);
        document.getElementById('resetBtn').addEventListener('click', resetStats);
        
        const s = localStorage.getItem('trade_stats_dm_pro');
        if(s) { stats = JSON.parse(s); App.modules.UI.updateStats(stats); }
      },
      checkAndAutoTrade,
      setContractId: (id) => currentContractId = id,
      handleTradeResult,
      getAutoRunning: () => isAutoRunning,
      getCycleCooldown: () => isCycleCooldown,
      resumeAutoTresumeAutoTrade: () => toggleAuto(true)
    };
  })();

  // ============ UI MODULE ============
  App.modules.UI = (function() {
    let sessionStartTime = null;
    let timerIntervalId = null;
    
    function init() {
      // Market selection
      document.querySelectorAll('#marketRadios .radio-option').forEach(opt => {
        opt.addEventListener('click', (e) => {
          const m = e.currentTarget.dataset.market;
          selectMarket(m);
        });
      });
      
      // Contract type selection
      document.querySelectorAll('.contract-option').forEach(opt => {
        opt.addEventListener('click', (e) => {
          const contractType = e.currentTarget.dataset.contract;
          selectContractType(contractType);
        });
      });
      
      document.querySelectorAll('.save-setting').forEach(el => {
        el.addEventListener('change', saveSettings);
        el.addEventListener('input', saveSettings);
      });
      
      document.getElementById('clearLog').addEventListener('click', () => {
         document.getElementById('logContainer').innerHTML = '';
      });
    }
    
    function selectContractType(type) {
      Config.selectedContractType = type;
      document.querySelectorAll('.contract-option').forEach(el => {
        el.classList.toggle('selected', el.dataset.contract === type);
      });
      const radioEl = document.getElementById('contract' + type.charAt(0).toUpperCase() + type.slice(1).replace('OVER', 'Over').replace('UNDER', 'Under').replace('MATCH', 'Match'));
      if (radioEl) radioEl.checked = true;
      
      // Show/hide mapper section based on contract type
      const mapperSection = document.getElementById('mapperSection');
      if (type === 'DIGITMATCH') {
        mapperSection.style.display = 'block';
      } else {
        mapperSection.style.display = 'none';
      }
      
      localStorage.setItem('selectedContractType', type);
      
      const typeNames = {
        DIGITMATCH: 'Digit Match',
        DIGITOVER: 'Digit Over 5',
        DIGITUNDER: 'Digit Under 5'
      };
      addLog(`Contract Type: ${typeNames[type]} selected`, "info");
    }
    
    function addLog(msg, type = 'info') {
      const container = document.getElementById('logContainer');
      const time = new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `<span class="log-time">[${time}]</span> <span class="log-msg-${type}">${msg}</span>`;
      container.appendChild(entry);
      container.scrollTop = container.scrollHeight;
    }
    
    function updateStatus(text, className) { 
      const s = document.getElementById('status'); 
      s.textContent = text; 
      s.className = 'status ' + className; 
    }
    
    function updateBalance() { 
      document.getElementById('balanceDisplay').style.display = 'block'; 
      document.getElementById('balance').textContent = parseFloat(Config.accountBalance).toFixed(2); 
    }
    
    function updateStats(stats) {
      document.getElementById('trades').textContent = stats.trades;
      document.getElementById('wins').textContent = stats.wins;
      document.getElementById('losses').textContent = stats.losses;
      const p = document.getElementById('profit');
      p.textContent = stats.profit.toFixed(2);
      p.style.color = stats.profit > 0 ? '#22c55e' : (stats.profit < 0 ? '#ef4444' : '#e5e7eb');
    }
    
    function startSessionTimer() {
      if (timerIntervalId) clearInterval(timerIntervalId);
      sessionStartTime = Date.now(); 
      timerIntervalId = setInterval(() => {
        const now = Date.now();
        const s = Math.floor((now - sessionStartTime) / 1000);
        document.getElementById('sessionTimer').textContent = `Session: ${Math.floor(s/3600).toString().padStart(2,'0')}:${Math.floor((s%3600)/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`;
      }, 1000);
    }
    
    function addToHistory(n, res, pl, m, isVirtual = false) {
      const tbody = document.getElementById('history');
      const row = tbody.insertRow(0);
      const cls = res === 'Win' ? 'win' : 'loss';
      const mode = isVirtual ? 'Virtual' : 'Live';
      row.innerHTML = `<td>${n}</td><td style="color: ${isVirtual ? '#8b5cf6' : '#22c55e'}">${mode}</td><td class="${cls}">${res}</td><td class="${cls}">${pl.toFixed(2)}</td><td>${m}</td>`;
      
      // Limit history to max rows
      while (tbody.rows.length > Config.maxHistoryRows) {
        tbody.deleteRow(tbody.rows.length - 1);
      }
    }
    
    function updatePredictionDisplay(digit, conf) {
      const box = document.getElementById('predictionDisplay');
      const bar = document.getElementById('confidenceBar');
      
      const visualPercent = Math.min(100, (conf / 25) * 100);
      bar.style.width = visualPercent + '%';
      
      if (digit !== null && digit !== undefined) {
        const color = conf > 18 ? '#22c55e' : (conf > 13 ? '#f59e0b' : '#94a3b8');
        box.innerHTML = `<span class="prediction-ready" style="color:${color}">DIGIT ${digit}</span>`;
      } else {
        box.innerHTML = `<span class="prediction-waiting">WAITING...</span>`;
      }
    }
    
    function saveSettings() {
      const set = {
        analyzer: App.modules.Analyzer.getData(),
        market: Config.currentMarketValue,
        mapperToggle: document.getElementById('mapperToggle').checked,
        virtualTradeToggle: document.getElementById('virtualTradeToggle').checked,
        adaptiveConfidence: document.getElementById('adaptiveConfidence').checked,
        selectedAIModel: Config.selectedAIModel,
        selectedContractType: Config.selectedContractType
      };
      document.querySelectorAll('.save-setting').forEach(el => {
        if(el.type !== 'checkbox') set[el.id] = el.value;
      });
      localStorage.setItem('settings_dm_pro', JSON.stringify(set));
    }
    
    function loadSettings() {
      const s = localStorage.getItem('settings_dm_pro');
      if(s) {
        const set = JSON.parse(s);
        for(let k in set) {
          const el = document.getElementById(k);
          if(el && el.type !== 'checkbox') el.value = set[k];
        }
        
        if(set.mapperToggle) document.getElementById('mapperToggle').checked = set.mapperToggle;
        if(set.adaptiveConfidence !== undefined) document.getElementById('adaptiveConfidence').checked = set.adaptiveConfidence;
        if(set.virtualTradeToggle) {
          document.getElementById('virtualTradeToggle').checked = set.virtualTradeToggle;
          if(set.virtualTradeToggle) {
            document.getElementById('virtualModeBadge').classList.add('active');
          }
        }
        
        if(set.analyzer) App.modules.Analyzer.setData(set.analyzer);
        if(set.market) {
          Config.currentMarketValue = set.market;
          selectMarket(set.market);
        }
        
        if(set.selectedAIModel) {
          setTimeout(() => {
            const modelRadio = document.querySelector(`input[name="aiModel"][value="${set.selectedAIModel}"]`);
            if (modelRadio) {
              modelRadio.click();
            }
          }, 100);
        }
        
        if(set.selectedContractType) {
          setTimeout(() => {
            selectContractType(set.selectedContractType);
          }, 100);
        }
      }
      
      const h = localStorage.getItem('trade_history_dm_pro');
      if(h) document.getElementById('history').innerHTML = h;
    }
    
    function selectMarket(m) {
      Config.currentMarketValue = m;
      document.querySelectorAll('.radio-option').forEach(el => {
        el.classList.toggle('selected', el.dataset.market === m);
      });
      const radioEl = document.getElementById('market'+m.replace('_',''));
      if(radioEl) radioEl.checked = true;
      
      if (App.modules.Connection.isConnected()) {
        App.modules.Connection.subscribeToTicks();
      }
      saveSettings();
    }
    
    return {
      init,
      addLog,
      updateStatus,
      updateBalance,
      updateStats,
      startSessionTimer,
      addToHistory,
      updatePredictionDisplay,
      saveSettings,
      loadSettings,
      selectMarket
    };
  })();

  // ============ INITIALIZE APP ============
  window.addEventListener('DOMContentLoaded', () => {
    App.init();
  });

})();
</script>
</body>
</html>