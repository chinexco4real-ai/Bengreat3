<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ben Sniper - Deriv Trading Bot (FIXED - Settlement Tracking)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 10px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: linear-gradient(135deg, #1e2749 0%, #2d3561 100%);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .connection-badge {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            border: 2px solid;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            transition: all 0.3s ease;
        }

        .connection-badge.connected {
            border-color: #2ecc71;
            color: #2ecc71;
        }

        .connection-badge.disconnected {
            border-color: #ff4757;
            color: #ff4757;
        }

        .connection-badge.reconnecting {
            border-color: #f39c12;
            color: #f39c12;
        }

        .connection-badge-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: badge-pulse 2s infinite;
        }

        .connection-badge.connected .connection-badge-dot {
            background-color: #2ecc71;
        }

        .connection-badge.disconnected .connection-badge-dot {
            background-color: #ff4757;
        }

        .connection-badge.reconnecting .connection-badge-dot {
            background-color: #f39c12;
        }

        @keyframes badge-pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.6;
                transform: scale(1.2);
            }
        }

        .header h1 {
            color: #00d4ff;
            font-size: 28px;
            margin-bottom: 15px;
            text-align: center;
            padding-right: 150px;
        }

        .login-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        .login-input-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .login-input {
            flex: 1;
            min-width: 200px;
            padding: 12px;
            background: #2a3250;
            border: 2px solid #3d4663;
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .login-input:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            color: #0a0e27;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff4757 0%, #cc3544 100%);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 71, 87, 0.4);
        }

        .btn-danger.confirm-state {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            animation: pulse-warning 1s infinite;
        }

        @keyframes pulse-warning {
            0%, 100% {
                box-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
            }
            50% {
                box-shadow: 0 0 20px rgba(231, 76, 60, 0.8);
            }
        }

        .btn-success {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.4);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            color: white;
        }

        .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.4);
        }

        .btn-info {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .btn-info:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .account-info {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 10px;
            padding: 15px;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 5px;
            margin-top: 10px;
        }

        .info-item {
            text-align: center;
        }

        .info-label {
            font-size: 11px;
            color: #8899aa;
            text-transform: uppercase;
        }

        .info-value {
            font-size: 16px;
            font-weight: 700;
            color: #00d4ff;
            margin-top: 5px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: #1e2749;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .panel-title {
            color: #00d4ff;
            font-size: 18px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3d4663;
        }

        .markets-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .market-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #2a3250;
            border-radius: 5px;
            border: 1px solid #3d4663;
            position: relative;
        }

        .market-name {
            font-size: 13px;
            color: #e0e0e0;
            flex: 1;
        }

        .market-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .subscription-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #3d4663;
            transition: all 0.3s ease;
        }

        .subscription-indicator.subscribing {
            background-color: #f1c40f;
            box-shadow: 0 0 10px rgba(241, 196, 15, 0.6);
            animation: pulse-yellow 1s infinite;
        }

        .subscription-indicator.subscribed {
            background-color: #2ecc71;
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.6);
            animation: glow 2s infinite;
        }

        @keyframes pulse-yellow {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.6;
                transform: scale(1.2);
            }
        }

        @keyframes glow {
            0%, 100% {
                box-shadow: 0 0 5px rgba(46, 204, 113, 0.6);
            }
            50% {
                box-shadow: 0 0 15px rgba(46, 204, 113, 0.9);
            }
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #3d4663;
            transition: 0.3s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #00d4ff;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .filter-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 15px;
        }

        .filter-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #2a3250;
            border-radius: 5px;
            border: 1px solid #3d4663;
        }

        .filter-label {
            font-size: 14px;
            color: #e0e0e0;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-label {
            font-size: 12px;
            color: #8899aa;
            text-transform: uppercase;
        }

        .input-field {
            padding: 10px;
            background: #2a3250;
            border: 2px solid #3d4663;
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .input-field:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .select-field {
            padding: 10px;
            background: #2a3250;
            border: 2px solid #3d4663;
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 14px;
            cursor: pointer;
        }

        .select-field:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .radio-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 8px 12px;
            background: #2a3250;
            border: 2px solid #3d4663;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .radio-option:hover {
            border-color: #00d4ff;
            background: #323d5a;
        }

        .radio-option input[type="radio"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #00d4ff;
        }

        .radio-option label {
            font-size: 13px;
            color: #e0e0e0;
            cursor: pointer;
            user-select: none;
        }

        .radio-option input[type="radio"]:checked + label {
            color: #00d4ff;
            font-weight: 600;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .control-buttons .btn {
            flex: 1;
            min-width: 120px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-card {
            background: #2a3250;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            border: 1px solid #3d4663;
        }

        .stat-label {
            font-size: 11px;
            color: #8899aa;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #00d4ff;
        }

        .stat-value.profit {
            color: #2ecc71;
        }

        .stat-value.loss {
            color: #ff4757;
        }

        .signal-monitor {
            background: #1e2749;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
        }

        .monitor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 15px;
            background: #2a3250;
            border-radius: 20px;
        }

        .pulse-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #ff4757;
            animation: pulse 2s infinite;
        }

        .pulse-dot.active {
            background-color: #2ecc71;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.5;
                transform: scale(1.1);
            }
        }

        .status-text {
            font-size: 13px;
            color: #ff4757;
            font-weight: 600;
        }

        .status-text.active {
            color: #2ecc71;
        }

        .signals-container {
            max-height: 300px;
            overflow-y: auto;
            background: #0a0e27;
            padding: 15px;
            border-radius: 5px;
        }

        .signals-container::-webkit-scrollbar {
            width: 8px;
        }

        .signals-container::-webkit-scrollbar-track {
            background: #1e2749;
            border-radius: 10px;
        }

        .signals-container::-webkit-scrollbar-thumb {
            background: #00d4ff;
            border-radius: 10px;
        }

        .signal-item {
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 5px;
            border-left: 4px solid #3d4663;
            background: #1e2749;
            transition: all 0.3s ease;
        }

        .signal-item.win {
            border-left-color: #2ecc71;
            background: rgba(46, 204, 113, 0.1);
        }

        .signal-item.loss {
            border-left-color: #ff4757;
            background: rgba(255, 71, 87, 0.1);
        }

        .signal-item.skipped {
            border-left-color: #f39c12;
            background: rgba(243, 156, 18, 0.1);
        }

        .signal-text {
            font-size: 13px;
            color: #e0e0e0;
        }

        .trade-history {
            background: #1e2749;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
        }

        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .history-table {
            width: 100%;
            border-collapse: collapse;
            background: #0a0e27;
            border-radius: 5px;
            overflow: hidden;
        }

        .history-table thead {
            background: #2a3250;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .history-table th {
            padding: 12px;
            text-align: left;
            font-size: 12px;
            color: #8899aa;
            text-transform: uppercase;
            font-weight: 600;
        }

        .history-table td {
            padding: 12px;
            border-top: 1px solid #1e2749;
            font-size: 13px;
            color: #e0e0e0;
        }

        .history-table-container {
            max-height: 500px;
            overflow-y: auto;
            overflow-x: auto;
            border-radius: 5px;
        }

        .history-table-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .history-table-container::-webkit-scrollbar-track {
            background: #1e2749;
            border-radius: 10px;
        }

        .history-table-container::-webkit-scrollbar-thumb {
            background: #00d4ff;
            border-radius: 10px;
        }

        .history-table-container::-webkit-scrollbar-thumb:hover {
            background: #0099cc;
        }

        .result-win {
            color: #2ecc71;
            font-weight: 600;
        }

        .result-loss {
            color: #ff4757;
            font-weight: 600;
        }

        .activities-log {
            background: #1e2749;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .log-container {
            max-height: 300px;
            overflow-y: auto;
            background: #0a0e27;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }

        .log-container::-webkit-scrollbar {
            width: 8px;
        }

        .log-container::-webkit-scrollbar-track {
            background: #1e2749;
            border-radius: 10px;
        }

        .log-container::-webkit-scrollbar-thumb {
            background: #00d4ff;
            border-radius: 10px;
        }

        .log-entry {
            font-size: 12px;
            color: #8899aa;
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .log-entry .timestamp {
            color: #00d4ff;
            margin-right: 10px;
        }

        .log-entry.error {
            color: #ff4757;
        }

        .log-entry.success {
            color: #2ecc71;
        }

        .log-entry.warning {
            color: #f39c12;
        }

        .reverse-mode-badge {
            display: inline-block;
            padding: 4px 10px;
            background: rgba(243, 156, 18, 0.2);
            border: 1px solid #f39c12;
            border-radius: 4px;
            color: #f39c12;
            font-size: 11px;
            font-weight: 600;
            margin-left: 10px;
        }

        .one-candle-badge {
            display: inline-block;
            padding: 4px 10px;
            background: rgba(155, 89, 182, 0.2);
            border: 1px solid #9b59b6;
            border-radius: 4px;
            color: #9b59b6;
            font-size: 11px;
            font-weight: 600;
            margin-left: 10px;
        }

        .alternator-mode-badge {
            display: inline-block;
            padding: 4px 10px;
            background: rgba(52, 152, 219, 0.2);
            border: 1px solid #3498db;
            border-radius: 4px;
            color: #3498db;
            font-size: 11px;
            font-weight: 600;
            margin-left: 10px;
        }

        .contract-type-badge {
            display: inline-block;
            padding: 4px 10px;
            background: rgba(46, 204, 113, 0.2);
            border: 1px solid #2ecc71;
            border-radius: 4px;
            color: #2ecc71;
            font-size: 11px;
            font-weight: 600;
            margin-left: 10px;
        }

        .conflict-alert {
            background: rgba(243, 156, 18, 0.15);
            border: 2px solid #f39c12;
            border-radius: 5px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }

        .conflict-alert.active {
            display: block;
            animation: conflict-pulse 2s infinite;
        }

        @keyframes conflict-pulse {
            0%, 100% {
                background: rgba(243, 156, 18, 0.15);
            }
            50% {
                background: rgba(243, 156, 18, 0.25);
            }
        }

        .conflict-title {
            color: #f39c12;
            font-weight: 700;
            font-size: 14px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .conflict-list {
            color: #e0e0e0;
            font-size: 12px;
            line-height: 1.6;
            margin-left: 24px;
        }

        .barrier-calculation-monitor {
            background: rgba(155, 89, 182, 0.15);
            border: 2px solid #9b59b6;
            border-radius: 5px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }

        .barrier-calculation-monitor.active {
            display: block;
            animation: barrier-pulse 2s infinite;
        }

        @keyframes barrier-pulse {
            0%, 100% {
                background: rgba(155, 89, 182, 0.15);
                border-color: #9b59b6;
            }
            50% {
                background: rgba(155, 89, 182, 0.25);
                border-color: #c39bd3;
            }
        }

        .barrier-monitor-header {
            color: #9b59b6;
            font-weight: 700;
            font-size: 14px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .barrier-spinner {
            width: 16px;
            height: 16px;
            border: 3px solid rgba(155, 89, 182, 0.3);
            border-top-color: #9b59b6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .barrier-progress {
            color: #e0e0e0;
            font-size: 13px;
            margin-bottom: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        .barrier-market-list {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .barrier-market-item {
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
            margin-bottom: 5px;
            font-size: 12px;
            color: #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .barrier-market-item.completed {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }

        .barrier-market-item.failed {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 22px;
                padding-right: 0;
                margin-top: 40px;
            }

            .connection-badge {
                top: 10px;
                right: 10px;
                font-size: 10px;
                padding: 6px 12px;
            }

            .markets-grid {
                grid-template-columns: 1fr;
            }

            .settings-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .control-buttons {
                flex-direction: column;
            }

            .control-buttons .btn {
                width: 100%;
            }

            .history-table {
                font-size: 11px;
            }

            .history-table th,
            .history-table td {
                padding: 8px 5px;
            }

            .radio-group {
                flex-direction: column;
                gap: 10px;
            }

            .radio-option {
                width: 100%;
            }
        }

        .timer-display {
            text-align: center;
            padding: 10px;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 5px;
            margin-top: 10px;
        }

        .timer-label {
            font-size: 11px;
            color: #8899aa;
            text-transform: uppercase;
        }

        .timer-value {
            font-size: 20px;
            font-weight: 700;
            color: #00d4ff;
            margin-top: 5px;
            font-family: 'Courier New', monospace;
        }

        .hidden {
            display: none;
        }

        .candle-counter {
            font-size: 13px;
            color: #f1c40f;
            font-weight: 600;
            margin-top: 10px;
            text-align: center;
            padding: 8px;
            background: rgba(241, 196, 15, 0.1);
            border-radius: 5px;
        }

        .trade-count-display {
            text-align: center;
            font-size: 12px;
            color: #8899aa;
            margin-top: 10px;
            padding: 8px;
            background: rgba(0, 212, 255, 0.05);
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <!-- Connection Badge -->
            <div class="connection-badge disconnected" id="connectionBadge">
                <div class="connection-badge-dot"></div>
                <span id="connectionStatus">Disconnected</span>
            </div>

            <h1>‚ö° BEN SNIPER - Deriv Trading Bot</h1>
            
            <div class="login-section" id="loginSection">
                <div class="login-input-group">
                    <input type="password" class="login-input" id="apiToken" placeholder="Enter Deriv API Token">
                    <button class="btn btn-primary" id="loginBtn">Login</button>
                </div>
            </div>

            <div class="account-info hidden" id="accountInfo">
                <div class="info-item">
                    <div class="info-label">Account Type</div>
                    <div class="info-value" id="accountType">-</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Currency</div>
                    <div class="info-value" id="accountCurrency">-</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Balance</div>
                    <div class="info-value" id="accountBalance">-</div>
                </div>
                <div class="info-item">
                    <button class="btn btn-danger" id="logoutBtn">Logout</button>
                </div>
            </div>

            <div class="timer-display hidden" id="timerDisplay">
                <div class="timer-label">Session Time</div>
                <div class="timer-value" id="timerValue">00:00:00</div>
            </div>
        </div>

        <div class="signal-monitor">
            <div class="monitor-header">
                <h2 class="panel-title">üìä Signal Monitor<span id="reverseModeIndicator" class="reverse-mode-badge hidden">REVERSE MODE</span><span id="oneCandleIndicator" class="one-candle-badge hidden">ONE CANDLE</span><span id="alternatorModeIndicator" class="alternator-mode-badge hidden">ALTERNATOR</span><span id="contractTypeIndicator" class="contract-type-badge hidden">RISE/FALL</span></h2>
                <div class="status-indicator">
                    <div class="pulse-dot" id="statusDot"></div>
                    <span class="status-text" id="statusText">Bot Inactive</span>
                </div>
            </div>
            <div id="candleCounter" class="candle-counter hidden">Building candles: 0 / 0 required</div>
            
            <!-- Barrier Calculation Monitor -->
            <div class="barrier-calculation-monitor" id="barrierMonitor">
                <div class="barrier-monitor-header">
                    <div class="barrier-spinner"></div>
                    Calculating Barriers for Higher/Lower Contracts
                </div>
                <div class="barrier-progress" id="barrierProgress">
                    Initializing barrier calculations...
                </div>
                <div class="barrier-market-list" id="barrierMarketList"></div>
            </div>
            
            <div class="signals-container" id="signalsContainer">
                <div class="signal-item">
                    <div class="signal-text">Waiting for bot activation...</div>
                </div>
            </div>
        </div>

        <div class="main-grid">
            <div class="panel">
                <h2 class="panel-title">üéØ Market Selection</h2>
                <div class="markets-grid" id="marketsGrid"></div>
            </div>

            <div class="panel">
                <h2 class="panel-title">üîß Filters</h2>
                <div class="filter-section">
                    <div class="filter-item">
                        <span class="filter-label">Zero Closing Filter(Perfect 0)</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="zeroClosingFilter">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <span class="filter-label">Ignore Height</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="ignoreHeightFilter">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <span class="filter-label">One Candle (Single Candle Analysis)</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="oneCandleFilter">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <span class="filter-label">Reverse Candle</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="reverseCandleFilter">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <span class="filter-label">Parabolic SAR Filter</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="parabolicSarFilter">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>

                <!-- Conflict Alert Box -->
                <div class="conflict-alert" id="conflictAlert">
                    <div class="conflict-title">
                        ‚ö†Ô∏è Filter Conflict Detected
                    </div>
                    <div class="conflict-list" id="conflictList"></div>
                </div>

                <h2 class="panel-title" style="margin-top: 20px;">‚öôÔ∏è Trade Settings</h2>
                <div class="settings-grid">
                    <div class="input-group">
                        <label class="input-label">Contract Type</label>
                        <div class="radio-group">
                            <div class="radio-option">
                                <input type="radio" id="contractTypeRiseFall" name="contractType" value="RISE_FALL" checked>
                                <label for="contractTypeRiseFall">Rise/Fall</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="contractTypeHigherLower" name="contractType" value="HIGHER_LOWER">
                                <label for="contractTypeHigherLower">Higher/Lower</label>
                            </div>
                        </div>
                    </div>
                    <div class="input-group" id="hlDirectionGroup" style="display: none;">
                        <label class="input-label">Higher/Lower Direction</label>
                        <div class="radio-group">
                            <div class="radio-option">
                                <input type="radio" id="hlDirectionBoth" name="hlDirection" value="BOTH" checked>
                                <label for="hlDirectionBoth">Both</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="hlDirectionHigher" name="hlDirection" value="HIGHER_ONLY">
                                <label for="hlDirectionHigher">Higher</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="hlDirectionLower" name="hlDirection" value="LOWER_ONLY">
                                <label for="hlDirectionLower">Lower</label>
                            </div>
                        </div>
                    </div>
                    <div class="input-group">
                        <label class="input-label">Stake Amount</label>
                        <input type="number" class="input-field" id="stakeAmount" value="1" min="0.35" step="0.01">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Stop Loss</label>
                        <input type="number" class="input-field" id="stopLoss" value="10" min="0" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Take Profit</label>
                        <input type="number" class="input-field" id="takeProfit" value="20" min="0" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Duration Type</label>
                        <div class="radio-group">
                            <div class="radio-option">
                                <input type="radio" id="durationTypeTicks" name="durationType" value="t" checked>
                                <label for="durationTypeTicks">Ticks</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="durationTypeSeconds" name="durationType" value="s">
                                <label for="durationTypeSeconds">Seconds</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="durationTypeMinutes" name="durationType" value="m">
                                <label for="durationTypeMinutes">Minutes</label>
                            </div>
                        </div>
                    </div>
                    <div class="input-group">
                        <label class="input-label">Duration Value</label>
                        <input type="number" class="input-field" id="durationValue" value="5" min="1" step="1">
                    </div>
                    <div class="input-group" id="payoutPercentageGroup" style="display: none;">
                        <label class="input-label">Payout % (Profit %)</label>
                        <input type="number" class="input-field" id="payoutPercentage" value="95" min="1" max="99" step="0.1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Min Lower Wick % (Buy)</label>
                        <input type="number" class="input-field" id="minLowerWickBuy" value="50" min="0" max="100" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Min Upper Wick % (Sell)</label>
                        <input type="number" class="input-field" id="minUpperWickSell" value="50" min="0" max="100" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Min Upper Wick % (Buy)</label>
                        <input type="number" class="input-field" id="minUpperWickBuy" value="20" min="0" max="100" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Min Lower Wick % (Sell)</label>
                        <input type="number" class="input-field" id="minLowerWickSell" value="20" min="0" max="100" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Matching Diff % (Buy)</label>
                        <input type="number" class="input-field" id="matchingDiffBuy" value="0.3" min="0" max="5" step="0.1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Matching Diff % (Sell)</label>
                        <input type="number" class="input-field" id="matchingDiffSell" value="0.3" min="0" max="5" step="0.1">
                    </div>
                </div>

                <div class="control-buttons">
                    <button class="btn btn-success" id="autoTradeBtn" disabled>Start Auto Trade</button>
                    <button class="btn btn-warning" id="reverseModeBtn" disabled>Reverse Mode: OFF</button>
                    <button class="btn btn-info" id="alternatorModeBtn" disabled>Alternator: OFF</button>
                </div>
            </div>
        </div>

        <div class="panel">
            <h2 class="panel-title">üìà Trading Statistics</h2>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Total Trades</div>
                    <div class="stat-value" id="totalTrades">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Wins</div>
                    <div class="stat-value profit" id="totalWins">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Losses</div>
                    <div class="stat-value loss" id="totalLosses">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Skipped</div>
                    <div class="stat-value" id="totalSkipped">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">P/L</div>
                    <div class="stat-value" id="profitLoss">0.00</div>
                </div>
            </div>
        </div>

        <div class="trade-history">
            <div class="history-header">
                <h2 class="panel-title">üìã Trade History</h2>
                <button class="btn btn-danger" id="clearHistoryBtn">Clear History</button>
            </div>
            <div class="trade-count-display" id="tradeCountDisplay">Showing 0 of 0 trades</div>
            <div class="history-table-container">
                <table class="history-table">
                    <thead>
                        <tr>
                            <th>S/N</th>
                            <th>Time</th>
                            <th>Market</th>
                            <th>Type</th>
                            <th>Stake</th>
                            <th>Result</th>
                        </tr>
                    </thead>
                    <tbody id="historyTableBody">
                        <tr>
                            <td colspan="6" style="text-align: center; color: #8899aa;">No trades yet</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="activities-log">
            <h2 class="panel-title">üìù Activity Log</h2>
            <div class="log-container" id="logContainer">
                <div class="log-entry">
                    <span class="timestamp">[--:--:--]</span> System initialized. Waiting for login...
                </div>
            </div>
        </div>
    </div>

    <script>
        /*
         * BEN SNIPER BOT - FIXED VERSION WITH SETTLEMENT TRACKING
         * 
         * =================================================================
         * CRITICAL FIXES IMPLEMENTED TO RESOLVE UNSETTLED CONTRACTS:
         * =================================================================
         * 
         * ‚úÖ FIX #1: Increased Proposal Timeout (Line ~3609)
         *    - Changed from 5 seconds to 15 seconds
         *    - Prevents premature timeout on slow connections
         *    - Reduces race conditions during trade execution
         * 
         * ‚úÖ FIX #2: Enhanced Buy Error Handling (Line ~2515)
         *    - Added proper error parsing for buy requests
         *    - Logs specific error messages with market context
         *    - Updates skipped stats when buy fails
         * 
         * ‚úÖ FIX #3: Contract Recovery System (New)
         *    - Periodic checking of open contracts (every 30s)
         *    - Automatic re-query for contracts older than 2 minutes
         *    - Rate-limited to prevent API overload
         * 
         * ‚úÖ FIX #4: Re-subscription After Reconnection (Line ~2448)
         *    - Saves open contracts to sessionStorage before disconnect
         *    - Restores open contract tracking after successful reconnect
         *    - Automatically re-subscribes to all pending contracts
         * 
         * ‚úÖ FIX #5: Proper Cleanup on Trade Errors (Line ~2515)
         *    - Removes failed trades from pendingTrades map
         *    - Prevents memory leaks from accumulating failed trades
         *    - Marks failed trades as "skipped" in statistics
         * 
         * ‚úÖ FIX #6: Open Contracts Tracking (New Variables)
         *    - New Map: openContracts (contract_id -> info)
         *    - Tracks: symbol, type, stake, timestamp for each contract
         *    - Automatically removed when contract settles
         * 
         * ‚úÖ FIX #7: Periodic Contract Status Checking (New Function)
         *    - checkMissedContracts() runs every 30 seconds
         *    - Identifies contracts pending longer than 2 minutes
         *    - Sends status queries to recover missed settlements
         * 
         * ‚úÖ FIX #8: Enhanced Subscription Error Handling (Line ~2626)
         *    - Wraps subscription request in try-catch block
         *    - Implements automatic retry after 2 seconds on failure
         *    - Logs all subscription failures for debugging
         * 
         * ‚úÖ FIX #9: Better WebSocket Disconnection Handling (Line ~2448)
         *    - Preserves contract state across disconnections
         *    - Exponential backoff for reconnection attempts
         *    - Clear logging of reconnection progress
         * 
         * ‚úÖ FIX #10: Contract ID Validation (Line ~2670)
         *    - Validates contract structure before processing
         *    - Prevents crashes from malformed data
         *    - Updates tracking for pending contracts
         * 
         * =================================================================
         * ALL ORIGINAL FEATURES PRESERVED:
         * =================================================================
         * ‚úÖ One Candle & Two Candle modes
         * ‚úÖ Zero Closing, Ignore Height, Reverse Candle filters
         * ‚úÖ Parabolic SAR filter
         * ‚úÖ Reverse Mode & Alternator Mode
         * ‚úÖ Rise/Fall & Higher/Lower contracts
         * ‚úÖ Smart decimal detection for barriers
         * ‚úÖ Stop Loss & Take Profit
         * ‚úÖ Session timer & statistics tracking
         * ‚úÖ Trade history with export capability
         * ‚úÖ Auto-reconnection with exponential backoff
         * ‚úÖ Market-specific barrier calculation
         * ‚úÖ Duplicate trade prevention
         * ‚úÖ Browser visibility handling
         * 
         * =================================================================
         * TESTING RECOMMENDATIONS:
         * =================================================================
         * 1. Test with real Demo account first
         * 2. Monitor "Activity Log" for settlement messages
         * 3. Check that all contracts show "TRADE SETTLED" message
         * 4. Verify contract recovery after intentional disconnect
         * 5. Confirm statistics match actual settled contracts
         * 
         * =================================================================
         */

        // Market definitions
        const markets = {
            '1HZ10V': 'Volatility 10 (1s)',
            '1HZ25V': 'Volatility 25 (1s)',
            '1HZ50V': 'Volatility 50 (1s)',
            '1HZ75V': 'Volatility 75 (1s)',
            '1HZ100V': 'Volatility 100 (1s)',
            'R_10': 'Volatility 10',
            'R_25': 'Volatility 25',
            'R_50': 'Volatility 50',
            'R_75': 'Volatility 75',
            'R_100': 'Volatility 100',
            'stpRNG': 'Step Index 100',
            'stpRNG2': 'Step Index 200',
            'stpRNG3': 'Step Index 300',
            'stpRNG4': 'Step Index 400',
            'stpRNG5': 'Step Index 500'
        };

        // Global state
        let ws = null;
        let isLoggedIn = false;
        let isAutoTrading = false;
        let isReverseMode = false;
        let isAlternatorMode = false;
        let activation_time = 0;
        let activeMarkets = {};
        let marketSubscriptions = {};
        let pendingSubscriptions = {};
        let candleData = {};
        let currentOHLC = {};
        let currentMinute = {};
        let tradeHistory = [];
        let sessionTimer = null;
        let sessionStartTime = null;
        let accountInfo = {};
        let tradeStats = {
            total: 0,
            wins: 0,
            losses: 0,
            skipped: 0,
            profitLoss: 0
        };
        let pendingTrades = new Map();
        let isFirstSignal = true;
        let lastHeartbeat = Date.now();
        let tradedCandles = {};
        let requestIdCounter = 0;
        let pendingProposals = new Map();
        let processedContracts = new Set();
        
        // SMART AUTO-DETECTION: Stores the correct decimal places for each market
        let symbolPips = {};
        
        // ALTERNATOR MODE: Track next trade type for each market separately
        let marketAlternatorState = {};
        
        // Parabolic SAR tracking
        let parabolicSarCache = {};
        
        // Time synchronization variables
        let serverTimeOffset = 0;
        let isTimeSynced = false;
        let candleWatchdogTimer = null;
        
        // Browser visibility tracking
        let isPageVisible = true;
        let lastVisibilityChange = Date.now();
        
        // Candle processing throttle - FLOATING BROWSER FIX
        let lastCandleProcessTime = {};
        let isProcessingTicks = false;

        // Auto-reconnect variables
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 10;
        let reconnectTimeout = null;
        let wasAutoTradingBeforeDisconnect = false;

        // Clear history double-tap state
        let clearHistoryConfirmState = false;
        let clearHistoryTimeout = null;

        // Higher/Lower contract variables
        let barrierCalculationQueue = [];
        let isCalculatingBarriers = false;
        let calculatedBarriers = {};
        let currentSpot = {};
        let barrierMarketStatus = {};

        // ‚úÖ FIX #6: Open contracts tracking for recovery
        let openContracts = new Map(); // contract_id -> {symbol, type, stake, timestamp}
        let contractRecoveryTimer = null;
        let lastContractCheckTime = 0;

        // Initialize markets and alternator state
        Object.keys(markets).forEach(symbol => {
            activeMarkets[symbol] = true;
            candleData[symbol] = [];
            currentOHLC[symbol] = undefined;
            currentMinute[symbol] = undefined;
            tradedCandles[symbol] = new Set();
            marketAlternatorState[symbol] = 'CALL';
            currentSpot[symbol] = null;
        });

        // SMART FUNCTION: Detects allowed decimals for any market
        function getSmartDecimals(symbol) {
            // 1. If we have exact data from API, use it
            if (symbolPips[symbol]) {
                return symbolPips[symbol];
            }
            
            // 2. Smart Fallback if API data isn't ready yet
            // Volatility 100 (1s and Normal) usually enforce 2 decimals
            if (symbol.includes('100') || symbol.includes('V100')) {
                return 2;
            }
            
            // 3. Default for most other markets is 3 or 4
            return 3;
        }

        // Get supported symbols for Higher/Lower (excludes Step Index)
        function getSupportedSymbolsForHL() {
            return Object.keys(markets).filter(symbol => {
                return !symbol.startsWith('stpRNG');
            });
        }

        // Helper function to get contract type value
        function getContractType() {
            const radios = document.getElementsByName('contractType');
            for (let radio of radios) {
                if (radio.checked) {
                    return radio.value;
                }
            }
            return 'RISE_FALL';
        }

        // Helper function to set contract type
        function setContractType(value) {
            const radios = document.getElementsByName('contractType');
            for (let radio of radios) {
                radio.checked = (radio.value === value);
            }
        }

        // Helper function to get HL direction
        function getHLDirection() {
            const radios = document.getElementsByName('hlDirection');
            for (let radio of radios) {
                if (radio.checked) {
                    return radio.value;
                }
            }
            return 'BOTH';
        }

        // Helper function to set HL direction
        function setHLDirection(value) {
            const radios = document.getElementsByName('hlDirection');
            for (let radio of radios) {
                radio.checked = (radio.value === value);
            }
        }

        // Update connection badge
        function updateConnectionBadge(status) {
            const badge = document.getElementById('connectionBadge');
            const statusText = document.getElementById('connectionStatus');
            
            badge.className = 'connection-badge ' + status;
            
            if (status === 'connected') {
                statusText.textContent = 'Connected';
            } else if (status === 'disconnected') {
                statusText.textContent = 'Disconnected';
            } else if (status === 'reconnecting') {
                statusText.textContent = 'Reconnecting...';
            }
        }

        // Update subscription indicator for a specific market
        function updateSubscriptionIndicator(symbol, state) {
            const indicator = document.querySelector(`[data-indicator="${symbol}"]`);
            if (indicator) {
                indicator.className = 'subscription-indicator';
                if (state === 'subscribing') {
                    indicator.classList.add('subscribing');
                } else if (state === 'subscribed') {
                    indicator.classList.add('subscribed');
                }
            }
        }

        // Update contract type indicator
        function updateContractTypeIndicator() {
            const indicator = document.getElementById('contractTypeIndicator');
            const contractType = getContractType();
            const hlDirection = getHLDirection();
            
            indicator.classList.remove('hidden');
            
            if (contractType === 'RISE_FALL') {
                indicator.textContent = 'RISE/FALL';
                indicator.style.borderColor = '#2ecc71';
                indicator.style.color = '#2ecc71';
                indicator.style.background = 'rgba(46, 204, 113, 0.2)';
            } else {
                let text = 'HIGHER/LOWER';
                if (hlDirection === 'HIGHER_ONLY') {
                    text = 'HIGHER ONLY';
                } else if (hlDirection === 'LOWER_ONLY') {
                    text = 'LOWER ONLY';
                } else {
                    text = 'HIGHER & LOWER';
                }
                indicator.textContent = text;
                indicator.style.borderColor = '#e74c3c';
                indicator.style.color = '#e74c3c';
                indicator.style.background = 'rgba(231, 76, 60, 0.2)';
            }
        }

        // Update reverse mode indicator
        function updateReverseModeIndicator() {
            const indicator = document.getElementById('reverseModeIndicator');
            if (isReverseMode) {
                indicator.classList.remove('hidden');
            } else {
                indicator.classList.add('hidden');
            }
        }

        // Update alternator mode indicator
        function updateAlternatorModeIndicator() {
            const indicator = document.getElementById('alternatorModeIndicator');
            if (isAlternatorMode) {
                indicator.classList.remove('hidden');
            } else {
                indicator.classList.add('hidden');
            }
        }

        // Update one candle mode indicator
        function updateOneCandleIndicator() {
            const indicator = document.getElementById('oneCandleIndicator');
            const oneCandleEnabled = document.getElementById('oneCandleFilter').checked;
            if (oneCandleEnabled) {
                indicator.classList.remove('hidden');
            } else {
                indicator.classList.add('hidden');
            }
        }

        // Show/hide Higher/Lower specific fields
        function updateContractTypeFields() {
            const contractType = getContractType();
            const hlDirectionGroup = document.getElementById('hlDirectionGroup');
            const payoutPercentageGroup = document.getElementById('payoutPercentageGroup');
            
            if (contractType === 'HIGHER_LOWER') {
                hlDirectionGroup.style.display = 'block';
                payoutPercentageGroup.style.display = 'block';
            } else {
                hlDirectionGroup.style.display = 'none';
                payoutPercentageGroup.style.display = 'none';
            }
            
            updateContractTypeIndicator();
        }

        // Show barrier calculation monitor
        function showBarrierMonitor() {
            document.getElementById('barrierMonitor').classList.add('active');
        }

        // Hide barrier calculation monitor
        function hideBarrierMonitor() {
            document.getElementById('barrierMonitor').classList.remove('active');
        }

        // Update barrier progress
        function updateBarrierProgress(message) {
            document.getElementById('barrierProgress').textContent = message;
        }

        // Add market to barrier monitor
        function addBarrierMarketStatus(symbol, status = 'pending') {
            const listContainer = document.getElementById('barrierMarketList');
            const marketId = `barrier-market-${symbol}`;
            
            let marketItem = document.getElementById(marketId);
            if (!marketItem) {
                marketItem = document.createElement('div');
                marketItem.id = marketId;
                marketItem.className = 'barrier-market-item';
                listContainer.appendChild(marketItem);
            }
            
            if (status === 'pending') {
                marketItem.className = 'barrier-market-item';
                marketItem.textContent = `${markets[symbol]} - Calculating...`;
            } else if (status === 'completed') {
                marketItem.className = 'barrier-market-item completed';
                marketItem.textContent = `${markets[symbol]} - ‚úì Complete`;
            } else if (status === 'failed') {
                marketItem.className = 'barrier-market-item failed';
                marketItem.textContent = `${markets[symbol]} - ‚úó Failed`;
            }
        }

        // Clear barrier monitor list
        function clearBarrierMonitorList() {
            document.getElementById('barrierMarketList').innerHTML = '';
            barrierMarketStatus = {};
        }

        // UPDATED: Calculate barrier with Smart Decimals & Correct Payout Logic
        async function calculateBarrierForPayout(symbol, contractType, payout, duration, durationType, currentPrice) {
            return new Promise((resolve, reject) => {
                const reqId = ++requestIdCounter;
                
                // 1. FIX: Convert User's Profit % (e.g. 95) to Total Payout % (195)
                const targetTotalPayout = parseFloat(payout) + 100;
                
                // 2. Validate duration
                const supportedDurations = {
                    't': { min: 5, max: 10 },
                    's': { min: 15, max: 3600 },
                    'm': { min: 1, max: 60 }
                };
                
                const durationLimits = supportedDurations[durationType];
                if (!durationLimits || duration < durationLimits.min || duration > durationLimits.max) {
                    reject(new Error(`Duration not supported. Min: ${durationLimits?.min}${durationType}, Max: ${durationLimits?.max}${durationType}`));
                    return;
                }
                
                // 3. Search Range
                let minBarrier = -10.0;
                let maxBarrier = 10.0;
                let bestBarrier = null;
                let attempts = 0;
                const maxAttempts = 20;
                const tolerance = 2.0;

                const tryBarrier = (barrier) => {
                    const testReqId = ++requestIdCounter;
                    
                    // 4. FIX: Handle near-zero values for BOTH Call and Put
                    if (Math.abs(barrier) < 0.001) {
                        // If CALL -> 0.001, If PUT -> -0.001
                        barrier = contractType === 'CALL' ? 0.001 : -0.001;
                    }
                    
                    const testAmount = 1.0;
                    // 5. FIX: Use Smart Decimals
                    const decimals = getSmartDecimals(symbol);
                    
                    const testProposal = {
                        proposal: 1,
                        amount: testAmount,
                        basis: 'stake',
                        contract_type: contractType,
                        currency: accountInfo.currency,
                        duration: duration,
                        duration_unit: durationType,
                        symbol: symbol,
                        // 6. FIX: Format barrier with correct decimals
                        barrier: barrier > 0 ? `+${barrier.toFixed(decimals)}` : `${barrier.toFixed(decimals)}`,
                        req_id: testReqId
                    };

                    const timeout = setTimeout(() => {
                        if (pendingProposals.has(testReqId)) {
                            pendingProposals.delete(testReqId);
                            reject(new Error('Barrier calculation timeout'));
                        }
                    }, 20000);

                    pendingProposals.set(testReqId, {
                        resolve: (data) => {
                            clearTimeout(timeout);
                            if (data.proposal && data.proposal.payout) {
                                const receivedTotalPayout = parseFloat(data.proposal.payout);
                                const currentTotalPct = (receivedTotalPayout / testAmount) * 100;
                                
                                if (Math.abs(currentTotalPct - targetTotalPayout) <= tolerance) {
                                    bestBarrier = barrier;
                                    resolve({ barrier: barrier, payout: currentTotalPct });
                                } else if (attempts < maxAttempts) {
                                    attempts++;
                                    
                                    const needHigherPayout = currentTotalPct < targetTotalPayout;
                                    
                                    if (contractType === 'CALL') {
                                        if (needHigherPayout) minBarrier = barrier; 
                                        else maxBarrier = barrier;
                                    } else {
                                        if (needHigherPayout) maxBarrier = barrier;
                                        else minBarrier = barrier;
                                    }
                                    
                                    const nextBarrier = (minBarrier + maxBarrier) / 2;
                                    tryBarrier(nextBarrier);
                                } else {
                                    resolve({ barrier: barrier, payout: currentTotalPct });
                                }
                            } else if (data.error) {
                                // If barrier is invalid (e.g. too close), adjust search
                                if (data.error.code === 'ContractBuyValidationError') {
                                     // Force move away from 0
                                     if (contractType === 'CALL') minBarrier = barrier;
                                     else maxBarrier = barrier;
                                     const nextBarrier = (minBarrier + maxBarrier) / 2;
                                     tryBarrier(nextBarrier);
                                } else {
                                    reject(new Error(data.error.message));
                                }
                            }
                        },
                        reject: reject,
                        timeout: timeout
                    });

                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify(testProposal));
                    } else {
                        clearTimeout(timeout);
                        reject(new Error('WebSocket not connected'));
                    }
                };

                // Start search slightly In-The-Money to find the 95% profit range quickly
                const initialBarrier = contractType === 'CALL' ? -0.15 : 0.15;
                tryBarrier(initialBarrier);
            });
        }

        // UPDATED: Process barrier calculation queue (Removes local price dependency)
        async function processBarrierCalculationQueue() {
            if (isCalculatingBarriers || barrierCalculationQueue.length === 0) {
                return;
            }

            isCalculatingBarriers = true;
            showBarrierMonitor();
            clearBarrierMonitorList();

            const totalMarkets = barrierCalculationQueue.length;
            let completed = 0;
            let failed = 0;
            updateBarrierProgress(`Starting barrier calculation for ${totalMarkets} contracts...`);

            while (barrierCalculationQueue.length > 0) {
                const { symbol, contractType, resolve, reject } = barrierCalculationQueue.shift();
                
                addBarrierMarketStatus(symbol, 'pending');
                
                try {
                    if (symbol.startsWith('stpRNG')) {
                        throw new Error(`Step Index symbols not supported for Higher/Lower contracts`);
                    }
                    
                    updateBarrierProgress(`Calculating barrier for ${markets[symbol]} ${contractType}... (${completed + failed + 1}/${totalMarkets})`);
                    
                    const payout = parseFloat(document.getElementById('payoutPercentage').value);
                    const duration = parseInt(document.getElementById('durationValue').value);
                    const durationType = getDurationType();
                    
                    // FIX: REMOVED THE "currentSpot" CHECK
                    // We pass 0 as the price because the API doesn't need us to tell it the price.
                    const result = await calculateBarrierForPayout(symbol, contractType, payout, duration, durationType, 0);
                    
                    calculatedBarriers[symbol] = calculatedBarriers[symbol] || {};
                    calculatedBarriers[symbol][contractType] = result.barrier;
                    
                    addBarrierMarketStatus(symbol, 'completed');
                    completed++;
                    
                    logActivity(`‚úÖ Barrier calculated for ${markets[symbol]} ${contractType}: ${result.barrier.toFixed(getSmartDecimals(symbol))} (${(result.payout - 100).toFixed(2)}% profit)`, 'success');
                    resolve(result.barrier);
                    
                    if (barrierCalculationQueue.length > 0) {
                        await new Promise(r => setTimeout(r, 1000));
                    }
                } catch (error) {
                    addBarrierMarketStatus(symbol, 'failed');
                    failed++;
                    
                    logActivity(`‚ùå Failed to calculate barrier for ${markets[symbol]} ${contractType}: ${error.message}`, 'error');
                    
                    resolve(null);
                    
                    if (symbol.startsWith('stpRNG') || error.message.includes('Step Index')) {
                        calculatedBarriers[symbol] = calculatedBarriers[symbol] || {};
                        calculatedBarriers[symbol][contractType] = null;
                        logActivity(`‚ö†Ô∏è ${markets[symbol]} skipped - not supported for Higher/Lower contracts`, 'warning');
                    }
                }
            }

            updateBarrierProgress(`Barrier calculation complete: ${completed} successful, ${failed} failed`);
            isCalculatingBarriers = false;
            
            setTimeout(() => {
                hideBarrierMonitor();
            }, 5000);
            
            logActivity(`Barrier calculation completed: ${completed} successful, ${failed} failed`, completed > 0 ? 'success' : 'warning');
        }

        // Get barrier for symbol and contract type
        async function getBarrierForContract(symbol, contractType) {
            const contractTypeValue = getContractType();
            
            if (contractTypeValue !== 'HIGHER_LOWER') {
                return null;
            }

            if (symbol.startsWith('stpRNG')) {
                logActivity(`‚ö†Ô∏è Cannot use Higher/Lower for ${markets[symbol]} - Step Index not supported`, 'warning');
                return null;
            }

            if (calculatedBarriers[symbol] && calculatedBarriers[symbol][contractType] !== undefined) {
                return calculatedBarriers[symbol][contractType];
            }

            if (calculatedBarriers[symbol] && calculatedBarriers[symbol][contractType] === null) {
                return null;
            }

            return new Promise((resolve, reject) => {
                barrierCalculationQueue.push({ symbol, contractType, resolve, reject });
                processBarrierCalculationQueue();
            });
        }

        // Helper function to queue missing barriers
        function queueMissingBarriers() {
            const supportedSymbols = getSupportedSymbolsForHL();
            const hlDirection = getHLDirection();
            let missingCount = 0;

            for (const symbol of supportedSymbols) {
                if (activeMarkets[symbol]) {
                    if (hlDirection === 'BOTH' || hlDirection === 'HIGHER_ONLY') {
                        // Check if CALL barrier is missing or failed
                        if (!calculatedBarriers[symbol] || calculatedBarriers[symbol]['CALL'] === undefined || calculatedBarriers[symbol]['CALL'] === null) {
                            barrierCalculationQueue.push({
                                symbol: symbol,
                                contractType: 'CALL',
                                resolve: () => {},
                                reject: () => {}
                            });
                            missingCount++;
                        }
                    }
                    
                    if (hlDirection === 'BOTH' || hlDirection === 'LOWER_ONLY') {
                        // Check if PUT barrier is missing or failed
                        if (!calculatedBarriers[symbol] || calculatedBarriers[symbol]['PUT'] === undefined || calculatedBarriers[symbol]['PUT'] === null) {
                            barrierCalculationQueue.push({
                                symbol: symbol,
                                contractType: 'PUT',
                                resolve: () => {},
                                reject: () => {}
                            });
                            missingCount++;
                        }
                    }
                }
            }

            return missingCount;
        }

        // UPDATED: Recalculate all barriers when payout percentage changes - Now returns Promise
        async function recalculateAllBarriers() {
            if (getContractType() !== 'HIGHER_LOWER') {
                return Promise.resolve();
            }

            calculatedBarriers = {};
            barrierCalculationQueue = [];

            const supportedSymbols = getSupportedSymbolsForHL();
            const hlDirection = getHLDirection();

            logActivity(`Calculating barriers for ${supportedSymbols.length} supported symbols (excluding Step Index)...`, 'info');

            for (const symbol of supportedSymbols) {
                if (activeMarkets[symbol]) {
                    if (hlDirection === 'BOTH' || hlDirection === 'HIGHER_ONLY') {
                        barrierCalculationQueue.push({
                            symbol: symbol,
                            contractType: 'CALL',
                            resolve: () => {},
                            reject: () => {}
                        });
                    }
                    
                    if (hlDirection === 'BOTH' || hlDirection === 'LOWER_ONLY') {
                        barrierCalculationQueue.push({
                            symbol: symbol,
                            contractType: 'PUT',
                            resolve: () => {},
                            reject: () => {}
                        });
                    }
                }
            }

            if (barrierCalculationQueue.length > 0) {
                logActivity(`Starting barrier calculation for ${barrierCalculationQueue.length} contracts...`, 'info');
                return processBarrierCalculationQueue();
            } else {
                logActivity('No supported symbols active for Higher/Lower contracts', 'warning');
                return Promise.resolve();
            }
        }

        // Check for filter conflicts
        function checkFilterConflicts() {
            const ignoreHeight = document.getElementById('ignoreHeightFilter').checked;
            const oneCandle = document.getElementById('oneCandleFilter').checked;
            const conflictAlert = document.getElementById('conflictAlert');
            const conflictList = document.getElementById('conflictList');
            
            const conflicts = [];
            
            if (ignoreHeight && oneCandle) {
                conflicts.push('‚Ä¢ "Ignore Height" and "One Candle" are both enabled. These filters work together:<br>&nbsp;&nbsp;- One Candle: Uses only first candle for analysis (no second candle needed)<br>&nbsp;&nbsp;- Ignore Height: Allows the single candle to be any height<br>&nbsp;&nbsp;‚Üí Both filters will be applied for maximum flexibility');
            }

            if (isReverseMode && isAlternatorMode) {
                conflicts.push('‚Ä¢ "Reverse Mode" and "Alternator Mode" are both enabled:<br>&nbsp;&nbsp;- Alternator enforces BUY-SELL-BUY pattern per market<br>&nbsp;&nbsp;- Reverse Mode inverts signals<br>&nbsp;&nbsp;‚Üí Combined effect: Alternator operates on reversed signals');
            }
            
            if (conflicts.length > 0) {
                conflictList.innerHTML = conflicts.join('<br><br>');
                conflictAlert.classList.add('active');
            } else {
                conflictAlert.classList.remove('active');
            }
        }

        // Update candle counter
        function updateCandleCounter() {
            if (!isAutoTrading) {
                document.getElementById('candleCounter').classList.add('hidden');
                return;
            }

            const oneCandleFilter = document.getElementById('oneCandleFilter').checked;
            
            let requiredCandles = oneCandleFilter ? 1 : 3;
            
            let minCandles = Infinity;
            let activeCount = 0;
            
            Object.keys(activeMarkets).forEach(symbol => {
                if (activeMarkets[symbol] && marketSubscriptions[symbol]) {
                    activeCount++;
                    const count = candleData[symbol].length;
                    if (count < minCandles) {
                        minCandles = count;
                    }
                }
            });

            if (activeCount === 0) {
                document.getElementById('candleCounter').classList.add('hidden');
                return;
            }

            if (minCandles === Infinity) minCandles = 0;

            const counterElement = document.getElementById('candleCounter');
            
            if (minCandles >= requiredCandles) {
                const mode = oneCandleFilter ? 'ONE CANDLE MODE' : 'TWO CANDLE MODE';
                counterElement.textContent = `‚úì Ready to analyze [${mode}] - All markets have ${requiredCandles}+ candles`;
                counterElement.style.color = '#2ecc71';
                counterElement.style.background = 'rgba(46, 204, 113, 0.1)';
            } else {
                counterElement.textContent = `Building candles: ${minCandles} / ${requiredCandles} required (${requiredCandles - minCandles} more needed)`;
                counterElement.style.color = '#f1c40f';
                counterElement.style.background = 'rgba(241, 196, 15, 0.1)';
            }
            
            counterElement.classList.remove('hidden');
        }

        // Update trade count display
        function updateTradeCountDisplay() {
            const totalTrades = tradeHistory.length;
            const displayElement = document.getElementById('tradeCountDisplay');
            
            if (totalTrades === 0) {
                displayElement.textContent = 'No trades yet';
            } else if (totalTrades <= 100) {
                displayElement.textContent = `Showing all ${totalTrades} trade${totalTrades === 1 ? '' : 's'}`;
            } else {
                displayElement.textContent = `Showing latest 100 of ${totalTrades} total trades`;
            }
        }

        // Get duration type value from radio buttons
        function getDurationType() {
            const radios = document.getElementsByName('durationType');
            for (let radio of radios) {
                if (radio.checked) {
                    return radio.value;
                }
            }
            return 't';
        }

        // Set duration type radio button
        function setDurationType(value) {
            const radios = document.getElementsByName('durationType');
            for (let radio of radios) {
                radio.checked = (radio.value === value);
            }
        }

        // Reset clear history button state
        function resetClearHistoryButton() {
            const btn = document.getElementById('clearHistoryBtn');
            btn.textContent = 'Clear History';
            btn.classList.remove('confirm-state');
            clearHistoryConfirmState = false;
            if (clearHistoryTimeout) {
                clearTimeout(clearHistoryTimeout);
                clearHistoryTimeout = null;
            }
        }

        // ALTERNATOR MODE: Get next trade type for a specific market
        function getNextAlternatorTradeType(symbol) {
            if (!isAlternatorMode) {
                return null;
            }
            return marketAlternatorState[symbol];
        }

        // ALTERNATOR MODE: Update alternator state after trade execution
        function updateAlternatorState(symbol, executedType) {
            if (!isAlternatorMode) return;
            
            if (executedType === 'CALL') {
                marketAlternatorState[symbol] = 'PUT';
                logActivity(`[ALTERNATOR] ${markets[symbol]}: Next trade will be SELL (PUT)`, 'info');
            } else if (executedType === 'PUT') {
                marketAlternatorState[symbol] = 'CALL';
                logActivity(`[ALTERNATOR] ${markets[symbol]}: Next trade will be BUY (CALL)`, 'info');
            }
        }

        // ALTERNATOR MODE: Reset all markets to starting state
        function resetAlternatorStates() {
            Object.keys(markets).forEach(symbol => {
                marketAlternatorState[symbol] = 'CALL';
            });
            logActivity('[ALTERNATOR] All markets reset to BUY (CALL) starting position', 'success');
        }

        // Load saved settings
        function loadSettings() {
            const savedToken = sessionStorage.getItem('derivToken');
            const savedMarkets = sessionStorage.getItem('activeMarkets');
            const savedZeroFilter = sessionStorage.getItem('zeroClosingFilter');
            const savedIgnoreHeightFilter = sessionStorage.getItem('ignoreHeightFilter');
            const savedOneCandleFilter = sessionStorage.getItem('oneCandleFilter');
            const savedReverseCandleFilter = sessionStorage.getItem('reverseCandleFilter');
            const savedReverseMode = sessionStorage.getItem('reverseMode');
            const savedAlternatorMode = sessionStorage.getItem('alternatorMode');
            const savedAlternatorStates = sessionStorage.getItem('alternatorStates');
            const savedContractType = sessionStorage.getItem('contractType');
            const savedHLDirection = sessionStorage.getItem('hlDirection');
            const savedPayoutPercentage = sessionStorage.getItem('payoutPercentage');
            const savedStake = sessionStorage.getItem('stakeAmount');
            const savedStopLoss = sessionStorage.getItem('stopLoss');
            const savedTakeProfit = sessionStorage.getItem('takeProfit');
            const savedDurationType = sessionStorage.getItem('durationType');
            const savedDurationValue = sessionStorage.getItem('durationValue');
            const savedMinLowerWickBuy = sessionStorage.getItem('minLowerWickBuy');
            const savedMinUpperWickSell = sessionStorage.getItem('minUpperWickSell');
            const savedMinUpperWickBuy = sessionStorage.getItem('minUpperWickBuy');
            const savedMinLowerWickSell = sessionStorage.getItem('minLowerWickSell');
            const savedMatchingDiffBuy = sessionStorage.getItem('matchingDiffBuy');
            const savedMatchingDiffSell = sessionStorage.getItem('matchingDiffSell');
            const savedTradeHistory = sessionStorage.getItem('tradeHistory');
            const savedStats = sessionStorage.getItem('tradeStats');

            if (savedToken) {
                document.getElementById('apiToken').value = savedToken;
            }

            if (savedMarkets) {
                activeMarkets = JSON.parse(savedMarkets);
            }

            if (savedZeroFilter) {
                document.getElementById('zeroClosingFilter').checked = savedZeroFilter === 'true';
            }

            if (savedIgnoreHeightFilter) {
                document.getElementById('ignoreHeightFilter').checked = savedIgnoreHeightFilter === 'true';
            }

            if (savedOneCandleFilter) {
                document.getElementById('oneCandleFilter').checked = savedOneCandleFilter === 'true';
            }

            if (savedReverseCandleFilter) {
                document.getElementById('reverseCandleFilter').checked = savedReverseCandleFilter === 'true';
            }

            if (savedReverseMode) {
                isReverseMode = savedReverseMode === 'true';
                updateReverseModeButton();
                updateReverseModeIndicator();
            }

            if (savedAlternatorMode) {
                isAlternatorMode = savedAlternatorMode === 'true';
                updateAlternatorModeButton();
                updateAlternatorModeIndicator();
            }

            if (savedAlternatorStates) {
                try {
                    marketAlternatorState = JSON.parse(savedAlternatorStates);
                } catch (e) {
                    console.error('Error loading alternator states:', e);
                }
            }

            if (savedContractType) {
                setContractType(savedContractType);
                updateContractTypeFields();
            }

            if (savedHLDirection) {
                setHLDirection(savedHLDirection);
            }

            if (savedPayoutPercentage) {
                document.getElementById('payoutPercentage').value = savedPayoutPercentage;
            }

            if (savedStake) document.getElementById('stakeAmount').value = savedStake;
            if (savedStopLoss) document.getElementById('stopLoss').value = savedStopLoss;
            if (savedTakeProfit) document.getElementById('takeProfit').value = savedTakeProfit;
            if (savedDurationType) setDurationType(savedDurationType);
            if (savedDurationValue) document.getElementById('durationValue').value = savedDurationValue;
            if (savedMinLowerWickBuy) document.getElementById('minLowerWickBuy').value = savedMinLowerWickBuy;
            if (savedMinUpperWickSell) document.getElementById('minUpperWickSell').value = savedMinUpperWickSell;
            if (savedMinUpperWickBuy) document.getElementById('minUpperWickBuy').value = savedMinUpperWickBuy;
            if (savedMinLowerWickSell) document.getElementById('minLowerWickSell').value = savedMinLowerWickSell;
            if (savedMatchingDiffBuy) document.getElementById('matchingDiffBuy').value = savedMatchingDiffBuy;
            if (savedMatchingDiffSell) document.getElementById('matchingDiffSell').value = savedMatchingDiffSell;

            if (savedTradeHistory) {
                try {
                    tradeHistory = JSON.parse(savedTradeHistory);
                    updateTradeHistoryTable();
                } catch (e) {
                    console.error('Error loading trade history:', e);
                    tradeHistory = [];
                }
            }

            if (savedStats) {
                try {
                    tradeStats = JSON.parse(savedStats);
                    updateStats();
                } catch (e) {
                    console.error('Error loading trade stats:', e);
                    tradeStats = { total: 0, wins: 0, losses: 0, skipped: 0, profitLoss: 0 };
                }
            }

            updateOneCandleIndicator();
            updateContractTypeIndicator();
            checkFilterConflicts();
        }

        // Save settings
        function saveSettings() {
            try {
                sessionStorage.setItem('derivToken', document.getElementById('apiToken').value);
                sessionStorage.setItem('activeMarkets', JSON.stringify(activeMarkets));
                sessionStorage.setItem('zeroClosingFilter', document.getElementById('zeroClosingFilter').checked);
                sessionStorage.setItem('ignoreHeightFilter', document.getElementById('ignoreHeightFilter').checked);
                sessionStorage.setItem('oneCandleFilter', document.getElementById('oneCandleFilter').checked);
                sessionStorage.setItem('reverseCandleFilter', document.getElementById('reverseCandleFilter').checked);
                sessionStorage.setItem('reverseMode', isReverseMode);
                sessionStorage.setItem('alternatorMode', isAlternatorMode);
                sessionStorage.setItem('alternatorStates', JSON.stringify(marketAlternatorState));
                sessionStorage.setItem('contractType', getContractType());
                sessionStorage.setItem('hlDirection', getHLDirection());
                sessionStorage.setItem('payoutPercentage', document.getElementById('payoutPercentage').value);
                sessionStorage.setItem('stakeAmount', document.getElementById('stakeAmount').value);
                sessionStorage.setItem('stopLoss', document.getElementById('stopLoss').value);
                sessionStorage.setItem('takeProfit', document.getElementById('takeProfit').value);
                sessionStorage.setItem('durationType', getDurationType());
                sessionStorage.setItem('durationValue', document.getElementById('durationValue').value);
                sessionStorage.setItem('minLowerWickBuy', document.getElementById('minLowerWickBuy').value);
                sessionStorage.setItem('minUpperWickSell', document.getElementById('minUpperWickSell').value);
                sessionStorage.setItem('minUpperWickBuy', document.getElementById('minUpperWickBuy').value);
                sessionStorage.setItem('minLowerWickSell', document.getElementById('minLowerWickSell').value);
                sessionStorage.setItem('matchingDiffBuy', document.getElementById('matchingDiffBuy').value);
                sessionStorage.setItem('matchingDiffSell', document.getElementById('matchingDiffSell').value);
                sessionStorage.setItem('tradeHistory', JSON.stringify(tradeHistory));
                sessionStorage.setItem('tradeStats', JSON.stringify(tradeStats));
                sessionStorage.setItem('wasAutoTrading', isAutoTrading);
            } catch (e) {
                console.error('Error saving settings:', e);
                logActivity('Warning: Failed to save some settings', 'warning');
            }
        }

        // Render markets with subscription indicators
        function renderMarkets() {
            const grid = document.getElementById('marketsGrid');
            grid.innerHTML = '';

            Object.entries(markets).forEach(([symbol, name]) => {
                const div = document.createElement('div');
                div.className = 'market-item';
                div.innerHTML = `
                    <span class="market-name">${name}</span>
                    <div class="market-controls">
                        <div class="subscription-indicator" data-indicator="${symbol}"></div>
                        <label class="toggle-switch">
                            <input type="checkbox" ${activeMarkets[symbol] ? 'checked' : ''} data-symbol="${symbol}">
                            <span class="slider"></span>
                        </label>
                    </div>
                `;
                grid.appendChild(div);

                const toggle = div.querySelector('input');
                toggle.addEventListener('change', (e) => {
                    activeMarkets[symbol] = e.target.checked;
                    logActivity(`Market ${name} ${e.target.checked ? 'enabled' : 'disabled'}`);
                    saveSettings();
                    
                    if (isLoggedIn && isAutoTrading) {
                        if (e.target.checked) {
                            subscribeToMarket(symbol);
                        } else {
                            unsubscribeFromMarket(symbol);
                        }
                    }
                });
            });
        }

        // Log activity
        function logActivity(message, type = 'info') {
            const container = document.getElementById('logContainer');
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<span class="timestamp">[${time}]</span> ${message}`;
            container.insertBefore(entry, container.firstChild);
            
            while (container.children.length > 100) {
                container.removeChild(container.lastChild);
            }
        }

        // Function to safely close a candle - FLOATING BROWSER FIX
        function finalizeCandle(symbol, closeTime, closePrice) {
            if (!currentOHLC[symbol]) return;
            
            const now = Date.now();
            if (lastCandleProcessTime[symbol] && (now - lastCandleProcessTime[symbol]) < 500) {
                console.log(`[THROTTLE] Skipping rapid candle finalization for ${symbol}`);
                return;
            }
            lastCandleProcessTime[symbol] = now;

            const completedCandle = {
                time: currentMinute[symbol],
                open: currentOHLC[symbol].open,
                high: currentOHLC[symbol].high,
                low: currentOHLC[symbol].low,
                close: currentOHLC[symbol].close
            };

            candleData[symbol].push(completedCandle);
            
            if (candleData[symbol].length > 100) {
                candleData[symbol].shift();
            }

            // Calculate Parabolic SAR if filter is enabled
            const parabolicSarFilterEnabled = document.getElementById('parabolicSarFilter').checked;
            if (parabolicSarFilterEnabled) {
                const sarData = calculateParabolicSAR(candleData[symbol]);
                if (sarData) {
                    parabolicSarCache[symbol] = sarData;
                }
            }

            currentMinute[symbol] = closeTime;
            
            currentOHLC[symbol] = {
                open: closePrice,
                high: closePrice,
                low: closePrice,
                close: closePrice
            };

            updateCandleCounter();
            
            const oneCandleFilter = document.getElementById('oneCandleFilter').checked;
            let requiredCandles = oneCandleFilter ? 1 : 3;
            
            if (isAutoTrading && candleData[symbol].length >= requiredCandles) {
                checkForSignals(symbol);
            }
        }

        // Enhanced Connect to Deriv API with auto-reconnect
        function connectWebSocket(token, isReconnect = false) {
            return new Promise((resolve, reject) => {
                if (reconnectTimeout) {
                    clearTimeout(reconnectTimeout);
                    reconnectTimeout = null;
                }

                ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=1089');

                ws.onopen = () => {
                    if (isReconnect) {
                        logActivity('WebSocket reconnected successfully', 'success');
                        reconnectAttempts = 0;
                    } else {
                        logActivity('WebSocket connected', 'success');
                    }
                    updateConnectionBadge('connected');
                    lastHeartbeat = Date.now();
                    ws.send(JSON.stringify({ authorize: token }));
                };

                ws.onmessage = (msg) => {
                    lastHeartbeat = Date.now();
                    const data = JSON.parse(msg.data);
                    handleWebSocketMessage(data, resolve, reject);
                };

                ws.onerror = (error) => {
                    logActivity('WebSocket error', 'error');
                    updateConnectionBadge('disconnected');
                    
                    if (sessionTimer) {
                        stopSessionTimer();
                        logActivity('Session timer reset due to connection error', 'warning');
                    }
                    
                    reject(error);
                };

                ws.onclose = () => {
                    logActivity('WebSocket disconnected', 'error');
                    updateConnectionBadge('disconnected');
                    if (sessionTimer) {
                        stopSessionTimer();
                        logActivity('Session timer reset due to disconnection', 'warning');
                    }
                    
                    Object.keys(markets).forEach(symbol => {
                        updateSubscriptionIndicator(symbol, 'disconnected');
                    });
                    
                    marketSubscriptions = {};
                    pendingSubscriptions = {};
                    
                    // ‚úÖ FIX #4: Save contract state before reconnecting
                    if (isLoggedIn && reconnectAttempts < maxReconnectAttempts) {
                        wasAutoTradingBeforeDisconnect = isAutoTrading;
                        
                        // Save open contracts to session storage
                        try {
                            const openContractsArray = Array.from(openContracts.entries());
                            sessionStorage.setItem('openContracts', JSON.stringify(openContractsArray));
                            logActivity(`Saved ${openContractsArray.length} open contracts for recovery`, 'info');
                        } catch (e) {
                            console.error('Error saving open contracts:', e);
                        }
                        
                        reconnectAttempts++;
                        const delay = Math.min(1000 * Math.pow(2, reconnectAttempts - 1), 30000);
                        
                        updateConnectionBadge('reconnecting');
                        logActivity(`Reconnection attempt ${reconnectAttempts}/${maxReconnectAttempts} in ${delay/1000}s...`, 'warning');
                        
                        reconnectTimeout = setTimeout(() => {
                            const savedToken = sessionStorage.getItem('derivToken');
                            if (savedToken) {
                                connectWebSocket(savedToken, true)
                                    .then(() => {
                                        logActivity('Reconnected successfully!', 'success');
                                        
                                        // ‚úÖ FIX #4: Restore open contracts tracking
                                        try {
                                            const savedOpenContracts = sessionStorage.getItem('openContracts');
                                            if (savedOpenContracts) {
                                                const openContractsArray = JSON.parse(savedOpenContracts);
                                                openContracts = new Map(openContractsArray);
                                                logActivity(`‚úÖ Restored tracking for ${openContracts.size} open contracts`, 'success');
                                                
                                                // Re-subscribe to all open contracts
                                                if (openContracts.size > 0) {
                                                    setTimeout(() => resubscribeToOpenContracts(), 1000);
                                                }
                                            }
                                        } catch (e) {
                                            console.error('Error restoring open contracts:', e);
                                        }
                                        
                                        if (!sessionTimer) {
                                            startSessionTimer();
                                            logActivity('Session timer restarted after reconnection', 'success');
                                        }
                                        
                                        if (wasAutoTradingBeforeDisconnect && !isAutoTrading) {
                                            logActivity('Resuming auto trading...', 'info');
                                            setTimeout(() => startAutoTrading(), 1000);
                                        } else if (isAutoTrading) {
                                            subscribeToActiveMarkets();
                                        }
                                    })
                                    .catch(err => {
                                        logActivity(`Reconnection attempt ${reconnectAttempts} failed`, 'error');
                                    });
                            }
                        }, delay);
                    } else if (reconnectAttempts >= maxReconnectAttempts) {
                        logActivity('Max reconnection attempts reached. Please refresh the page or login again.', 'error');
                        reconnectAttempts = 0;
                    }
                };
            });
        }

        // Handle WebSocket messages
        function handleWebSocketMessage(data, resolve, reject) {
            if (data.error) {
                if (data.error.code !== 'AlreadySubscribed') {
                    logActivity('API Error: ' + data.error.message, 'error');
                    
                    if (data.echo_req && data.echo_req.ticks) {
                        const symbol = data.echo_req.ticks;
                        delete pendingSubscriptions[symbol];
                        updateSubscriptionIndicator(symbol, 'disconnected');
                    }
                    
                    // ‚úÖ FIX #2 & #5: Enhanced buy error handling
                    if (data.msg_type === 'buy' || (data.echo_req && data.echo_req.buy)) {
                        const proposalId = data.echo_req?.buy;
                        
                        // Clean up pending trade on error
                        if (proposalId && pendingTrades.has(proposalId)) {
                            const tradeInfo = pendingTrades.get(proposalId);
                            pendingTrades.delete(proposalId);
                            
                            logActivity(`‚ùå Buy request failed for ${markets[tradeInfo.symbol]}: ${data.error.message}`, 'error');
                            
                            // Mark as skipped in stats
                            tradeStats.skipped++;
                            updateStats();
                            saveSettings();
                        } else {
                            logActivity(`‚ùå Trade failed: ${data.error.message}`, 'error');
                        }
                    }
                }
                if (reject && data.error.code !== 'AlreadySubscribed') {
                    reject(new Error(data.error.message));
                }
                return;
            }

            if (data.msg_type === 'authorize') {
                accountInfo = {
                    type: data.authorize.account_list.find(a => a.loginid === data.authorize.loginid)?.is_virtual ? 'Demo' : 'Real',
                    currency: data.authorize.currency,
                    balance: data.authorize.balance,
                    loginid: data.authorize.loginid
                };

                document.getElementById('accountType').textContent = accountInfo.type;
                document.getElementById('accountCurrency').textContent = accountInfo.currency;
                document.getElementById('accountBalance').textContent = parseFloat(accountInfo.balance).toFixed(2);

                logActivity(`Logged in as ${accountInfo.loginid} (${accountInfo.type})`, 'success');
                
                // SMART AUTO-DETECTION: Request active_symbols to get market precision data
                ws.send(JSON.stringify({ active_symbols: 'brief', product_type: 'basic' }));
                
                ws.send(JSON.stringify({ balance: 1, subscribe: 1 }));

                if (resolve) resolve();
            }

            // SMART AUTO-DETECTION: Handle active_symbols response
            if (data.msg_type === 'active_symbols') {
                const symbols = data.active_symbols;
                symbols.forEach(s => {
                    // Calculate decimal count from pip value (e.g., 0.01 = 2, 0.001 = 3)
                    const pipStr = String(s.pip);
                    const decimals = pipStr.includes('.') ? pipStr.split('.')[1].length : 0;
                    symbolPips[s.symbol] = decimals;
                });
                logActivity(`‚úÖ Smart detection active: Loaded precision for ${symbols.length} markets`, 'success');
            }

            if (data.msg_type === 'balance') {
                accountInfo.balance = data.balance.balance;
                document.getElementById('accountBalance').textContent = parseFloat(accountInfo.balance).toFixed(2);
            }

            if (data.msg_type === 'tick' && data.tick) {
                const symbol = data.tick.symbol;
                if (!activeMarkets[symbol]) return;
                
                if (isProcessingTicks) {
                    return;
             }
                isProcessingTicks = true;

                const epoch = data.tick.epoch;
                const quote = parseFloat(data.tick.quote);
                const now = Date.now();
                
                currentSpot[symbol] = quote;
                
                const calculatedOffset = now - (epoch * 1000);
                if (!isTimeSynced) {
                    serverTimeOffset = calculatedOffset;
                    isTimeSynced = true;
                } else {
                    serverTimeOffset = (serverTimeOffset * 0.9) + (calculatedOffset * 0.1);
                }

                const tickMinute = Math.floor(epoch / 60) * 60;

                if (currentMinute[symbol] === undefined) {
                    currentMinute[symbol] = tickMinute;
                    currentOHLC[symbol] = { open: quote, high: quote, low: quote, close: quote };
                }

                if (tickMinute > currentMinute[symbol]) {
                    finalizeCandle(symbol, tickMinute, quote);
                }

                if (currentOHLC[symbol]) {
                    currentOHLC[symbol].high = Math.max(currentOHLC[symbol].high, quote);
                    currentOHLC[symbol].low = Math.min(currentOHLC[symbol].low, quote);
                    currentOHLC[symbol].close = quote;
                }

                if (data.subscription && data.subscription.id && !marketSubscriptions[symbol]) {
                    marketSubscriptions[symbol] = data.subscription.id;
                    delete pendingSubscriptions[symbol];
                    updateSubscriptionIndicator(symbol, 'subscribed');
                    logActivity(`${markets[symbol]} subscribed successfully`, 'success');
                }
                
                isProcessingTicks = false;
            }

            if (data.msg_type === 'proposal' && data.proposal) {
                const reqId = data.req_id;
                if (pendingProposals.has(reqId)) {
                    const proposalData = pendingProposals.get(reqId);
                    proposalData.resolve(data);
                    pendingProposals.delete(reqId);
                }
            }

            if (data.msg_type === 'buy') {
                if (data.buy && data.buy.contract_id) {
                    const proposalId = data.echo_req?.buy;
                    const tradeInfo = pendingTrades.get(proposalId);
                    
                    if (tradeInfo) {
                        pendingTrades.delete(proposalId);
                        pendingTrades.set(data.buy.contract_id, tradeInfo);
                        
                        // ‚úÖ FIX #6: Track open contract
                        openContracts.set(data.buy.contract_id, {
                            symbol: tradeInfo.symbol,
                            type: tradeInfo.type,
                            stake: tradeInfo.stake,
                            timestamp: Date.now()
                        });
                    }
                    
                    // ‚úÖ FIX #8: Enhanced subscription with error handling
                    try {
                        ws.send(JSON.stringify({
                            proposal_open_contract: 1,
                            contract_id: data.buy.contract_id,
                            subscribe: 1
                        }));
                        
                        logActivity(`Trade opened: Contract ID ${data.buy.contract_id}`, 'success');
                    } catch (error) {
                        logActivity(`Failed to subscribe to contract ${data.buy.contract_id}: ${error.message}`, 'error');
                        
                        // Retry subscription after 2 seconds
                        setTimeout(() => {
                            if (ws && ws.readyState === WebSocket.OPEN) {
                                try {
                                    ws.send(JSON.stringify({
                                        proposal_open_contract: 1,
                                        contract_id: data.buy.contract_id,
                                        subscribe: 1
                                    }));
                                    logActivity(`Retried subscription for contract ${data.buy.contract_id}`, 'info');
                                } catch (retryError) {
                                    logActivity(`Retry failed for contract ${data.buy.contract_id}`, 'error');
                                }
                            }
                        }, 2000);
                    }
                }
            }

            if (data.msg_type === 'proposal_open_contract') {
                handleTradeResult(data.proposal_open_contract);
            }

            if (data.msg_type === 'forget') {
                if (data.forget) {
                    logActivity(`Unsubscribed from subscription ID: ${data.forget}`, 'info');
                }
            }

            if (data.msg_type === 'ping') {
                ws.send(JSON.stringify({ ping: 1 }));
            }

            if (data.msg_type === 'contracts_for') {
                const reqId = data.req_id;
                if (pendingProposals.has(reqId)) {
                    const proposalData = pendingProposals.get(reqId);
                    proposalData.resolve(data);
                    pendingProposals.delete(reqId);
                }
            }
        }

        // Handle trade result with proper duplicate prevention
        function handleTradeResult(contract) {
            // ‚úÖ FIX #10: Validate contract ID before processing
            if (!contract || !contract.contract_id) {
                logActivity('Received invalid contract data', 'warning');
                return;
            }
            
            if (!['won', 'lost', 'sold'].includes(contract.status)) {
                // ‚úÖ FIX #6: Update timestamp for pending contracts
                if (openContracts.has(contract.contract_id)) {
                    const contractInfo = openContracts.get(contract.contract_id);
                    contractInfo.lastUpdate = Date.now();
                    openContracts.set(contract.contract_id, contractInfo);
                }
                return;
            }
            
            if (processedContracts.has(contract.contract_id)) {
                console.log(`[DUPLICATE PREVENTED] Contract ${contract.contract_id} already processed`);
                return;
            }

            processedContracts.add(contract.contract_id);
            
            // ‚úÖ FIX #6: Remove from open contracts tracking
            if (openContracts.has(contract.contract_id)) {
                openContracts.delete(contract.contract_id);
                logActivity(`Contract ${contract.contract_id} removed from tracking`, 'info');
            }

            const profit = parseFloat(contract.profit || 0);
            const isWin = profit > 0;

            tradeStats.total++;
            if (isWin) tradeStats.wins++;
            else tradeStats.losses++;
            tradeStats.profitLoss += profit;

            const trade = {
                id: contract.contract_id,
                time: new Date().toLocaleTimeString(),
                date: new Date().toLocaleDateString(),
                market: markets[contract.underlying] || contract.underlying || 'Unknown',
                type: contract.contract_type || 'Unknown',
                stake: parseFloat(contract.buy_price || 0).toFixed(2),
                result: profit.toFixed(2),
                isWin: isWin
            };

            if (!Array.isArray(tradeHistory)) {
                tradeHistory = [];
                logActivity('Trade history reinitialized', 'warning');
            }

            tradeHistory.unshift(trade);
            
            if (tradeHistory.length > 100) {
                tradeHistory = tradeHistory.slice(0, 100);
            }

            updateStats();
            updateTradeHistoryTable();
            saveSettings();

            logActivity(`‚úÖ TRADE SETTLED: ${trade.market} - ${trade.type} - P/L: ${trade.result} (ID: ${contract.contract_id})`, isWin ? 'success' : 'error');

            const stopLoss = parseFloat(document.getElementById('stopLoss').value);
            const takeProfit = parseFloat(document.getElementById('takeProfit').value);

            if (stopLoss > 0 && Math.abs(tradeStats.profitLoss) >= stopLoss && tradeStats.profitLoss < 0) {
                logActivity(`Stop loss reached: ${tradeStats.profitLoss.toFixed(2)}`, 'error');
                stopAutoTrading();
            }

            if (takeProfit > 0 && tradeStats.profitLoss >= takeProfit) {
                logActivity(`Take profit reached: ${tradeStats.profitLoss.toFixed(2)}`, 'success');
                stopAutoTrading();
            }

            if (pendingTrades.has(contract.contract_id)) {
                pendingTrades.delete(contract.contract_id);
            }

            setTimeout(() => {
                processedContracts.delete(contract.contract_id);
            }, 300000);
        }

        // ‚úÖ FIX #7: Periodic contract status checking
        function startContractRecoveryTimer() {
            if (contractRecoveryTimer) {
                clearInterval(contractRecoveryTimer);
            }
            
            contractRecoveryTimer = setInterval(() => {
                checkMissedContracts();
            }, 30000); // Check every 30 seconds
            
            logActivity('Contract recovery system started', 'info');
        }

        // ‚úÖ FIX #7: Check for contracts that may have been missed
        function checkMissedContracts() {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            if (openContracts.size === 0) return;
            
            const now = Date.now();
            if (now - lastContractCheckTime < 25000) return; // Rate limit checks
            
            lastContractCheckTime = now;
            
            const contractsToCheck = [];
            openContracts.forEach((contractInfo, contractId) => {
                const age = now - contractInfo.timestamp;
                // Check contracts older than 2 minutes
                if (age > 120000) {
                    contractsToCheck.push(contractId);
                }
            });
            
            if (contractsToCheck.length > 0) {
                logActivity(`üîç Checking status of ${contractsToCheck.length} pending contracts...`, 'info');
                
                contractsToCheck.forEach(contractId => {
                    try {
                        ws.send(JSON.stringify({
                            proposal_open_contract: 1,
                            contract_id: contractId
                        }));
                    } catch (error) {
                        logActivity(`Failed to check contract ${contractId}`, 'error');
                    }
                });
            }
        }

        // ‚úÖ FIX #4: Re-subscribe to open contracts after reconnection
        function resubscribeToOpenContracts() {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            
            let resubscribed = 0;
            openContracts.forEach((contractInfo, contractId) => {
                try {
                    ws.send(JSON.stringify({
                        proposal_open_contract: 1,
                        contract_id: contractId,
                        subscribe: 1
                    }));
                    resubscribed++;
                } catch (error) {
                    logActivity(`Failed to re-subscribe to contract ${contractId}`, 'error');
                }
            });
            
            if (resubscribed > 0) {
                logActivity(`‚úÖ Re-subscribed to ${resubscribed} open contracts`, 'success');
            }
        }

        // Login
        document.getElementById('loginBtn').addEventListener('click', async () => {
            const token = document.getElementById('apiToken').value.trim();
            if (!token) {
                logActivity('Please enter API token', 'error');
                return;
            }

            document.getElementById('loginBtn').disabled = true;
            document.getElementById('loginBtn').textContent = 'Connecting...';

            try {
                await connectWebSocket(token);
                isLoggedIn = true;
                reconnectAttempts = 0;
                
                document.getElementById('loginSection').classList.add('hidden');
                document.getElementById('accountInfo').classList.remove('hidden');
                document.getElementById('timerDisplay').classList.remove('hidden');
                document.getElementById('autoTradeBtn').disabled = false;
                document.getElementById('reverseModeBtn').disabled = false;
                document.getElementById('alternatorModeBtn').disabled = false;

                saveSettings();
                startSessionTimer();
                
                // ‚úÖ FIX #4 & #7: Start contract recovery timer
                startContractRecoveryTimer();
                
                logActivity('Login successful', 'success');
            } catch (error) {
                logActivity('Login failed: ' + error.message, 'error');
                document.getElementById('loginBtn').disabled = false;
                document.getElementById('loginBtn').textContent = 'Login';
                updateConnectionBadge('disconnected');
            }
        });

        // Logout
        document.getElementById('logoutBtn').addEventListener('click', () => {
            if (isAutoTrading) {
                stopAutoTrading();
            }

            if (ws) {
                ws.close();
                ws = null;
            }

            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }
            
            // ‚úÖ FIX: Stop contract recovery timer
            if (contractRecoveryTimer) {
                clearInterval(contractRecoveryTimer);
                contractRecoveryTimer = null;
            }
            
            // Clear open contracts tracking
            openContracts.clear();
            sessionStorage.removeItem('openContracts');

            isLoggedIn = false;
            reconnectAttempts = 0;
            stopSessionTimer();
            updateConnectionBadge('disconnected');

            document.getElementById('apiToken').value = '';
            sessionStorage.removeItem('derivToken');

            document.getElementById('loginSection').classList.remove('hidden');
            document.getElementById('accountInfo').classList.add('hidden');
            document.getElementById('timerDisplay').classList.add('hidden');
            document.getElementById('autoTradeBtn').disabled = true;
            document.getElementById('reverseModeBtn').disabled = true;
            document.getElementById('alternatorModeBtn').disabled = true;
            document.getElementById('loginBtn').disabled = false;
            document.getElementById('loginBtn').textContent = 'Login';

            logActivity('Logged out successfully - Token cleared', 'success');
        });

        // Session timer
        function startSessionTimer() {
            sessionStartTime = Date.now();
            sessionTimer = setInterval(() => {
                const elapsed = Date.now() - sessionStartTime;
                const hours = Math.floor(elapsed / 3600000);
                const minutes = Math.floor((elapsed % 3600000) / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                
                document.getElementById('timerValue').textContent = 
                    `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }, 1000);
        }

        function stopSessionTimer() {
            if (sessionTimer) {
                clearInterval(sessionTimer);
                sessionTimer = null;
            }
            sessionStartTime = null;
            document.getElementById('timerValue').textContent = '00:00:00';
        }

        // Calculate Parabolic SAR
        function calculateParabolicSAR(candles, acceleration = 0.02, maxAcceleration = 0.2) {
            if (candles.length < 2) return null;

            const sar = [];
            let trend = 1; // 1 for uptrend, -1 for downtrend
            let ep = candles[0].high;
            let af = acceleration;
            let sarValue = candles[0].low;

            for (let i = 1; i < candles.length; i++) {
                const currentCandle = candles[i];
                
                // Calculate new SAR
                sarValue = sarValue + af * (ep - sarValue);

                // Check for trend reversal
                if (trend === 1) {
                    if (currentCandle.low < sarValue) {
                        // Reversal to downtrend
                        trend = -1;
                        sarValue = ep;
                        ep = currentCandle.low;
                        af = acceleration;
                    } else {
                        // Continue uptrend
                        if (currentCandle.high > ep) {
                            ep = currentCandle.high;
                            af = Math.min(af + acceleration, maxAcceleration);
                        }
                    }
                } else {
                    if (currentCandle.high > sarValue) {
                        // Reversal to uptrend
                        trend = 1;
                        sarValue = ep;
                        ep = currentCandle.high;
                        af = acceleration;
                    } else {
                        // Continue downtrend
                        if (currentCandle.low < ep) {
                            ep = currentCandle.low;
                            af = Math.min(af + acceleration, maxAcceleration);
                        }
                    }
                }

                sar.push({
                    value: sarValue,
                    trend: trend,
                    position: trend === 1 ? 'below' : 'above'
                });
            }

            return sar;
        }

        // Check Parabolic SAR signal
        function checkParabolicSARSignal(symbol, signalType) {
            const cachedData = parabolicSarCache[symbol];
            if (!cachedData || cachedData.length < 2) {
                return false;
            }

            const previousSAR = cachedData[cachedData.length - 2];
            const currentSAR = cachedData[cachedData.length - 1];

            // For CALL: SAR moves from above to below
            if (signalType === 'CALL') {
                return previousSAR.position === 'above' && currentSAR.position === 'below';
            }

            // For PUT: SAR moves from below to above
            if (signalType === 'PUT') {
                return previousSAR.position === 'below' && currentSAR.position === 'above';
            }

            return false;
        }

        // Subscribe to market
        function subscribeToMarket(symbol) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                logActivity('Cannot subscribe: WebSocket not connected', 'error');
                return;
            }

            if (marketSubscriptions[symbol]) {
                logActivity(`Already subscribed to ${markets[symbol]}`, 'info');
                updateSubscriptionIndicator(symbol, 'subscribed');
                return;
            }

            if (pendingSubscriptions[symbol]) {
                logActivity(`Already subscribing to ${markets[symbol]}`, 'info');
                return;
            }

            pendingSubscriptions[symbol] = true;
            updateSubscriptionIndicator(symbol, 'subscribing');

            const subscribeMsg = {
                ticks: symbol,
                subscribe: 1
            };

            ws.send(JSON.stringify(subscribeMsg));
            logActivity(`Subscribing to ${markets[symbol]}...`, 'info');

            setTimeout(() => {
                if (pendingSubscriptions[symbol] && !marketSubscriptions[symbol]) {
                    delete pendingSubscriptions[symbol];
                    updateSubscriptionIndicator(symbol, 'disconnected');
                    logActivity(`Subscription timeout for ${markets[symbol]}`, 'error');
                }
            }, 10000);
        }

        function unsubscribeFromMarket(symbol) {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;

            if (marketSubscriptions[symbol]) {
                ws.send(JSON.stringify({ forget: marketSubscriptions[symbol] }));
                delete marketSubscriptions[symbol];
                candleData[symbol] = [];
                currentOHLC[symbol] = undefined;
                currentMinute[symbol] = undefined;
                tradedCandles[symbol].clear();
                updateSubscriptionIndicator(symbol, 'disconnected');
                logActivity(`Unsubscribed from ${markets[symbol]}`);
            }

            if (pendingSubscriptions[symbol]) {
                delete pendingSubscriptions[symbol];
                updateSubscriptionIndicator(symbol, 'disconnected');
            }
            
            updateCandleCounter();
        }

        // Subscribe to all active markets
        function subscribeToActiveMarkets() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                logActivity('Cannot subscribe: WebSocket not connected', 'error');
                return;
            }

            let subscribeCount = 0;
            Object.keys(activeMarkets).forEach(symbol => {
                if (activeMarkets[symbol]) {
                    subscribeToMarket(symbol);
                    subscribeCount++;
                }
            });

            logActivity(`Subscribing to ${subscribeCount} active markets...`, 'info');
        }

        // Unsubscribe from all markets
        function unsubscribeFromAllMarkets() {
            Object.keys(marketSubscriptions).forEach(symbol => {
                unsubscribeFromMarket(symbol);
            });
            Object.keys(pendingSubscriptions).forEach(symbol => {
                delete pendingSubscriptions[symbol];
                updateSubscriptionIndicator(symbol, 'disconnected');
            });
        }

        // Check for trading signals with proper execution order - FULLY FIXED
        function checkForSignals(symbol) {
            const oneCandleFilter = document.getElementById('oneCandleFilter').checked;
            
            let requiredCandles = oneCandleFilter ? 1 : 3;
            
            if (candleData[symbol].length < requiredCandles) return;

            const candles = candleData[symbol];
            const lastCandle = candles[candles.length - 1];

            if (!lastCandle) return;

            const candle_start_time = lastCandle.time;
            if (candle_start_time < activation_time) {
                return;
            }

            const candleKey = `${lastCandle.time}`;
            
            if (tradedCandles[symbol].has(candleKey)) {
                return;
            }

            const zeroClosingFilter = document.getElementById('zeroClosingFilter').checked;
            const ignoreHeightFilter = document.getElementById('ignoreHeightFilter').checked;
            const reverseCandleFilter = document.getElementById('reverseCandleFilter').checked;
            const minLowerWickBuy = parseFloat(document.getElementById('minLowerWickBuy').value) / 100;
            const minUpperWickSell = parseFloat(document.getElementById('minUpperWickSell').value) / 100;
            const minUpperWickBuy = parseFloat(document.getElementById('minUpperWickBuy').value) / 100;
            const minLowerWickSell = parseFloat(document.getElementById('minLowerWickSell').value) / 100;

            // ONE CANDLE MODE
            if (oneCandleFilter) {
                const buySignal = checkOneCandleBuy(lastCandle, zeroClosingFilter, ignoreHeightFilter, reverseCandleFilter, minLowerWickBuy, minUpperWickBuy);
                if (buySignal) {
                    let tradeType = isReverseMode ? 'PUT' : 'CALL';

                    if (!ws || ws.readyState !== WebSocket.OPEN) {
                        logActivity(`‚ö†Ô∏è Signal skipped for ${markets[symbol]}: WebSocket not connected`, 'warning');
                        tradeStats.skipped++;
                        updateStats();
                        saveSettings();
                        return;
                    }

                    // Check Parabolic SAR filter
                    const parabolicSarFilterEnabled = document.getElementById('parabolicSarFilter').checked;
                    if (parabolicSarFilterEnabled) {
                        const tempTradeType = isReverseMode ? 'PUT' : 'CALL';
                        const sarSignal = checkParabolicSARSignal(symbol, tempTradeType);
                        if (!sarSignal) {
                            logActivity(`‚è≠Ô∏è Signal skipped for ${markets[symbol]}: Parabolic SAR filter not met for ${tempTradeType}`, 'warning');
                            tradeStats.skipped++;
                            updateStats();
                            saveSettings();
                            return;
                        }
                    }

                    const contractType = getContractType();
                    const hlDirection = getHLDirection();
                    
                    if (contractType === 'HIGHER_LOWER') {
                        if (symbol.startsWith('stpRNG')) {
                            logActivity(`‚ö†Ô∏è Signal skipped for ${markets[symbol]}: Step Index not supported for Higher/Lower`, 'warning');
                            tradeStats.skipped++;
                            updateStats();
                            saveSettings();
                            return;
                        }
                        
                        if (hlDirection === 'LOWER_ONLY') {
                            logActivity(`‚ö†Ô∏è Signal skipped for ${markets[symbol]}: BUY signal but LOWER ONLY mode active`, 'warning');
                            tradeStats.skipped++;
                            updateStats();
                            saveSettings();
                            return;
                        }
                        tradeType = isReverseMode ? 'PUT' : 'CALL';
                    }

                    // ALTERNATOR MODE
                    if (isAlternatorMode) {
                        const expectedType = getNextAlternatorTradeType(symbol);
                        if (tradeType !== expectedType) {
                            logActivity(`‚ö†Ô∏è [ALTERNATOR BLOCK] ${markets[symbol]}: BUY signal detected but expecting ${expectedType === 'CALL' ? 'BUY' : 'SELL'}. Signal skipped.`, 'warning');
                            tradeStats.skipped++;
                            updateStats();
                            
                            const patternName = reverseCandleFilter ? 'Reverse One Candle Buy' : 'One Candle Buy';
                            const signalText = isReverseMode ? `${patternName} SELL (REVERSED) - BLOCKED BY ALTERNATOR` : `${patternName} BUY - BLOCKED BY ALTERNATOR`;
                            addSignal(symbol, signalText, 'skipped');
                            
                            saveSettings();
                            return;
                        }
                    }

                    tradedCandles[symbol].add(candleKey);

                    const patternName = reverseCandleFilter ? 'Reverse One Candle Buy' : 'One Candle Buy';
                    const signalText = isReverseMode ? `${patternName} SELL (REVERSED)` : `${patternName} BUY`;
                    addSignal(symbol, signalText);

                    executeTrade(symbol, tradeType, candleKey).catch(error => {
                        logActivity(`‚ùå Trade failed for ${markets[symbol]}: ${error.message}`, 'error');
                    });
                }

                const sellSignal = checkOneCandleSell(lastCandle, zeroClosingFilter, ignoreHeightFilter, reverseCandleFilter, minUpperWickSell, minLowerWickSell);
                if (sellSignal) {
                    let tradeType = isReverseMode ? 'CALL' : 'PUT';

                    if (!ws || ws.readyState !== WebSocket.OPEN) {
                        logActivity(`‚ö†Ô∏è Signal skipped for ${markets[symbol]}: WebSocket not connected`, 'warning');
                        tradeStats.skipped++;
                        updateStats();
                        saveSettings();
                        return;
                    }

                    // Check Parabolic SAR filter
                    const parabolicSarFilterEnabled = document.getElementById('parabolicSarFilter').checked;
                    if (parabolicSarFilterEnabled) {
                        const tempTradeType = isReverseMode ? 'CALL' : 'PUT';
                        const sarSignal = checkParabolicSARSignal(symbol, tempTradeType);
                        if (!sarSignal) {
                            logActivity(`‚è≠Ô∏è Signal skipped for ${markets[symbol]}: Parabolic SAR filter not met for ${tempTradeType}`, 'warning');
                            tradeStats.skipped++;
                            updateStats();
                            saveSettings();
                            return;
                        }
                    }

                    const contractType = getContractType();
                    const hlDirection = getHLDirection();
                    
                    if (contractType === 'HIGHER_LOWER') {
                        if (symbol.startsWith('stpRNG')) {
                            logActivity(`‚ö†Ô∏è Signal skipped for ${markets[symbol]}: Step Index not supported for Higher/Lower`, 'warning');
                            tradeStats.skipped++;
                            updateStats();
                            saveSettings();
                            return;
                        }
                        
                        if (hlDirection === 'HIGHER_ONLY') {
                            logActivity(`‚ö†Ô∏è Signal skipped for ${markets[symbol]}: SELL signal but HIGHER ONLY mode active`, 'warning');
                            tradeStats.skipped++;
                            updateStats();
                            saveSettings();
                            return;
                        }
                        tradeType = isReverseMode ? 'CALL' : 'PUT';
                    }

                    // ALTERNATOR MODE
                    if (isAlternatorMode) {
                        const expectedType = getNextAlternatorTradeType(symbol);
                        if (tradeType !== expectedType) {
                            logActivity(`‚ö†Ô∏è [ALTERNATOR BLOCK] ${markets[symbol]}: SELL signal detected but expecting ${expectedType === 'CALL' ? 'BUY' : 'SELL'}. Signal skipped.`, 'warning');
                            tradeStats.skipped++;
                            updateStats();
                            
                            const patternName = reverseCandleFilter ? 'Reverse One Candle Sell' : 'One Candle Sell';
                            const signalText = isReverseMode ? `${patternName} BUY (REVERSED) - BLOCKED BY ALTERNATOR` : `${patternName} SELL - BLOCKED BY ALTERNATOR`;
                            addSignal(symbol, signalText, 'skipped');
                            
                            saveSettings();
                            return;
                        }
                    }

                    tradedCandles[symbol].add(candleKey);

                    const patternName = reverseCandleFilter ? 'Reverse One Candle Sell' : 'One Candle Sell';
                    const signalText = isReverseMode ? `${patternName} BUY (REVERSED)` : `${patternName} SELL`;
                    addSignal(symbol, signalText);

                    executeTrade(symbol, tradeType, candleKey).catch(error => {
                        logActivity(`‚ùå Trade failed for ${markets[symbol]}: ${error.message}`, 'error');
                    });
                }
            } else {
                // TWO CANDLE MODE
                const prevCandle = candles[candles.length - 2];
                if (!prevCandle) return;

                const matchingDiffBuy = parseFloat(document.getElementById('matchingDiffBuy').value) / 100;
                const matchingDiffSell = parseFloat(document.getElementById('matchingDiffSell').value) / 100;

                const buySignal = checkTweezersBottom(prevCandle, lastCandle, zeroClosingFilter, ignoreHeightFilter, reverseCandleFilter, minLowerWickBuy, minUpperWickBuy, matchingDiffBuy);
                if (buySignal) {
                    let tradeType = isReverseMode ? 'PUT' : 'CALL';

                    if (!ws || ws.readyState !== WebSocket.OPEN) {
                        logActivity(`‚ö†Ô∏è Signal skipped for ${markets[symbol]}: WebSocket not connected`, 'warning');
                        tradeStats.skipped++;
                        updateStats();
                        saveSettings();
                        return;
                    }

                    // Check Parabolic SAR filter
                    const parabolicSarFilterEnabled = document.getElementById('parabolicSarFilter').checked;
                    if (parabolicSarFilterEnabled) {
                        const tempTradeType = isReverseMode ? 'PUT' : 'CALL';
                        const sarSignal = checkParabolicSARSignal(symbol, tempTradeType);
                        if (!sarSignal) {
                            logActivity(`‚è≠Ô∏è Signal skipped for ${markets[symbol]}: Parabolic SAR filter not met for ${tempTradeType}`, 'warning');
                            tradeStats.skipped++;
                            updateStats();
                            saveSettings();
                            return;
                        }
                    }

                    const contractType = getContractType();
                    const hlDirection = getHLDirection();
                    
                    if (contractType === 'HIGHER_LOWER') {
                        if (symbol.startsWith('stpRNG')) {
                            logActivity(`‚ö†Ô∏è Signal skipped for ${markets[symbol]}: Step Index not supported for Higher/Lower`, 'warning');
                            tradeStats.skipped++;
                            updateStats();
                            saveSettings();
                            return;
                        }
                        
                        if (hlDirection === 'LOWER_ONLY') {
                            logActivity(`‚ö†Ô∏è Signal skipped for ${markets[symbol]}: BUY signal but LOWER ONLY mode active`, 'warning');
                            tradeStats.skipped++;
                            updateStats();
                            saveSettings();
                            return;
                        }
                        tradeType = isReverseMode ? 'PUT' : 'CALL';
                    }

                    // ALTERNATOR MODE
                    if (isAlternatorMode) {
                        const expectedType = getNextAlternatorTradeType(symbol);
                        if (tradeType !== expectedType) {
                            logActivity(`‚ö†Ô∏è [ALTERNATOR BLOCK] ${markets[symbol]}: BUY signal detected but expecting ${expectedType === 'CALL' ? 'BUY' : 'SELL'}. Signal skipped.`, 'warning');
                            tradeStats.skipped++;
                            updateStats();
                            
                            const patternName = reverseCandleFilter ? 'Reverse Tweezers Bottom' : 'Tweezers Bottom';
                            const signalText = isReverseMode ? `${patternName} SELL (REVERSED) - BLOCKED BY ALTERNATOR` : `${patternName} BUY - BLOCKED BY ALTERNATOR`;
                            addSignal(symbol, signalText, 'skipped');
                            
                            saveSettings();
                            return;
                        }
                    }

                    tradedCandles[symbol].add(candleKey);

                    const patternName = reverseCandleFilter ? 'Reverse Tweezers Bottom' : 'Tweezers Bottom';
                    const signalText = isReverseMode ? `${patternName} SELL (REVERSED)` : `${patternName} BUY`;
                    addSignal(symbol, signalText);

                    executeTrade(symbol, tradeType, candleKey).catch(error => {
                        logActivity(`‚ùå Trade failed for ${markets[symbol]}: ${error.message}`, 'error');
                    });
                }

                const sellSignal = checkTweezersTop(prevCandle, lastCandle, zeroClosingFilter, ignoreHeightFilter, reverseCandleFilter, minUpperWickSell, minLowerWickSell, matchingDiffSell);
                if (sellSignal) {
                    let tradeType = isReverseMode ? 'CALL' : 'PUT';

                    if (!ws || ws.readyState !== WebSocket.OPEN) {
                        logActivity(`‚ö†Ô∏è Signal skipped for ${markets[symbol]}: WebSocket not connected`, 'warning');
                        tradeStats.skipped++;
                        updateStats();
                        saveSettings();
                        return;
                    }

                    // Check Parabolic SAR filter
                    const parabolicSarFilterEnabled = document.getElementById('parabolicSarFilter').checked;
                    if (parabolicSarFilterEnabled) {
                        const tempTradeType = isReverseMode ? 'CALL' : 'PUT';
                        const sarSignal = checkParabolicSARSignal(symbol, tempTradeType);
                        if (!sarSignal) {
                            logActivity(`‚è≠Ô∏è Signal skipped for ${markets[symbol]}: Parabolic SAR filter not met for ${tempTradeType}`, 'warning');
                            tradeStats.skipped++;
                            updateStats();
                            saveSettings();
                            return;
                        }
                    }

                    const contractType = getContractType();
                    const hlDirection = getHLDirection();
                    
                    if (contractType === 'HIGHER_LOWER') {
                        if (symbol.startsWith('stpRNG')) {
                            logActivity(`‚ö†Ô∏è Signal skipped for ${markets[symbol]}: Step Index not supported for Higher/Lower`, 'warning');
                            tradeStats.skipped++;
                            updateStats();
                            saveSettings();
                            return;
                        }
                        
                        if (hlDirection === 'HIGHER_ONLY') {
                            logActivity(`‚ö†Ô∏è Signal skipped for ${markets[symbol]}: SELL signal but HIGHER ONLY mode active`, 'warning');
                            tradeStats.skipped++;
                            updateStats();
                            saveSettings();
                            return;
                        }
                        tradeType = isReverseMode ? 'CALL' : 'PUT';
                    }

                    // ALTERNATOR MODE
                    if (isAlternatorMode) {
                        const expectedType = getNextAlternatorTradeType(symbol);
                        if (tradeType !== expectedType) {
                            logActivity(`‚ö†Ô∏è [ALTERNATOR BLOCK] ${markets[symbol]}: SELL signal detected but expecting ${expectedType === 'CALL' ? 'BUY' : 'SELL'}. Signal skipped.`, 'warning');
                            tradeStats.skipped++;
                            updateStats();
                            
                            const patternName = reverseCandleFilter ? 'Reverse Tweezers Top' : 'Tweezers Top';
                            const signalText = isReverseMode ? `${patternName} BUY (REVERSED) - BLOCKED BY ALTERNATOR` : `${patternName} SELL - BLOCKED BY ALTERNATOR`;
                            addSignal(symbol, signalText, 'skipped');
                            
                            saveSettings();
                            return;
                        }
                    }

                    tradedCandles[symbol].add(candleKey);

                    const patternName = reverseCandleFilter ? 'Reverse Tweezers Top' : 'Tweezers Top';
                    const signalText = isReverseMode ? `${patternName} BUY (REVERSED)` : `${patternName} SELL`;
                    addSignal(symbol, signalText);

                    executeTrade(symbol, tradeType, candleKey).catch(error => {
                        logActivity(`‚ùå Trade failed for ${markets[symbol]}: ${error.message}`, 'error');
                    });
                }
            }
        }

        // ONE CANDLE MODE - Check single candle for BUY signal (Red candle)
        function checkOneCandleBuy(candle, zeroClosing, ignoreHeight, reverseCandle, minLowerWickPercent, minUpperWickPercent) {
            const isCandleRed = candle.close < candle.open;
            const isCandleGreen = candle.close > candle.open;
            
            if (reverseCandle) {
                if (!isCandleGreen) return false;
            } else {
                if (!isCandleRed) return false;
            }

            const candleRange = candle.high - candle.low;
            if (candleRange === 0) return false;

            const lowerWick = Math.min(candle.open, candle.close) - candle.low;
            const upperWick = candle.high - Math.max(candle.open, candle.close);

            if (lowerWick / candleRange < minLowerWickPercent) return false;

            if (zeroClosing) {
                if (upperWick !== 0) return false;
            } else {
                if (upperWick / candleRange > minUpperWickPercent) return false;
            }

            return true;
        }

        // ONE CANDLE MODE - Check single candle for SELL signal (Green candle)
        function checkOneCandleSell(candle, zeroClosing, ignoreHeight, reverseCandle, minUpperWickPercent, minLowerWickPercent) {
            const isCandleGreen = candle.close > candle.open;
            const isCandleRed = candle.close < candle.open;
            
            if (reverseCandle) {
                if (!isCandleRed) return false;
            } else {
                if (!isCandleGreen) return false;
            }

            const candleRange = candle.high - candle.low;
            if (candleRange === 0) return false;

            const upperWick = candle.high - Math.max(candle.open, candle.close);
            const lowerWick = Math.min(candle.open, candle.close) - candle.low;

            if (upperWick / candleRange < minUpperWickPercent) return false;

            if (zeroClosing) {
                if (lowerWick !== 0) return false;
            } else {
                if (lowerWick / candleRange > minLowerWickPercent) return false;
            }

            return true;
        }

        // TWO CANDLE MODE - Check Tweezers Bottom with all filters
        function checkTweezersBottom(candle1, candle2, zeroClosing, ignoreHeight, reverseCandle, minLowerWickPercent, minUpperWickPercent, matchingDiff) {
            const isCandle1Red = candle1.close < candle1.open;
            const isCandle1Green = candle1.close > candle1.open;
            
            if (reverseCandle) {
                if (!isCandle1Green) return false;
            } else {
                if (!isCandle1Red) return false;
            }

            const candle1Range = candle1.high - candle1.low;
            if (candle1Range === 0) return false;

            const candle1LowerWick = Math.min(candle1.open, candle1.close) - candle1.low;
            const candle1UpperWick = candle1.high - Math.max(candle1.open, candle1.close);

            if (candle1LowerWick / candle1Range < minLowerWickPercent) return false;

            if (zeroClosing) {
                if (candle1UpperWick !== 0) return false;
            } else {
                if (candle1UpperWick / candle1Range > minUpperWickPercent) return false;
            }

            const isCandle2Green = candle2.close > candle2.open;
            const isCandle2Red = candle2.close < candle2.open;
            
            if (reverseCandle) {
                if (!isCandle2Red) return false;
            } else {
                if (!isCandle2Green) return false;
            }

            const candle2Range = candle2.high - candle2.low;
            if (candle2Range === 0) return false;

            const candle2LowerWick = Math.min(candle2.open, candle2.close) - candle2.low;
            const candle2UpperWick = candle2.high - Math.max(candle2.open, candle2.close);

            if (candle2LowerWick / candle2Range < minLowerWickPercent) return false;

            if (zeroClosing) {
                if (candle2UpperWick !== 0) return false;
            } else {
                if (candle2UpperWick / candle2Range > minUpperWickPercent) return false;
            }

            const lowDiff = Math.abs(candle1.low - candle2.low) / candle1.low;
            if (lowDiff > matchingDiff) return false;

            if (ignoreHeight) {
                return true;
            } else {
                if (candle2.close < candle1.high) return false;
            }

            return true;
        }

        // TWO CANDLE MODE - Check Tweezers Top with all filters
        function checkTweezersTop(candle1, candle2, zeroClosing, ignoreHeight, reverseCandle, minUpperWickPercent, minLowerWickPercent, matchingDiff) {
            const isCandle1Green = candle1.close > candle1.open;
            const isCandle1Red = candle1.close < candle1.open;
            
            if (reverseCandle) {
                if (!isCandle1Red) return false;
            } else {
                if (!isCandle1Green) return false;
            }

            const candle1Range = candle1.high - candle1.low;
            if (candle1Range === 0) return false;

            const candle1UpperWick = candle1.high - Math.max(candle1.open, candle1.close);
            const candle1LowerWick = Math.min(candle1.open, candle1.close) - candle1.low;

            if (candle1UpperWick / candle1Range < minUpperWickPercent) return false;

            if (zeroClosing) {
                if (candle1LowerWick !== 0) return false;
            } else {
                if (candle1LowerWick / candle1Range > minLowerWickPercent) return false;
            }

            const isCandle2Red = candle2.close < candle2.open;
            const isCandle2Green = candle2.close > candle2.open;
            
            if (reverseCandle) {
                if (!isCandle2Green) return false;
            } else {
                if (!isCandle2Red) return false;
            }

            const candle2Range = candle2.high - candle2.low;
            if (candle2Range === 0) return false;

            const candle2UpperWick = candle2.high - Math.max(candle2.open, candle2.close);
            const candle2LowerWick = Math.min(candle2.open, candle2.close) - candle2.low;

            if (candle2UpperWick / candle2Range < minUpperWickPercent) return false;

            if (zeroClosing) {
                if (candle2LowerWick !== 0) return false;
            } else {
                if (candle2LowerWick / candle2Range > minLowerWickPercent) return false;
            }

            const highDiff = Math.abs(candle1.high - candle2.high) / candle1.high;
            if (highDiff > matchingDiff) return false;

            if (ignoreHeight) {
                return true;
            } else {
                if (candle2.close > candle1.low) return false;
            }

            return true;
        }

        // Add signal to monitor with status
        let signalCounter = 0;
        function addSignal(symbol, pattern, status = 'active') {
            const container = document.getElementById('signalsContainer');
            
            if (isFirstSignal) {
                container.innerHTML = '';
                isFirstSignal = false;
            }

            const signalId = `signal-${signalCounter++}`;
            
            const time = new Date().toLocaleTimeString();
            const signalDiv = document.createElement('div');
            signalDiv.className = `signal-item ${status}`;
            signalDiv.id = signalId;
            signalDiv.innerHTML = `<div class="signal-text">[${time}] ${markets[symbol]} - ${pattern}</div>`;
            
            container.insertBefore(signalDiv, container.firstChild);
            
            while (container.children.length > 50) {
                container.removeChild(container.lastChild);
            }

            return signalId;
        }

        // UPDATED: Execute trade with FAST BARRIER LOOKUP and SMART DECIMAL FORMATTING
        async function executeTrade(symbol, type, candleKey) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                const error = new Error('WebSocket not connected');
                logActivity(`Cannot execute trade: ${error.message}`, 'error');
                throw error;
            }

            const stake = parseFloat(document.getElementById('stakeAmount').value);
            const durationType = getDurationType();
            const durationValue = parseInt(document.getElementById('durationValue').value);
            const contractType = getContractType();

            const reqId = ++requestIdCounter;

            let proposal = {
                proposal: 1,
                amount: stake,
                basis: 'stake',
                contract_type: type,
                currency: accountInfo.currency,
                duration: durationValue,
                duration_unit: durationType,
                symbol: symbol,
                req_id: reqId
            };

            // UPDATED: Fast barrier lookup - pre-calculated barriers only
            if (contractType === 'HIGHER_LOWER') {
                // Check if we have a pre-calculated barrier ready
                if (calculatedBarriers[symbol] && calculatedBarriers[symbol][type] !== undefined) {
                    const barrier = calculatedBarriers[symbol][type];
                    if (barrier === null) {
                        logActivity(`‚ö†Ô∏è Trade skipped: Barrier calculation failed for ${markets[symbol]}`, 'warning');
                        tradeStats.skipped++;
                        updateStats();
                        saveSettings();
                        return;
                    }
                    
                    const decimals = getSmartDecimals(symbol);
                    proposal.barrier = barrier > 0 ? `+${barrier.toFixed(decimals)}` : `${barrier.toFixed(decimals)}`;
                } else {
                    // Fallback: If not calculated yet, trigger calculation for NEXT time, but skip this trade to avoid lag
                    logActivity(`‚ö†Ô∏è Trade skipped: Barrier not ready for ${markets[symbol]}. Calculating now...`, 'warning');
                    getBarrierForContract(symbol, type);
                    tradeStats.skipped++;
                    updateStats();
                    saveSettings();
                    return; 
                }
            }

            try {
                ws.send(JSON.stringify(proposal));
                
                const proposalResponse = await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        pendingProposals.delete(reqId);
                        reject(new Error('Proposal timeout (15s)'));
                    }, 15000); // ‚úÖ FIX #1: Increased from 5s to 15s
                    
                    pendingProposals.set(reqId, { resolve, reject, timeout });
                });

                if (pendingProposals.has(reqId)) {
                    clearTimeout(pendingProposals.get(reqId).timeout);
                    pendingProposals.delete(reqId);
                }

                if (proposalResponse.proposal) {
                    const proposalId = proposalResponse.proposal.id;
                    const tradeInfo = {
                        symbol: symbol,
                        type: type,
                        stake: stake,
                        candle_time: candleKey
                    };
                    
                    pendingTrades.set(proposalId, tradeInfo);
                    
                    ws.send(JSON.stringify({
                        buy: proposalId,
                        price: stake
                    }));

                    // ALTERNATOR MODE: Update state after successful trade execution
                    if (isAlternatorMode) {
                        updateAlternatorState(symbol, type);
                        saveSettings();
                    }

                    logActivity(`‚úÖ Trade executed: ${type} on ${markets[symbol]} - Stake: ${stake}`, 'success');
                }
            } catch (error) {
                logActivity(`‚ùå Trade execution failed for ${markets[symbol]}: ${error.message}`, 'error');
                throw error;
            }
        }

        // Update statistics
        function updateStats() {
            document.getElementById('totalTrades').textContent = tradeStats.total;
            document.getElementById('totalWins').textContent = tradeStats.wins;
            document.getElementById('totalLosses').textContent = tradeStats.losses;
            document.getElementById('totalSkipped').textContent = tradeStats.skipped;
            
            const plElement = document.getElementById('profitLoss');
            plElement.textContent = tradeStats.profitLoss.toFixed(2);
            plElement.className = 'stat-value ' + (tradeStats.profitLoss >= 0 ? 'profit' : 'loss');
        }

        // Update trade history table with better handling
        function updateTradeHistoryTable() {
            const tbody = document.getElementById('historyTableBody');
            
            if (!Array.isArray(tradeHistory)) {
                console.error('tradeHistory is not an array, reinitializing');
                tradeHistory = [];
            }
            
            if (tradeHistory.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #8899aa;">No trades yet</td></tr>';
                updateTradeCountDisplay();
                return;
            }

            tbody.innerHTML = '';
            
            const displayCount = Math.min(tradeHistory.length, 100);
            
            for (let i = 0; i < displayCount; i++) {
                const trade = tradeHistory[i];
                
                if (!trade || typeof trade !== 'object') {
                    console.warn(`Invalid trade at index ${i}`, trade);
                    continue;
                }
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${i + 1}</td>
                    <td>${trade.time || '-'}</td>
                    <td>${trade.market || 'Unknown'}</td>
                    <td>${trade.type || '-'}</td>
                    <td>${trade.stake || '0.00'}</td>
                    <td class="${trade.isWin ? 'result-win' : 'result-loss'}">${trade.result || '0.00'}</td>
                `;
                tbody.appendChild(row);
            }
            
            tbody.offsetHeight;
            
            updateTradeCountDisplay();
            
            console.log(`[TABLE UPDATE] Displayed ${displayCount} trades from ${tradeHistory.length} total`);
        }

        // UPDATED: Start Auto Trading with 10s Retry Loop
        async function startAutoTrading() {
            if (!isLoggedIn) {
                logActivity('Please login first', 'error');
                return;
            }

            if (!ws || ws.readyState !== WebSocket.OPEN) {
                logActivity('WebSocket not connected. Please check connection.', 'error');
                return;
            }

            // 1. Initialize State
            isAutoTrading = true;
            activation_time = Math.floor(Date.now() / 1000);
            processedContracts.clear();
            
            // Clear chart data
            Object.keys(markets).forEach(symbol => {
                candleData[symbol] = [];
                currentOHLC[symbol] = undefined;
                currentMinute[symbol] = undefined;
                tradedCandles[symbol].clear();
            });
            
            if (isAlternatorMode) {
                resetAlternatorStates();
            }

            const contractType = getContractType();
            const hlDirection = getHLDirection();

            // 2. HIGHER/LOWER LOGIC: Persistent Retry Loop
            if (contractType === 'HIGHER_LOWER') {
                let directionText = 'Both (Higher & Lower)';
                if (hlDirection === 'HIGHER_ONLY') directionText = 'Higher Only (Buy)';
                if (hlDirection === 'LOWER_ONLY') directionText = 'Lower Only (Sell)';
                logActivity(`Direction: ${directionText}`, 'info');
                
                logActivity('‚è≥ Pausing signals to calculate ALL barriers...', 'warning');
                
                // Disable button and show status
                document.getElementById('autoTradeBtn').disabled = true;
                document.getElementById('autoTradeBtn').textContent = 'Calibrating...';
                
                // Clear old barriers
                calculatedBarriers = {}; 
                
                let attempts = 0;
                
                // THE LOOP: Keep retrying until EVERYTHING is successful
                while (isAutoTrading) {
                    // Step A: Find which markets are missing/failed
                    const missingCount = queueMissingBarriers();
                    
                    // Step B: Success Check
                    if (missingCount === 0) {
                        logActivity('‚úÖ All barriers successfully calculated! System Armed.', 'success');
                        break;
                    }

                    // Step C: Retry Logic
                    attempts++;
                    if (attempts > 1) {
                        logActivity(`‚ö†Ô∏è Retry #${attempts-1}: Retrying ${missingCount} failed markets...`, 'warning');
                        logActivity('‚è≥ Waiting 10s before retry to prevent rate limits...', 'info');
                        
                        await new Promise(r => setTimeout(r, 10000));
                    } else {
                        logActivity(`Starting calculation for ${missingCount} contracts...`, 'info');
                    }

                    // Step D: Run the processor
                    try {
                        await processBarrierCalculationQueue();
                    } catch (e) {
                        console.error("Queue error:", e);
                    }
                }
                
                // Safety: If user stopped bot during the 10s wait
                if (!isAutoTrading) {
                    logActivity('Bot stopped during calculation.', 'warning');
                    document.getElementById('autoTradeBtn').disabled = false;
                    document.getElementById('autoTradeBtn').textContent = 'Start Auto Trade';
                    return;
                }
            }

            // 3. RESUME TRADING
            subscribeToActiveMarkets();
            
            // 4. Update UI
            document.getElementById('autoTradeBtn').disabled = false;
            document.getElementById('autoTradeBtn').textContent = 'Stop Auto Trade';
            document.getElementById('autoTradeBtn').className = 'btn btn-danger';
            
            const statusText = document.getElementById('statusText');
            const statusDot = document.getElementById('statusDot');
            statusText.textContent = 'Bot Active - Analyzing Markets';
            statusText.className = 'status-text active';
            statusDot.className = 'pulse-dot active';

            const container = document.getElementById('signalsContainer');
            container.innerHTML = '<div class="signal-item"><div class="signal-text">Bot activated. Monitoring markets for signals...</div></div>';

            const oneCandleFilter = document.getElementById('oneCandleFilter').checked;
            let requiredCandles = oneCandleFilter ? 1 : 3;
            
            logActivity('Auto trading started', 'success');
            logActivity(`Activation time set: ${new Date(activation_time * 1000).toLocaleTimeString()}`, 'info');
            logActivity(`Mode: ${oneCandleFilter ? 'ONE CANDLE' : 'TWO CANDLE (Tweezers)'}`, 'info');
            
            // Log active filters
            const activeFilters = [];
            if (oneCandleFilter) activeFilters.push('One Candle Mode');
            if (document.getElementById('zeroClosingFilter').checked) activeFilters.push('Zero Closing');
            if (document.getElementById('ignoreHeightFilter').checked) activeFilters.push('Ignore Height');
            if (document.getElementById('reverseCandleFilter').checked) activeFilters.push('Reverse Candle');
            
            if (activeFilters.length > 0) logActivity(`Active filters: ${activeFilters.join(', ')}`, 'info');
            
            updateCandleCounter();

            // 5. SMART WATCHDOG
            if (candleWatchdogTimer) clearInterval(candleWatchdogTimer);
            
            candleWatchdogTimer = setInterval(() => {
                if (!isTimeSynced) return;

                if (document.getElementById('zeroClosingFilter').checked) {
                    return; 
                }

                const now = Date.now();
                const estimatedServerTime = now - serverTimeOffset;
                const serverMinuteStart = Math.floor(estimatedServerTime / 1000 / 60) * 60;
                const timeIntoMinute = estimatedServerTime % 60000;

                Object.keys(activeMarkets).forEach(symbol => {
                    if (!activeMarkets[symbol] || !marketSubscriptions[symbol]) return;
                    if (currentMinute[symbol] === undefined) return;

                    if (serverMinuteStart > currentMinute[symbol]) {
                        const is1HZ = symbol.includes('1HZ') || symbol.includes('1s');
                        const gracePeriod = is1HZ ? 200 : 1500;

                        if (timeIntoMinute > gracePeriod) {
                            const lastPrice = currentOHLC[symbol].close;
                            if (!lastCandleProcessTime[symbol] || (now - lastCandleProcessTime[symbol] > 2000)) {
                                finalizeCandle(symbol, serverMinuteStart, lastPrice);
                            }
                        }
                    }
                });
            }, 100);

            saveSettings();
        }

        // Stop auto trading
        function stopAutoTrading() {
            isAutoTrading = false;
            activation_time = 0;
            
            document.getElementById('autoTradeBtn').textContent = 'Start Auto Trade';
            document.getElementById('autoTradeBtn').className = 'btn btn-success';
            
            const statusText = document.getElementById('statusText');
            const statusDot = document.getElementById('statusDot');
            statusText.textContent = 'Bot Inactive';
            statusText.className = 'status-text';
            statusDot.className = 'pulse-dot';

            logActivity('Auto trading stopped', 'error');

            unsubscribeFromAllMarkets();

            const container = document.getElementById('signalsContainer');
            container.innerHTML = '<div class="signal-item"><div class="signal-text">Waiting for bot activation...</div></div>';
            
            document.getElementById('candleCounter').classList.add('hidden');
            
            if (candleWatchdogTimer) {
                clearInterval(candleWatchdogTimer);
                candleWatchdogTimer = null;
            }

            saveSettings();
        }

        // Update reverse mode button
        function updateReverseModeButton() {
            const btn = document.getElementById('reverseModeBtn');
            if (isReverseMode) {
                btn.textContent = 'Reverse Mode: ON';
                btn.className = 'btn btn-warning';
            } else {
                btn.textContent = 'Reverse Mode: OFF';
                btn.className = 'btn btn-warning';
            }
        }

        // Update alternator mode button
        function updateAlternatorModeButton() {
            const btn = document.getElementById('alternatorModeBtn');
            if (isAlternatorMode) {
                btn.textContent = 'Alternator: ON';
                btn.className = 'btn btn-info';
            } else {
                btn.textContent = 'Alternator: OFF';
                btn.className = 'btn btn-info';
            }
        }

        // Auto trade button
        document.getElementById('autoTradeBtn').addEventListener('click', () => {
            if (isAutoTrading) {
                stopAutoTrading();
            } else {
                startAutoTrading();
            }
        });

        // Reverse mode button
        document.getElementById('reverseModeBtn').addEventListener('click', () => {
            isReverseMode = !isReverseMode;
            updateReverseModeButton();
            updateReverseModeIndicator();
            checkFilterConflicts();
            saveSettings();
            
            if (isReverseMode) {
                logActivity('Reverse Mode ENABLED: Buy signals will execute Sell, Sell signals will execute Buy', 'success');
            } else {
                logActivity('Reverse Mode DISABLED: Normal trading mode', 'info');
            }
        });

        // ALTERNATOR MODE button
        document.getElementById('alternatorModeBtn').addEventListener('click', () => {
            isAlternatorMode = !isAlternatorMode;
            updateAlternatorModeButton();
            updateAlternatorModeIndicator();
            checkFilterConflicts();
            
            if (isAlternatorMode) {
                resetAlternatorStates();
                logActivity('‚úÖ ALTERNATOR MODE ENABLED: BUY-SELL-BUY pattern enforced separately for each market', 'success');
                logActivity('[ALTERNATOR] Each market will alternate: CALL‚ÜíPUT‚ÜíCALL‚ÜíPUT...', 'success');
                logActivity('[ALTERNATOR] All markets reset to BUY (CALL) starting position', 'success');
            } else {
                logActivity('ALTERNATOR MODE DISABLED: Normal signal processing', 'info');
            }
            
            saveSettings();
        });

        // Contract type change listeners
        document.getElementsByName('contractType').forEach(radio => {
            radio.addEventListener('change', () => {
                updateContractTypeFields();
                saveSettings();
                
                const contractType = getContractType();
                if (contractType === 'RISE_FALL') {
                    logActivity('Contract type changed to: Rise/Fall', 'info');
                    calculatedBarriers = {};
                    barrierCalculationQueue = [];
                } else {
                    logActivity('Contract type changed to: Higher/Lower', 'info');
                    logActivity('Higher/Lower supports: Volatility 10/25/50/75/100 (all variants), minimum durations: 5 ticks, 15 seconds, 1 minute', 'info');
                    
                    if (isAutoTrading) {
                        const durationType = getDurationType();
                        const durationValue = parseInt(document.getElementById('durationValue').value);
                        
                        const supportedDurations = {
                            't': { min: 5, max: 10 },
                            's': { min: 15, max: 3600 },
                            'm': { min: 1, max: 60 }
                        };
                        
                        const limits = supportedDurations[durationType];
                        if (limits && (durationValue < limits.min || durationValue > limits.max)) {
                            logActivity(`‚ö†Ô∏è Warning: Current duration (${durationValue}${durationType}) may not be supported for Higher/Lower. Recommended: ${limits.min}-${limits.max}${durationType}`, 'warning');
                        }
                        
                        recalculateAllBarriers();
                    }
                }
            });
        });

        // Higher/Lower direction change listeners
        document.getElementsByName('hlDirection').forEach(radio => {
            radio.addEventListener('change', () => {
                const direction = getHLDirection();
                let directionText = 'Both (Higher & Lower)';
                if (direction === 'HIGHER_ONLY') directionText = 'Higher Only (Buy)';
                if (direction === 'LOWER_ONLY') directionText = 'Lower Only (Sell)';
                
                logActivity(`Higher/Lower direction changed to: ${directionText}`, 'info');
                updateContractTypeIndicator();
                saveSettings();
                
                if (isAutoTrading && getContractType() === 'HIGHER_LOWER') {
                    recalculateAllBarriers();
                }
            });
        });

        // Payout percentage change listener
        document.getElementById('payoutPercentage').addEventListener('change', () => {
            const payout = document.getElementById('payoutPercentage').value;
            logActivity(`Payout percentage changed to: ${payout}% profit`, 'info');
            saveSettings();
            
            if (isAutoTrading && getContractType() === 'HIGHER_LOWER') {
                recalculateAllBarriers();
            }
        });

        // Clear history button with double-tap confirmation
        document.getElementById('clearHistoryBtn').addEventListener('click', () => {
            const btn = document.getElementById('clearHistoryBtn');
            
            if (!clearHistoryConfirmState) {
                clearHistoryConfirmState = true;
                btn.textContent = 'Are you sure?';
                btn.classList.add('confirm-state');
                logActivity('Click again to confirm clearing trade history', 'warning');
                
                clearHistoryTimeout = setTimeout(() => {
                    resetClearHistoryButton();
                    logActivity('Clear history cancelled', 'info');
                }, 3000);
            } else {
                clearTimeout(clearHistoryTimeout);
                
                tradeHistory = [];
                tradeStats = { total: 0, wins: 0, losses: 0, skipped: 0, profitLoss: 0 };
                processedContracts.clear();
                updateStats();
                updateTradeHistoryTable();
                saveSettings();
                
                logActivity('Trade history cleared successfully', 'success');
                resetClearHistoryButton();
            }
        });

        // Filter change listeners
        document.getElementById('zeroClosingFilter').addEventListener('change', () => {
            const enabled = document.getElementById('zeroClosingFilter').checked;
            logActivity(`Zero closing filter (Perfect 0) ${enabled ? 'enabled' : 'disabled'}`);
            saveSettings();
        });

        document.getElementById('ignoreHeightFilter').addEventListener('change', () => {
            const enabled = document.getElementById('ignoreHeightFilter').checked;
            logActivity(`Ignore height filter ${enabled ? 'enabled' : 'disabled'}`);
            checkFilterConflicts();
            saveSettings();
        });

        document.getElementById('oneCandleFilter').addEventListener('change', () => {
            const enabled = document.getElementById('oneCandleFilter').checked;
            logActivity(`One Candle filter ${enabled ? 'enabled (Single candle: Red=Buy, Green=Sell)' : 'disabled'}`);
            updateOneCandleIndicator();
            checkFilterConflicts();
            if (isAutoTrading) {
                updateCandleCounter();
            }
            saveSettings();
        });

        document.getElementById('reverseCandleFilter').addEventListener('change', () => {
            const enabled = document.getElementById('reverseCandleFilter').checked;
            logActivity(`Reverse Candle filter ${enabled ? 'enabled' : 'disabled'}`);
            saveSettings();
        });

        document.getElementById('parabolicSarFilter').addEventListener('change', () => {
            const enabled = document.getElementById('parabolicSarFilter').checked;
            logActivity(`Parabolic SAR filter ${enabled ? 'enabled' : 'disabled'}`);
            saveSettings();
        });

        // Duration type radio button listeners
        document.getElementsByName('durationType').forEach(radio => {
            radio.addEventListener('change', () => {
                const typeLabels = { 't': 'Ticks', 's': 'Seconds', 'm': 'Minutes' };
                logActivity(`Duration type updated to ${typeLabels[radio.value]}`);
                saveSettings();
                
                if (isAutoTrading && getContractType() === 'HIGHER_LOWER') {
                    recalculateAllBarriers();
                }
            });
        });
    
        // Settings change listeners
        document.getElementById('stakeAmount').addEventListener('change', () => {
            logActivity(`Stake amount updated to ${document.getElementById('stakeAmount').value}`);
            saveSettings();
        });

        document.getElementById('stopLoss').addEventListener('change', () => {
            logActivity(`Stop loss updated to ${document.getElementById('stopLoss').value}`);
            saveSettings();
        });

        document.getElementById('takeProfit').addEventListener('change', () => {
            logActivity(`Take profit updated to ${document.getElementById('takeProfit').value}`);
            saveSettings();
        });

        document.getElementById('durationValue').addEventListener('change', () => {
            logActivity(`Duration value updated to ${document.getElementById('durationValue').value}`);
            saveSettings();
            
            if (isAutoTrading && getContractType() === 'HIGHER_LOWER') {
                recalculateAllBarriers();
            }
        });

        document.getElementById('minLowerWickBuy').addEventListener('blur', saveSettings);
        document.getElementById('minUpperWickSell').addEventListener('blur', saveSettings);
        document.getElementById('minUpperWickBuy').addEventListener('blur', saveSettings);
        document.getElementById('minLowerWickSell').addEventListener('blur', saveSettings);
        document.getElementById('matchingDiffBuy').addEventListener('blur', saveSettings);
        document.getElementById('matchingDiffSell').addEventListener('blur', saveSettings);

        // Monitor WebSocket health
        function checkWebSocketHealth() {
            if (isLoggedIn && ws && ws.readyState === WebSocket.OPEN) {
                const timeSinceLastMessage = Date.now() - lastHeartbeat;
                
                if (timeSinceLastMessage > 30000) {
                    ws.send(JSON.stringify({ ping: 1 }));
                }

                if (timeSinceLastMessage > 60000) {
                    logActivity('No response from server. Connection may be lost.', 'warning');
                }
            }
        }

        setInterval(checkWebSocketHealth, 10000);

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveSettings();
                logActivity('Settings saved manually', 'success');
            }

            if ((e.ctrlKey || e.metaKey) && e.key === ' ') {
                e.preventDefault();
                if (isLoggedIn && document.getElementById('autoTradeBtn').disabled === false) {
                    if (isAutoTrading) {
                        stopAutoTrading();
                    } else {
                        startAutoTrading();
                    }
                }
            }
        });

        // Visual connection status
        function updateConnectionStatus() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                document.body.style.borderTop = '3px solid #ff4757';
            } else {
                document.body.style.borderTop = '3px solid #2ecc71';
            }
        }

        setInterval(updateConnectionStatus, 1000);

        // Network status monitoring
        window.addEventListener('online', () => {
            logActivity('Network connection restored', 'success');
            updateConnectionBadge('connected');
            
            if (isLoggedIn && (!ws || ws.readyState !== WebSocket.OPEN)) {
                const token = sessionStorage.getItem('derivToken');
                if (token) {
                    logActivity('Attempting to reconnect...', 'info');
                    connectWebSocket(token, true).catch(err => {
                        logActivity('Reconnection failed', 'error');
                    });
                }
            }
        });

        window.addEventListener('offline', () => {
            logActivity('Network connection lost!', 'error');
            updateConnectionBadge('disconnected');
            
            if (sessionTimer) {
                stopSessionTimer();
                logActivity('Session timer reset due to network failure', 'warning');
            }
        });

        // Auto-reconnect on page refresh/reload
        window.addEventListener('beforeunload', () => {
            saveSettings();
        });

        window.addEventListener('load', () => {
            const savedToken = sessionStorage.getItem('derivToken');
            const wasAutoTrading = sessionStorage.getItem('wasAutoTrading') === 'true';
            
            if (savedToken && !isLoggedIn) {
                document.getElementById('apiToken').value = savedToken;
                logActivity('Saved token found. Auto-login in 0.5s...', 'info');
                
                setTimeout(() => {
                    document.getElementById('loginBtn').click();
                    
                    if (wasAutoTrading) {
                        setTimeout(() => {
                            if (isLoggedIn && !isAutoTrading) {
                                logActivity('Resuming auto trading after refresh...', 'info');
                                startAutoTrading();
                            }
                        }, 2000);
                    }
                }, 500);
            }
        });

        // Error boundaries
        window.addEventListener('error', (e) => {
            logActivity(`Unexpected error: ${e.message}`, 'error');
            console.error('Error details:', e);
        });

        window.addEventListener('unhandledrejection', (e) => {
            logActivity(`Unhandled promise rejection: ${e.reason}`, 'error');
            console.error('Promise rejection details:', e);
        });

        // Export trade history
        window.exportTradeHistory = function() {
            if (tradeHistory.length === 0) {
                logActivity('No trade history to export', 'error');
                return;
            }

            const csv = [
                ['S/N', 'Time', 'Market', 'Type', 'Stake', 'Result'],
                ...tradeHistory.map((trade, index) => [
                    index + 1,
                    trade.time,
                    trade.market,
                    trade.type,
                    trade.stake,
                    trade.result
                ])
            ].map(row => row.join(',')).join('\n');

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ben-sniper-trades-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            URL.revokeObjectURL(url);

            logActivity('Trade history exported successfully', 'success');
        };

        // Initialize app
        loadSettings();
        renderMarkets();
        logActivity('System initialized. Please login to continue.', 'success');
        
        // FLOATING BROWSER FIX: Log visibility changes but don't pause trading
        document.addEventListener('visibilitychange', () => {
            const wasVisible = isPageVisible;
            isPageVisible = !document.hidden;
            lastVisibilityChange = Date.now();
            
            if (isPageVisible && !wasVisible) {
                logActivity('üîÑ Browser window restored', 'info');
            } else if (!isPageVisible && wasVisible) {
                logActivity('‚è∏Ô∏è Browser window minimized (still active)', 'info');
            }
        });

        // Log system information
        logActivity(`Browser: ${navigator.userAgent}`, 'info');
        logActivity(`Available markets: ${Object.keys(markets).length}`, 'info');

        // Log startup complete
        setTimeout(() => {
            logActivity('üéØ Ben Sniper Bot - FIXED VERSION initialized successfully!', 'success');
            logActivity('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
            logActivity('üîß SETTLEMENT TRACKING FIXES ACTIVE:', 'success');
            logActivity('‚úÖ FIX #1: Proposal timeout increased to 15 seconds', 'success');
            logActivity('‚úÖ FIX #2: Enhanced buy error handling with cleanup', 'success');
            logActivity('‚úÖ FIX #3: Contract recovery system (30s checks)', 'success');
            logActivity('‚úÖ FIX #4: Re-subscription after reconnection', 'success');
            logActivity('‚úÖ FIX #5: Proper cleanup on trade errors', 'success');
            logActivity('‚úÖ FIX #6: Open contracts tracking system', 'success');
            logActivity('‚úÖ FIX #7: Periodic contract status checking', 'success');
            logActivity('‚úÖ FIX #8: Enhanced subscription error handling', 'success');
            logActivity('‚úÖ FIX #9: Better WebSocket disconnection handling', 'success');
            logActivity('‚úÖ FIX #10: Contract ID validation before processing', 'success');
            logActivity('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
            logActivity('üìä ALL ORIGINAL FEATURES PRESERVED:', 'info');
            logActivity('‚úÖ CRITICAL FIX COMPLETE: All CALL/PUT logic corrected throughout codebase', 'success');
            logActivity('‚úÖ FIX #1: Contract type validation uses CALL/PUT only', 'success');
            logActivity('‚úÖ FIX #2: Barrier calculation uses CALL/PUT only with correct payout conversion', 'success');
            logActivity('‚úÖ FIX #3: Signal generation uses CALL/PUT only', 'success');
            logActivity('‚úÖ FIX #4: Trade execution uses CALL/PUT only with pre-calculated barriers', 'success');
            logActivity('‚úÖ FIX #5: Alternator state tracking uses CALL/PUT only', 'success');
            logActivity('‚úÖ SMART AUTO-DETECTION: Market-specific decimal precision system active', 'success');
            logActivity('‚úÖ SMART AUTO-DETECTION: Automatic pip detection from Deriv API', 'success');
            logActivity('‚úÖ SMART AUTO-DETECTION: Intelligent fallback for V100 (2 decimals) and others (3 decimals)', 'success');
            logActivity('‚úÖ SMART AUTO-DETECTION: Eliminates InvalidBarrier errors completely', 'success');
            logActivity('‚úÖ PAYOUT FIX: Converts profit % to total payout % (95% profit = 195% total payout)', 'success');
            logActivity('‚úÖ SPEED FIX: Pre-calculates barriers on bot start for instant trade entry', 'success');
            logActivity('‚úÖ SPEED FIX: Skips trades if barrier not ready (calculates in background)', 'success');
            logActivity('‚úÖ BARRIER FIX: Removed currentSpot dependency - barriers calculate without price check', 'success');
            logActivity('‚úÖ RETRY FIX: 10-second retry delay for failed barrier calculations', 'success');
            logActivity('‚úÖ NEW: Visual barrier calculation monitor with progress tracking', 'success');
            logActivity('‚úÖ NEW: Real-time barrier calculation status display', 'success');
            logActivity('‚úÖ NEW: Per-market barrier calculation progress indicators', 'success');
            logActivity('‚úÖ Skipped signals now tracked in statistics', 'success');
            logActivity('‚úÖ Alternator Mode: Per-market BUY-SELL-BUY enforcement', 'success');
            logActivity('‚úÖ Trade history: Duplicate prevention enabled', 'success');
            logActivity('‚úÖ Floating browser: Race condition prevention active', 'success');
            logActivity('‚úÖ AUTO-REFRESH REMOVED: Feature completely removed from the bot', 'success');
            logActivity('Features: One Candle, Zero Closing, Ignore Height, Reverse Candle, Alternator, Higher/Lower', 'success');
            logActivity('Modes: TWO CANDLE (Tweezers) or ONE CANDLE (Single candle pattern)', 'success');
            logActivity('Contracts: RISE/FALL (CALL/PUT) or HIGHER/LOWER (CALL/PUT with smart barriers)', 'success');
            logActivity('Signal Flow: Check Already Traded ‚Üí Validate WS ‚Üí Mark Traded ‚Üí Display Signal ‚Üí Execute Trade', 'success');
            logActivity('Auto-Reconnect: Enabled with exponential backoff', 'success');
            logActivity('Higher/Lower: Supported symbols - Volatility 10/25/50/75/100 (all variants)', 'success');
            logActivity('Higher/Lower: Duration limits - 5-10 ticks, 15-3600 seconds, 1-60 minutes', 'success');
            logActivity('Barrier Calculation: PRE-CALCULATED on bot start for instant entry (no lag)', 'success');
            logActivity('Barrier Retry: 10-second delay between retry attempts to prevent rate limiting', 'success');
            logActivity('Smart Decimals: Auto-detects correct precision for each market (no more InvalidBarrier)', 'success');
            logActivity('Payout Logic: Input is PROFIT % (e.g., 95%), bot converts to 195% total payout', 'success');
            logActivity('Tip: Press Ctrl+Space to toggle auto trading', 'info');
            logActivity('Tip: Use exportTradeHistory() in console to export trades', 'info');
            logActivity('App ID: 1089 | All systems operational | Settlement tracking active', 'success');
        }, 1000);
    </script>
</body>
</html>